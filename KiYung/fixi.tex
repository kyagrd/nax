\chapter{System \Fixi}\label{ch:fixi}

It is known that primitive recursion is not embeddable in System \F\ since
induction is not derivable in second-order dependent type theory
\cite{Geuvers01}. For similar reasons, it is strongly believed that
primitive recursion is not embeddable in System \Fw. 
\citet{AbeMat04} designed \Fixw, an extension of \Fw\ with polarized kinds and
equi-recursive fixpoint type operator, in order to embed primitive recursion
over regular datatypes and type-indexed datatypes.
We present \Fixi, an extension of \Fixw\ with erasable term-indices,
to embed primitive recursion over term-indexed datatypes.

The organization of this chapter is analogous to the chapter on System \Fi\
(Chapter \ref{ch:fi}). Since the extensions from \Fixw\ to \Fixi\ is
basically the same as the extensions from \Fw\ to \Fi,
the description for \Fixi\ will be focused on the differences between \Fi.
Readers may refer back to Chapter \ref{ch:fi} for the details that are
in common with System~\Fi.

We describe syntax and typing rules (\S\ref{sec:fixi:def}),
illustrate embeddings of primitive recursion (\S\ref{sec:fixi:data})
and discuss embeddings of course-of-values primitive recursion
(\S\ref{sec:fixi:cv}) for term-indexed datatypes. Lastly, we
discuss the metatheory of \Fixi\ (\S\ref{sec:fixi:theory}).

\section{System \Fixi} \label{sec:fixi:def}
The syntax and rules of System~\Fi\ are described in
Figures \ref{fig:Fixi}, \ref{fig:Fixi2} and~\ref{fig:eqFixi}.
The extensions new to System~\Fixi, which are not original part of
either System~\Fw\ or System~\Fixw\ are highlighted by either
\dbox{dashed boxes} or \newFi{\text{grey boxes}}.

The extensions, which are not originally part of System~\Fixw, are highlighted
by \newFi{\text{grey boxes}}. Those extensions in grey boxes are to support
term indexing.  Eliding all the grey boxes from Figures~\ref{fig:Fixi},
\ref{fig:Fixi2} and~\ref{fig:eqFixi},
one obtains a version of System~\Fixw\ with typing contexts separated into
two parts.\footnote{The original description of \Fixw \cite{AbeMat04} has
one combined typing context.}

The extensions, which are not originally part of System \Fw\ but
present in System~\Fixw, are highlighted by \dbox{dashed boxes}.
Those extensions in dashed boxes are to support equi-recursive types. 
Eliding all the dashed boxes, as well as all the grey boxes,
from Figures~\ref{fig:Fixi}, \ref{fig:Fixi2} and~\ref{fig:eqFixi}, one obtains
the Curry-style System \Fw\ with typing contexts separated into two parts.


\begin{figure}\begin{singlespace}
	\small
\paragraph{Syntax:}
\begin{align*}
\!\!\!\!\!\!\!\!&\text{Sort}
 	& \square
	\\
\!\!\!\!\!\!\!\!&\text{Term Variables}
 	& x,i
\\
\!\!\!\!\!\!\!\!&\text{Type Constructor Variables}
 	& X
\\
\!\!\!\!\!\!\!\!&\text{\dbox{Polarities}}
	& \dbox{$p$} &~ ::= + \mid - \mid 0
\\
\!\!\!\!\!\!\!\!&\text{Kinds}
 	& \kappa		&~ ::= ~ *
				\mid \dbox{$p\kappa$} -> \kappa
				\mid \newFi{A -> \kappa}
\\
\!\!\!\!\!\!\!\!&\text{Type Constructors}
	& A,B,F,G		&~ ::= ~ X
				\mid A -> B
				\mid \dbox{$\fix F$} \\ &&& ~\quad
				\mid \lambda \dbox{$X^{p\kappa}$}.F
				\mid F\,G
				\mid \forall X^\kappa . B \\ &&& ~\quad
				\mid \newFi{\lambda i^A.F
				\mid F\,\{s\}
				\mid \forall i^A . B}
\\
\!\!\!\!\!\!\!\!&\text{Terms}
	& r,s,t			&~ ::= ~ x \mid \lambda x.t \mid r\;s
\\
\!\!\!\!\!\!\!\!&\text{Typing Contexts}
	& \Delta		&~ ::= ~ \cdot
				\mid \Delta,\dbox{$X^{p\kappa}$}
				\mid \newFi{\Delta, i^A} \\
&	& \Gamma		&~ ::= ~ \cdot
				\mid \Gamma, x : A
\end{align*}
\paragraph{Reduction:} \fbox{$t \rightsquigarrow t'$}
\[ 
   \inference{}{(\lambda x.t)\,s \rightsquigarrow t[s/x]}
 ~~~~
   \inference{t \rightsquigarrow t'}{\lambda x.t \rightsquigarrow \lambda x.t'}
 ~~~~
   \inference{r \rightsquigarrow r'}{r\;s \rightsquigarrow r'\;s}
 ~~~~
   \inference{s \rightsquigarrow s'}{r\;s \rightsquigarrow r\;s'}
\]
~\\
\end{singlespace}
\caption{Syntax and Reduction rules of \Fixi}
\label{fig:Fixi}
\end{figure}

\begin{figure}\begin{singlespace}\small
\paragraph{Well-formed typing contexts:}
\[ \fbox{$|- \Delta$}
 ~~~~
   \inference{}{|- \cdot}
 ~~~
   \inference{|- \Delta & |- \kappa:\square}{|- \Delta,\dbox{$X^{p\kappa}$}}
      \big( X\notin\dom(\Delta) \big)
 ~~~ \newFi{
   \inference{|- \Delta & \cdot |- A:*}{|- \Delta,i^A}
      \big( i\notin\dom(\Delta) \big) }
\]
$ \fbox{$\Delta |- \Gamma$}
 ~~~~
   \inference{|- \Delta}{\dbox{$0\Delta$} |- \cdot}
 ~~~~
   \inference{\Delta |- \Gamma & \Delta |- A:*}{
              \Delta |- \Gamma,x:A}
      \big( x\notin\dom(\Gamma) \big)
$ \vskip1ex ~
\paragraph{Sorting:} \fbox{$|- \kappa : \square$}
$ \quad
  \inference[($A$)]{}{|- *:\square}
 ~~~
   \inference[($R$)]{|- \kappa:\square & |- \kappa':\square}{
		     |- \dbox{$p\kappa$} -> \kappa' : \square}
 ~~~
   \newFi{
   \inference[($Ri$)]{\cdot |- A:* & |- \kappa:\square}{
                      |- A -> \kappa : \square} }
$
~\\
\paragraph{Kinding:} \fbox{$\Delta |- F : \kappa$}
$ \qquad
   \inference[($Var$)]{\dbox{$X^{p\kappa}$}\in\Delta & |- \Delta}{
 		       \Delta |- X : \kappa}
		\, \dbox{$(p\in \{+,0\})$} $
\[
   \inference[($->$)]{\dbox{$-\Delta$} |- A : * & \Delta |- B : *}{
                      \Delta |- A -> B : * }
 \qquad \qquad \dbox{
   \inference[($\fix$)]{\Delta |- F : +\kappa -> \kappa}{
		      \Delta |- \fix F : \kappa } }
\]
\[
  \inference[($\lambda$)]{ |- \kappa:\square
                         & \Delta,\dbox{$X^{p\kappa}$} |- F:\kappa'}{
  	\Delta |- \lambda \dbox{$X^{p\kappa}$}.F : \dbox{$p\kappa$} -> \kappa'}
 ~~~~ \qquad
 \newFi{
  \inference[($\lambda i$)]{\cdot |- A:* & \Delta,i^A |- F : \kappa}{
			    \Delta |- \lambda i^A.F : A->\kappa} }
\]
\[
  \inference[($@$)]{ \Delta |- F : \dbox{$p\kappa$} -> \kappa'
		    & \dbox{$p\Delta$} |- G : \kappa }{
                     \Delta |- F\,G : \kappa'}
 ~~~~
 \newFi{
   \inference[($@i$)]{ \Delta |- F : A -> \kappa
   		     & \dbox{$0\Delta$\!};\cdot |- s : A }{
		      \Delta |- F\,\{s\} : \kappa} }
\]
\[
   \inference[($\forall$)]{ |- \kappa:\square
   			  & \Delta,\dbox{$X^{0\kappa}$} |- B : *}{
                           \Delta |- \forall X^\kappa . B : *}
 ~~~~ \qquad ~\,
	\newFi{
   \inference[($\forall i$)]{\cdot |- A:* & \Delta, i^A |- B : *}{
                             \Delta |- \forall i^A . B : *} }
\]
\[ \newFi{
   \inference[($Conv$)]{ \Delta |- A : \kappa
                       & \Delta |- \kappa = \kappa' : \square }{
                        \Delta |- A : \kappa'} }
\]
~\\
\paragraph{Typing:} \fbox{$\Delta;\Gamma |- t : A$}
$ \qquad
 ~~~~
 \inference[($:$)]{(x:A) \in \Gamma & \Delta |- \Gamma}{
                   \Delta;\Gamma |- x:A}
 ~~~~ \newFi{
   \inference[($:i$)]{i^A \in \Delta & \Delta |- \Gamma}{
                      \Delta;\Gamma |- i:A} }
$
\[
   \inference[($->$$I$)]{\Delta |- A:* & \Delta;\Gamma,x:A |- t : B}{
                         \Delta;\Gamma |- \lambda x.t : A -> B}
 ~~~~ ~~~~
   \inference[($->$$E$)]{\Delta;\Gamma |- r : A -> B & \Delta;\Gamma |- s : A}{
                         \Delta;\Gamma |- r\;s : B}
\]
\[ \inference[($\forall I$)]{|- \kappa:\square
			    & \Delta,\dbox{$X^{0\kappa}$\!};\Gamma |- t : B}{
                             \Delta;\Gamma |- t : \forall X^\kappa.B}
			    (X\notin\FV(\Gamma))
 ~~~~ ~~~~
   \inference[($\forall E$)]{ \Delta;\Gamma |- t : \forall X^\kappa.B
                            & \Delta |- G:\kappa }{
                             \Delta;\Gamma |- t : B[G/X]}
\]
\[ \newFi{
   \inference[($\forall I i$)]{\cdot |- A:* & \Delta, i^A;\Gamma |- t : B}{
                               \Delta;\Gamma |- t : \forall i^A.B}
   \left(\begin{matrix}
		i\notin\FV(t),\\
		i\notin\FV(\Gamma)\end{matrix}\right)
 ~~~~
   \inference[($\forall E i$)]{ \Delta;\Gamma |- t : \forall i^A.B
                              & \Delta;\cdot |- s:A}{
                               \Delta;\Gamma |- t : B[s/i]} }
\]
\[ \inference[($=$)]{\Delta;\Gamma |- t : A & \Delta |- A = B : *}{
                     \Delta;\Gamma |- t : B}
\]
\end{singlespace}
\caption{Sorting, Kinding, and Typing rules of \Fixi}
\label{fig:Fixi2}
\end{figure}

\begin{figure}\begin{singlespace}\small
\paragraph{Kind equality:} \fbox{$|- \kappa=\kappa' : \square$}
$ \quad
 ~~~~
   \inference{}{|- * = *:\square} $
\[
   \inference{ |- \kappa_1 = \kappa_1' : \square
             & |- \kappa_2 = \kappa_2' : \square }{
   |- \dbox{$p\kappa_1$}-> \kappa_2 = \dbox{$p\kappa_1'$}-> \kappa_2' : \square}
 ~~~~ \newFi{
   \inference{\cdot |- A=A':* & |- \kappa=\kappa':\square}{
              |- A -> \kappa = A' -> \kappa' : \square} }
\]
\[ \inference{|- \kappa=\kappa':\square}{
              |- \kappa'=\kappa:\square}
 ~~~~
   \inference{ |- \kappa =\kappa' :\square
             & |- \kappa'=\kappa'':\square}{
              |- \kappa=\kappa'':\square}
\]
~
\paragraph{Type constructor equality:} \fbox{$\Delta |- F = F' : \kappa$}
$\qquad \dbox{$
  \inference{\Delta|- F:+\kappa-> \kappa}{\Delta|- \fix F=F(\fix F):\kappa}$ } $
\[
   \inference{ \Delta,\dbox{$X^{p\kappa}$} |- F:\kappa'
   	     & \dbox{$p\Delta$} |- G:\kappa}{
	      \Delta |- (\lambda X^{p\kappa}.F)\,G = F[G/X]:\kappa'}
 ~~~~ \newFi{
   \inference{ \Delta,i^A |- F:\kappa
             & \dbox{$0\Delta$\!};\cdot |- s:A}{
              \Delta |- (\lambda i^A.F)\,\{s\} = F[s/i]:\kappa} }
\]
\[ \inference{\Delta |- X:\kappa }{\Delta |- X=X:\kappa}
 ~~~~
   \inference{-\Delta |- A=A':* & \Delta |- B=B':*}{\Delta |- A-> B=A'-> B':*}
 ~~~~
   \inference{\Delta |- F=F' : +\kappa -> \kappa}{
	      \Delta |- \fix F = \fix F' : \kappa}
\]
\[
   \inference{ |- \kappa:\square
   	     & \Delta,\dbox{$X^{p\kappa}$} |- F=F' : \kappa'}{
   	\Delta |- \lambda \dbox{$X^{p\kappa}$}.F
		= \lambda \dbox{$X^{p\kappa}$}.F': \dbox{$\kappa$} -> \kappa'}
 ~~~~ ~
 \newFi{
   \inference{\cdot |- A:* & \Delta,i^A |- F=F' : \kappa}{
	      \Delta |- \lambda i^A.F=\lambda i^A.F' : A -> \kappa} }
\]
\[\!\!\!\!\!\!\!\!\!\!\!\!
   \inference{ \Delta |- F=F' : \dbox{$p\kappa$} -> \kappa'
   	     & \dbox{$p\Delta$} |- G=G':\kappa}{
              \Delta |- F\,G = F'\,G' : \kappa'}
 ~~~~
 \newFi{
   \inference{ \Delta |- F=F': A -> \kappa
             & \dbox{$0\Delta$\!};\cdot |- s=s':A}{
	      \Delta |- F\,\{s\} = F'\,\{s'\} : \kappa} }
\]
\[
   \inference{ |- \kappa:\square
   	     & \Delta,\dbox{$X^{0\kappa}$} |- B=B':*}{
              \Delta |- \forall X^\kappa.B=\forall X^\kappa.B':*}
 ~~~~ \quad
 \newFi{
   \inference{\cdot |- A:* & \Delta,i^A |- B=B':*}{
              \Delta |- \forall i^A.B=\forall i^A.B':*} }
\]
\[ \inference{\Delta |- F = F' : \kappa}{\Delta |- F' = F : \kappa}
 ~~~~
   \inference{\Delta |- F = F' : \kappa & \Delta |- F' = F'' : \kappa}{
              \Delta |- F = F'' : \kappa}
\]
~
\paragraph{Term equality:} \fbox{$\Delta;\Gamma |- t = t' : A$}
\[
   \inference{\Delta;\Gamma,x:A |- t:B & \Delta;\Gamma |- s:A}{
              \Delta;\Gamma |- (\lambda x.t)\,s=t[s/x] : B}
 ~~~~
   \inference{\Delta;\Gamma |- x:A}{\Delta;\Gamma |- x=x:A}
\]
\[ \inference{\Delta |- A:* & \Delta;\Gamma,x:A |- t=t':B}{
              \Delta;\Gamma |- \lambda x.t = \lambda x.t':B}
 ~~~~
   \inference{\Delta;\Gamma |- r=r':A-> B & \Delta;\Gamma |- s=s':A}{
              \Delta;\Gamma |- r\;s=r'\;s':B}
\]
\[ \inference{ |- \kappa:\square
	     & \Delta, \dbox{$X^{0\kappa}$\!};\Gamma |- t=t' : B}{
              \Delta;\Gamma |- t=t' : \forall X^\kappa.B}
	     (X\notin\FV(\Gamma))
 ~~~~ ~~~~
   \inference{ \Delta;\Gamma |- t=t' : \forall X^\kappa.B
             & \Delta |- G:\kappa }{
              \Delta;\Gamma |- t=t' : B[G/X]}
\]
\[ \newFi{
   \inference{\cdot |- A:* & \Delta, i^A;\Gamma |- t=t' : B}{
              \Delta;\Gamma |- t=t' : \forall i^A.B}
   \left(\begin{smallmatrix}
		i\notin\FV(t),\\
		i\notin\FV(t'),\\
		i\notin\FV(\Gamma)\end{smallmatrix}\right)
 ~~~~
   \inference{ \Delta;\Gamma |- t=t' : \forall i^A.B
             & \Delta;\cdot |- s:A}{
              \Delta;\Gamma |- t=t' : B[s/i]} }
\]
\[ \inference{\Delta;\Gamma |- t=t':A}{\Delta;\Gamma |- t'=t:A}
 ~~~~
   \inference{\Delta;\Gamma |- t=t':A & \Delta;\Gamma |- t'=t'':A}{
              \Delta;\Gamma |- t=t'':A}
\]
\end{singlespace}
\caption{Equality rules of \Fixi}
\label{fig:eqFixi}
\end{figure}

The grey-boxed extensions for term-indexing are essentially the same as
those grey-boxed extensions in System \Fi\ (\S\ref{sec:fi:fi}). So, we will
only focus our description on the dashed-box extensions regarding polarities
(\S\ref{ssec:fixi:def:polarity}) and equi-recursive types
(\S\ref{ssec:fixi:def:equirec}).

\subsection{Polarities} \label{ssec:fixi:def:polarity}
Polarities track in which position the type constructor variables are used.
A polarity ($p$) is either covariant ($+$), contravariant ($-$), or
avariant ($0$). The avariant polarity ($0$) means that it can be used in
any position.\footnote{``invariant'' is more often used
	(also in \cite{AbeMat04}, but we think it is a quite misleading jargon,
	since $0$ means that it \emph{does not care} about polarities
	rather than maintaining some unchanging properties about polarities.}
We prefix a kind  by a polarity (\ie, $p\kappa$) to specify the variable's
kind and polarity. For example,
\[
\begin{array}{rlrl}
X_1^{+*},X_2^{-*} |- \!\!\! & X_1 -> X_2 : *
	& ~~~\text{justifies} & \l X_1^{+*}.\l X_2^{-*}.X_1 -> X_2 \\
X_1^{0*},X_2^{0*} |- \!\!\! & X_1 -> X_2 : *
	& ~~~\text{also justifies} & \l X_1^{0*}.\l X_2^{-*}.X_1 -> X_2 \\
X^{0*} |- \!\!\! & X\phantom{_.} -> X\phantom{_2} : *
	& ~~~\text{justifies} & \l X^{0*}.X -> X
\end{array}
\]
Note that we can replace $+$ and $-$ in the first example with $0$
as in the second example, since the variables of avariant polarity can be used
in any position, that is both in covariant position and contravariant position.
In the third example, the polarity of $X$ can be neither $+$ nor $-$, but must
must be $0$, since $X$ appears in both covariant and contravariant positions.

\paragraph{Syntax using polarized kinds:}
The kind syntax are polarized. That is, the domain kind ($\kappa$) of
an arrow kind ($p\kappa -> \kappa'$) must be prefixed by its polarity ($p$).
A type abstractions ($\l X^{p\kappa}.F$) in the type syntax are annotated by
polarity-prefixed kinds ($p\kappa$). Type constructor variables ($X$) bound
in the type-level contexts ($\Delta$) are annotated by polarity-prefixed kinds
($p\kappa$), likewise. Note the syntax for extending the type-level context
$\Delta,X^{p\kappa}$ in Figure~\ref{fig:Fixi}. The kinding rule ($\lambda$)
make use of all these three uses of polarized kinds -- in type abstractions,
in kind arrows, and in type-level contexts.

\paragraph{Polarity operation on type-level context ($p\Delta$):}
The kinding judgment $\Delta |- F : \kappa$ assumes that $F$ is in covariant
positions. This is why the ($Var$) rule requires the polarity of $X$ to be
either $+$ or $0$, but not $-$. To judge well-kindedness of type constructors
in contravariant positions (\eg, $A$ in $A -> B$), we should invert
the polarities of all the type constructor variables in the context.
This idea of inverting polarities in the context is captured by $-\Delta$
operation in the kinding rule ($->$). More generally, the well-kindedness $F$
expected to be used as $p$-polarity can be determined by the judgement
$p\Delta |- F : \kappa$, where $p\Delta$ operation is defined as:
\[
\begin{array}{lcl}
p~\cdot &=& \cdot \\
p(\Delta,X^{p'\kappa}) &=& p\Delta,X^{(pp')\kappa} \\
p(\Delta,i^A) &=& p\Delta,i^A
\end{array}
\quad\text{where $pp'$ is the usual sign product}~~
\begin{smallmatrix}
+ p' & = & p' \\
- +  & = & -  \\
- -  & = & +  \\
- 0  & = & 0  \\
0 p' & = & 0
\end{smallmatrix}
\]
Note the use of $p\Delta$ operation in the kinding rule ($@$) in order to
determine the well-kindedness of $G$ expected to be used as $p$-polarity
by the type constructor $F : p\kappa -> \kappa'$ being applied to $G$.

\paragraph{Where polarities are irrelevant (or, avariant):}
Polarities are irrelevant (or, avariant) for universally quantified variables,
indices, and in the typing rules. This is because the sole purpose of tracking 
polarities in \Fixi\ is to make sure that we only take the equi-recursive
fixpoint over covariant type constructors, as in the kinding rule ($\mu$).
Note that we can only take fixpoints over type constructors of covariant
arrow kinds whose domain and codomain coincides ($+\kappa -> \kappa$).
We can never take fixpoints over forall types (or, universal quantification)
and type constructor expecting an index because they are not of arrow kinds.
Forall types are always of kind $*$ and type constructors expecting an index
are of arrow kinds ($A -> \kappa$). So, we give universally quantified variables
avariant polarity ($X^{0\kappa}$ in the ($\forall$) rule) and nullify polarities
when type checking indices ($0\Delta$ in the ($@i$) rule). For similar reasons,
we assume that type-level contexts are nullified in the typing rules;
note $0\Delta$ in the well-formedness condition for $\Delta |- \Gamma$
in Figure~\ref{fig:Fixi2}. That is, we always type check under nullified
type-level context for all terms in general, as well as indices appearing
in type applications. As a result, the typing rules of \Fixi\ have no dashed-box
extensions except for $X^{0\kappa}$ in the generalization rule ($\forall$$I$)
where we introduce a universally quantified type constructor variable.

\subsection{The Equi-recursive type operator $\fix$}
\label{ssec:fixi:def:equirec}
\Fixi\ provides the equi-recursive type operator $\fix$.
The kinding rule ($\fix$) in Figure~\ref{fig:Fixi2} is similar to
the ($\mu$) rule of System \Fi\ (see Figure~\ref{fig:Fi2} in \S\ref{sec:fi:fi}),
but requires base structure $F$ to be covariant (or, positive), \ie,
$F : +\kappa -> \kappa$. This restriction on the polarity of $F$ is due to
the equi-recursive nature of $\fix$, \ie, $\fix F=F(\fix F)$, which is
described by the first type constructor equality rule inside a dashed box
in Figure~\ref{fig:eqFixi}. Recall that adding equi-recursive types
without restricting the polarity of base structure breaks strong normalization.
\KYA{TODO should reference intro chapter section which is not written yet}

Note that there are no explicit term syntax that guides the conversion between
$\fix F$ and $F(\fix F)$, unlike in iso-recursive systems where $\In$ and
$\mathsf{unIn}$ are term syntax that explicitly guide rolling
(from $\mu F$ to $F(\mu F)$) and unrolling (from $F(\mu F)$ to $\mu F$).
Since $\fix F=F(\fix F)$ is given definitionally (\ie, by the equality rule
definition), the type constructor conversion rule ($Conv$) can silently
roll (from $F(\fix F)$ to $\fix F$) and unroll (from $F(\fix F)$ to $\fix F$)
the recursive types, just as it can silently $\beta$-convert type constructors.

In the following section, we will review how iso-recursive type operator
$\mu_\kappa$ and its $\In_\kappa$ constructor, which is well-behaved
(\ie, strongly normalize) for base structures of arbitrary polarity,
can be embedded into \Fixi\ being defined in terms of the equi-recursive
type operator $\fix$, which is only well-behaved for covariant base structures.

\section{Embedding datatypes and primitive recursion}
\label{sec:fixi:data}
Embedding for primitive recursion over datatypes of arbitrary polarities into
\Fixi\ was discovered by \citet{AbeMat04}. We review these embeddings
in the context of \Fixi.

The embeddings of non-recursive datatypes in Figure~\ref{fig:fixiNonRecData}
are exactly the same as in \Fi\ (see \S\ref{sec:fi:data}), other than tracking
polarities of the type constructor variables. That is, we use the usual
impredicative encodings for non-recursive datatypes such as void, unit, pairs,
sums, and existential types. The examples in Figure \ref{fig:fixiNonRecData}
are mostly from \citet{AbeMat04}, except for the last example of $\exists_A$,
an existential type over term-indices of type $A$.
\begin{figure}
\begin{singlespace}
\begin{align*}
\bot &~\triangleq~ \forall X^{*}.X
	&:\;& *\\
\textsf{Unit} &~\triangleq~ \forall X.\lambda X^{0*}. X
	&:\;& * \\
\times &~\triangleq~
	\l X_1^{+*}.\l X_2^{+*}.\forall X^{*}.(X_1 -> X_2 -> X) -> X
	&:\;& +* -> +* -> * \\
+ &~\triangleq~
	\lambda X_1^{+*}.\l X_2^{+*}.\forall X^{*}.(X_1 -> X) -> (X_2 -> X) -> X
	&:\;& +* -> +* -> * \\
\exists_\kappa &~\triangleq~
	\l X_{\!F}^{0\kappa -> *}.\forall X^{*}.
		(\forall X_1^\kappa.X_{\!F}\,X_1 -> X) -> X
	&:\;& +(0\kappa -> *) -> * \\
\exists_A &~\triangleq~
	\l X_{\!F}^{A -> *}.\forall X^{*}.
	(\forall i^A.X_{\!F}\{i\} -> X) -> X
	&:\;& +(A -> *) -> *
\end{align*}
\caption{Embeddings of some well-known non-recursive datatypes in \Fixi}
\label{fig:fixiNonRecData}
\end{singlespace}
\end{figure}

Embedding recursive datatypes and their Mendler-style primitive recursion
amounts to embedding $\mu_\kappa$, $\In_\kappa$, and $\MPr_\kappa$ described
in \S\ref{sec:mpr}. Figure~\ref{fig:embedMPr} illustrates the embeddings
discovered by \citet{AbeMat04}, reformatted using our conventions (see
Figure~\ref{fig:mu} in \S\ref{ssec:embedTwoLevel}) and taking term-indices
into consideration. To confirm the correctness of these embeddings,
we should check that (1) the embeddings are well-kinded and well-typed
and that (2) the primitive recursion behaves well
(\ie, $\MPr_\kappa\;s\;(\In_\kappa) -->+ s\;\textit{id}\;(\MPr_\kappa\;s)\;t$).
From the term encodings of $\MPr_\kappa$ and $\In_\kappa$, it is obvious that
the reduction of primitive recursion behaves well. Thus, we only need to check
that $\mu_\kappa$ is well-kinded and $\MPr_\kappa$ and $\In_\kappa$ are
well-typed.
\afterpage{ %%%%%%%%%%%%%%%%%%%%%%% begin afterpage
\begin{landscape}
\begin{figure}
\begin{singlespace}
\begin{multline*} \text{notation:}\quad
   \boldsymbol{\l}\mathbb{I}^\kappa.F =
	\lambda I_1^{K_1}.\cdots.\lambda I_n^{K_n}.F \qquad
   \boldsymbol{\forall}\mathbb{I}^\kappa.B =
	\forall I_1^{K_1}.\cdots.\forall I_n^{K_n}.B \qquad
   F\mathbb{I} = F I_1 \cdots I_n \qquad
   F \stackrel{\kappa}{\pmb{\pmb{->}}} G =
	\boldsymbol{\forall}\mathbb{I}^\kappa.F\mathbb{I} -> G\mathbb{I} \\
\begin{array}{lll}
\text{where}
 	& \kappa = K_1 -> \cdots -> K_n -> * & \text{and} ~~~
 	\text{$I_i$ is an index variable ($i_i$) when $K_i$ is a type,}
 		\\
 	& \mathbb{I}\,=I_1,\;\dots\;\dots\;,\;I_n& \qquad~\qquad
		\text{a type constructor variable ($X_i$) otherwise
			(\ie, $K_n=p_i\kappa_i$).}
\end{array}
\end{multline*} ~ \vspace*{-5pt}
\hrule  \vspace*{-2pt}
\begin{align*}
\mu_\kappa &\;:~ 0(0\kappa -> \kappa) -> \kappa \\
\mu_\kappa &\triangleq
\l X_{\!F}^{0(0\kappa -> \kappa)}.\fix(\Phi_\kappa\,X_{\!F})\\
\Phi_\kappa &\;:~ 0(0\kappa -> \kappa) -> +\kappa -> \kappa \\
\Phi_\kappa &\triangleq \l X_{\!F}^{0(0\kappa -> \kappa)}.
\l X_c^{+\kappa}.\boldsymbol{\l}\mathbb{I}^\kappa.
\forall X^\kappa.
(\forall X_r^\kappa. (X_r \karrow{\kappa} X_c)
		-> (X_r \karrow{\kappa} X)
		-> (X_{\!F}\,X_r \karrow{\kappa} X) ) -> X\,\mathbb{I}\\
~\\
\MPr_\kappa &\;:~
	\forall X_{\!F}^{0(0\kappa-> \kappa)}.\forall X^\kappa.
	(\forall {X_r}^{\!\!\kappa}.
	 (X_r \karrow{\kappa} \mu_\kappa X_{\!F}) ->
	 (X_r \karrow{\kappa} X) ->
	 (X_{\!F}\,X_r \karrow{\kappa} X) ) ->
	 (\mu_\kappa X_{\!F} \karrow{\kappa} X) \\
\MPr_\kappa &\triangleq \l s.\l r.r\;s \\
~\\
\In_\kappa &\;:~ \forall X_{\!F}^{0(0\kappa-> \kappa)}.
		X_{\!F}(\mu_\kappa X_{\!F}) \karrow{\kappa} \mu_\kappa X_{\!F}\\
\In_\kappa &\triangleq \l t.\l s.s\;\textit{id}\;(\MPr_\kappa\;s)\;t \\
\textit{id} &\triangleq \l x.x
\end{align*}
\end{singlespace}
\caption{Embedding of the recursive type operators ($\mu_\kappa$),
	their data constructors ($\In_\kappa$),
	and the Mendler-style primitive recursors ($\MPr_\kappa$) in \Fixi.}
\label{fig:embedMPr}
\end{figure}

\begin{figure}
\begin{singlespace}
\[
\text{The type of $r$ can be expanded by the defintion of $\fix$
	and the equi-recursive equality rule on $\fix$ as follows:}\]
	\vskip-6ex
\begin{multline*}\,
\mu_\kappa X_{\!F}\,\mathbb{I} = \fix(\Phi_\kappa X_{\!F})\mathbb{I}
= \Phi_\kappa X_{\!F}(\fix(\Phi_\kappa X_{\!F}))\mathbb{I}
= \Phi_\kappa X_{\!F}(\mu_\kappa X_{\!F}) \mathbb{I} \\
= \forall X^\kappa.\underbrace{
	(\forall X_r^\kappa.
		(X_r \karrow{\kappa} \mu_\kappa X_{\!F}) ->
		(X_r \karrow{\kappa} X) ->
		(X_{\!F}\,X_r \karrow{\kappa} X) )}_\text{exactly matches with
						the type of {\,\small$s$}}
	-> X\,\mathbb{I} \,
\end{multline*}
\[
\inference{
	\inference{
	X_{\!F}^{0(0\kappa-> \kappa)}, X^{0\kappa},
	\mathbb{I}^\kappa
	; \;
	s: (\forall {X_r}^{\!\!\kappa}.
	 (X_r \karrow{\kappa} \mu_\kappa X_{\!F}) ->
	 (X_r \karrow{\kappa} X) ->
	 (X_{\!F}\,X_r \karrow{\kappa} X) ),
	r: \mu_\kappa X_{\!F}\,\mathbb{I}
	|- r\;s : X\,\mathbb{I}
	}{
	X_{\!F}^{0(0\kappa-> \kappa)}, X^{0\kappa} ; \;
	s: (\forall {X_r}^{\!\!\kappa}.
	 (X_r \karrow{\kappa} \mu_\kappa X_{\!F}) ->
	 (X_r \karrow{\kappa} X) ->
	 (X_{\!F}\,X_r \karrow{\kappa} X) )
	|- \l s.r\;s : \mu_\kappa X_{\!F} \karrow{\kappa} X
	}
}{
	\cdot;\cdot |- \l s.\l r.r\;s :
	\forall X_{\!F}^{0\kappa-> \kappa}.\forall X^\kappa.
	(\forall {X_r}^{\!\!\kappa}.
	 (X_r \karrow{\kappa} \mu_\kappa X_{\!F}) ->
	 (X_r \karrow{\kappa} X) ->
	 (X_{\!F}\,X_r \karrow{\kappa} X) ) ->
	 (\mu_\kappa X_{\!F} \karrow{\kappa} X) 
}
\]
\end{singlespace} \vskip-1.5ex
\caption{Well-typedness of the $\MPr$ embedding in \Fixi}
\label{fig:embedMPrJustify}
\end{figure}

\begin{figure}
\begin{singlespace}~\qquad
Let ~ $\Delta =
	X_{\!F}^{0(0\kappa-> \kappa)}, \mathbb{I}^\kappa,
	X^{0\kappa}$ ~ and ~
$\Gamma =
	t: X_{\!F}(\mu_\kappa X_{\!F})\mathbb{I},
	s: (\forall X_r^\kappa.
		(X_r \karrow{\kappa} \mu_\kappa X_{\!F}) ->
		(X_r \karrow{\kappa} X) ->
		(X_{\!F}\,X_r \karrow{\kappa} X) )$.
\[
\inference{
	\inference{
		\inference{
			\inference{
				{\begin{array}{llll}
			\Delta;\Gamma |- s \;:
			(\mu_\kappa X_{\!F} \karrow{\kappa} \mu_\kappa X_{\!F})
			~ -> &
			(\mu_\kappa X_{\!F} \karrow{\kappa} X)
			~ -> &
			(X_{\!F}(\mu_\kappa X_{\!F}) \karrow{\kappa} X)
			& \qquad \text{\small(by instantiating $X_r$
						with $\mu_\kappa X_{\!F})$}
				\\
			\Delta;\Gamma |- \textit{id} :
			(\mu_\kappa X_{\!F} \karrow{\kappa} \mu_\kappa X_{\!F})
				\\
			\Delta;\Gamma |- (\MPr_\kappa\; s) ~~ : &
			(\mu_\kappa X_{\!F} \karrow{\kappa} X)
				\\
			\Delta;\Gamma |- t \qquad\qquad\, : & &
			X_{\!F}(\mu_\kappa X_{\!F})\mathbb{I}
				\end{array}}
			}{
	X_{\!F}^{0(0\kappa-> \kappa)}, \mathbb{I}^\kappa,
	X^{0\kappa}
	; \;
	t: X_{\!F}(\mu_\kappa X_{\!F})\mathbb{I},
	s: (\forall X_r^\kappa.
		(X_r \karrow{\kappa} \mu_\kappa X_{\!F}) ->
		(X_r \karrow{\kappa} X) ->
		(X_{\!F}\,X_r \karrow{\kappa} X) )
	|- s\;\textit{id}\;(\MPr_\kappa\;s)\;t : X\,\mathbb{I}
			}
		}{
	X_{\!F}^{0(0\kappa-> \kappa)}, \mathbb{I}^\kappa ; \;
	t: X_{\!F}(\mu_\kappa X_{\!F})\mathbb{I}
	|- \l s.s\;\textit{id}\;(\MPr_\kappa\;s)\;t :
	\forall X^\kappa.
	(\forall X_r^\kappa.
		(X_r \karrow{\kappa} \mu_\kappa X_{\!F}) ->
		(X_r \karrow{\kappa} X) ->
		(X_{\!F}\,X_r \karrow{\kappa} X) ) -> X\,\mathbb{I}
		}
	}{
	X_{\!F}^{0(0\kappa-> \kappa)}, \mathbb{I}^\kappa ; \;
	t: X_{\!F}(\mu_\kappa X_{\!F})\mathbb{I}
	|- \l s.s\;\textit{id}\;(\MPr_\kappa\;s)\;t :
		\mu_\kappa X_{\!F}\,\mathbb{I} \quad
		\qquad \text{\small(We can expand the type into above
				as in Figure \ref{fig:embedMPrJustify})}
	}
}{
	\cdot;\cdot |- \l t.\l s.s\;\textit{id}\;(\MPr_\kappa\;s)\;t :
	\forall X_{\!F}^{\kappa-> \kappa}.
		X_{\!F}(\mu_\kappa X_{\!F}) \karrow{\kappa} \mu_\kappa X_{\!F}
}
\]
\end{singlespace} \vskip-2.5ex
\caption{Well-typedness of the $\In$ embedding in \Fixi}
\label{fig:embedInJustify}
\end{figure}

\end{landscape}
} %%%%%%%%%%%%%%%%%%%%%%% end of afterpage

Note that the polarities appearing in the embedding of $\mu_\kappa$ are all
$0$. The embedding from a non-polarize kind $\kappa$ into
a polarize kinds $\ulcorner\kappa\urcorner$ can be defined as:
\[ \ulcorner * \urcorner = * \qquad
\ulcorner \kappa_1 -> \kappa_2 \urcorner =
0\ulcorner\kappa_1\urcorner -> \ulcorner\kappa_2\urcorner \qquad
\ulcorner A -> \kappa \urcorner = A -> \ulcorner \kappa \urcorner.
\]

It is easy to see that the embedding of the non-polarized recursive
type operator $\mu_\kappa : 0(0\kappa -> \kappa) -> \kappa$
is well-kinded, provided that
$\Phi_\kappa : 0(0\kappa -> \kappa) -> +\kappa -> \kappa$
is well kinded. Note that $\Phi_\kappa$ turns an avariant type constructor
($0\kappa -> \kappa$) into a positive type constructor
($+\kappa -> \kappa$). From the definition of $\Phi_\kappa$, we only need 
to check that $(X_r \karrow{\kappa} X_c)$, $(X_r \karrow{\kappa} X)$,
$X_F\,X_r \karrow{\kappa} X$ and $X\;\mathbb{I}$ are of kind $*$
under the context $ X_{\!F}^{0(0\kappa -> \kappa)},
		X_c^{+\kappa}, \mathbb{I}^\kappa, X^{0\kappa}$,
which is not difficult to see.

Well-typedness of $\MPr_\kappa$ and $\In_\kappa$ are justified in
Figures~\ref{fig:embedMPrJustify} and \ref{fig:embedInJustify}

\section{Embedding course-of-values primitive recursion}
\label{sec:fixi:cv}
Figure~\ref{fig:embedMcvPr} and Figure~\ref{fig:unInExamples}
illustrates embeddings of the iso-recursive operator ($\mu^{+}_\kappa$) and
the course-of-values primitive recursor ($\McvPr_\kappa$), and
the roll and unroll operations ($\In_F$ and $\unIn_F$) over
a fairly large class of positive base structures ($F$) in \Fixi.
The embeddings of $\mu^{+}_\kappa$, $\McvPr_\kappa$, and $\In_F$
are very similar to the embeddings of $\mu_\kappa$, $\MPr_\kappa$,
and $\In_\kappa$ for the primitive recursion in the previous section,
but there should be an additional embedding for the unroll operation $\unIn_F$
for course-of-values primitive recursion.

\afterpage{ %%%%%%%%%%%%%%%%%%%%%%% begin afterpage
\begin{landscape}
\begin{figure}
\begin{singlespace}
\begin{align*}
\mu^{+}_\kappa &\;:~ 0(+\kappa -> \kappa) -> \kappa \\
\mu^{+}_\kappa &\triangleq
\l X_{\!F}^{0(+\kappa -> \kappa)}.\fix(\Phi^{+}_\kappa\,X_{\!F})\\
\Phi^{+}_\kappa &\;:~ 0(+\kappa -> \kappa) -> +\kappa -> \kappa \\
\Phi^{+}_\kappa &\triangleq \l X_{\!F}^{0(+\kappa -> \kappa)}.
\l X_c^{+\kappa}.\boldsymbol{\l}\mathbb{I}^\kappa.
\forall X^\kappa.
(\forall X_r^\kappa. (X_r \karrow{\kappa} X_{\!F}\,X_r)
		-> (X_r \karrow{\kappa} X_c)
		-> (X_r \karrow{\kappa} X)
		-> (X_{\!F}\,X_r \karrow{\kappa} X) ) -> X\,\mathbb{I}\\
~\\
\McvPr_\kappa &\;:~
	\forall X_{\!F}^{+\kappa-> \kappa}.\forall X^\kappa.
	(\forall {X_r}^{\!\!\kappa}.
	 (X_r \karrow{\kappa} X_{\!F}\,X_r) ->
	 (X_r \karrow{\kappa} \mu^{+}_\kappa X_{\!F}) ->
	 (X_r \karrow{\kappa} X) ->
	 (X_{\!F}\,X_r \karrow{\kappa} X) ) ->
	 (\mu^{+}_\kappa X_{\!F} \karrow{\kappa} X) \\
\McvPr_\kappa &\triangleq \l s.\l r.r\;s\\
~\\
\In_F &\;:~ F(\mu^{+}_\kappa F) \karrow{\kappa} \mu^{+}_\kappa F\\
\In_F &\triangleq
	\l t. \l s. s~\unIn_F\;\textit{id}\;\,(\McvPr\;s)\;\,t \\
\end{align*}\vskip -2.5ex
Provided that there exists
$\unIn_{F} : \mu^{+}_\kappa F \karrow{\kappa} F(\mu^{+}_\kappa F)$
for the base structure $F:+\kappa -> \kappa$, 
such that
\[
	(\In_F \circ \unIn_F)\;r -->+ r \qquad \qquad
	(\unIn_F \circ \In_F)\;t -->+ t
\]
where the reduction steps above are constant with regards to $r$ and $t$
(vary between each base structure $F$ though).
\end{singlespace} \vskip-3.5ex
\[\text{See Figure \ref{fig:unInExamples} for
embeddings of unroll operations ($\unIn_F$) for
some well-known positive base structures ($F$).}
\]
\caption{Embedding of the recursive type operators ($\mu^{+}_\kappa$),
	the Mendler-style course-of-values primitive recursors
	($\McvPr_\kappa$), and the roll operation ($\In_F$) in \Fixi.}
\label{fig:embedMcvPr}
\end{figure}

\begin{figure}
\[\!\!\!\!\!\!\!
\begin{array}{llcll}
	& \text{\textbf{Regular datatypes}} \\
N &\!\!\!\triangleq \l X^{+*}.X + \textsf{Unit} &\qquad&
\unIn_N &\!\!\!\triangleq \McvPr_{*} (\l\_.\l\textit{cast}.\l\_.
	\l x. x\;(\texttt{InL}\circ\textit{cast})\;\texttt{InR})
	\\
L &\!\!\!\triangleq \l X_a^{+*}.\l X^{+*}.(X_a\times X) + \textsf{Unit} &&
\unIn_{(LA)} &\!\!\!\triangleq \McvPr_{*} (\l\_.\l\textit{cast}.\l\_.
	\l x. x\;(\texttt{InL}\circ(\textit{id}\times cast))\;\texttt{InR})
	\\
R &\!\!\!\triangleq \l X_a^{+*}.\l X^{+*}.(X_a\times \texttt{List} X) -> X &&
\unIn_{(RA)} &\!\!\!\triangleq \McvPr_{*} (\l\_.\l\textit{cast}.\l\_.
	\l x. x\;(\textit{id}\times \textit{map}_\texttt{List}\;cast) )
	\quad\text{ \textcolor{red}{\sc Not constant} } 
	\\
& \text{\textbf{Type-indexed datatypes}} \phantom{G^{G^{G^{G^{G^G}}}}}\\
P &\!\!\!\triangleq \l X^{+* -> *}.\l X_a^{+*}.
	X_a \times X(X_a \times X_a) + \textsf{Unit} &&
\unIn_P &\!\!\!\triangleq \McvPr_{+* -> *} (\l\_.\l\textit{cast}.\l\_.
	\l x. x \;(\texttt{InL}\circ(\textit{id}\times\textit{cast}))
		\;\texttt{InR})
	\\
B &\!\!\!\triangleq \l X^{+* -> *}.\l X_a^{+*}.
	X_a \times X(X\,X_a) + \textsf{Unit} &&
\unIn_B &\!\!\!\triangleq \text{ \textcolor{red}{\sc unknown.}
	{\small(Not likely to be constant time even if this exists.)}}
	\\
	& \text{\textbf{Term-indexed datatypes}} \phantom{G^{G^{G^{G^{G^G}}}}}\\
\end{array}
\]\vskip-4.5ex
\[
V \triangleq \l X_a^{*}.\l X^{\texttt{Nat} -> *}.\l i^{\texttt{Nat}}.
(\exists j^\texttt{Nat}.((i=\texttt{succ}\,j) \times X_a \times X\{j\})) +
(i=\texttt{zero})
\]
\[
\begin{array}{lll}
\texttt{VCons} &\!\!\!\triangleq \l x_a.\l x.
	\texttt{InL}(\mathtt{Ex_{Nat}}(\mathtt{Eq_{\,Nat}},x_a,x))
& : \;
\forall X_a^{*}. \forall X^{\texttt{Nat} -> *}. \forall i^\texttt{Nat}.
	X_a -> X\,\{i\} -> V\,X_a\,X\,\{\texttt{succ}\,i\}
	\\
\texttt{VNil} &\!\!\!\triangleq \texttt{InR}~\mathtt{Eq_{\,Nat}}
& : \;
\forall X_a^{*}. \forall X^{\texttt{Nat} -> *}. V\,X_a\,X\,\{\texttt{zero}\}
\end{array}
\]
\[
\unIn_{(V\,A)} \triangleq \McvPr_{\texttt{Nat} -> *}(\l\_.\l\textit{cast}.\l\_.
\l x. x \;(\texttt{InL}\circ
		(\textit{id}\times\textit{id}\times\textit{cast}))
	\;\texttt{InR})
\]
The notation $\exists j^A.B$ is a shorthand for $\exists_A(\l j^A.B)$
where $\exists_A$ is defined in Figure~\ref{fig:fixiNonRecData}.
$\mathtt{Ex_{A}} : \forall F^{A -> *}.\exists_A F$ and
$\mathtt{Eq_{A}} : \forall i^A.\forall j^A.(i=j)$ are
the data constructors of the existential type and the equality type.
\[\text{
See Figure \ref{fig:embedMcvPr} for the embedding of the Mendler-style
course-of-values primitive recursor ($\McvPr_\kappa$)}
\]
\caption{Embeddings of unroll operator ($\unIn_F$)
	for some well-known positive base structures ($F$).}
\label{fig:unInExamples}
\end{figure}

\end{landscape}
} %%%%%%%%%%%%%%%%%%%%%%% end of afterpage
%% [basicstyle={\ttfamily\small},language=Haskell,mathescape]

The embedding of unroll operations for some well-known positive datatypes
are illustrated in Figure~\ref{fig:unInExamples}. The idea is to use
$\McvPr_\kappa$ to define $\unIn_F$ for the base structure
$F:+\kappa -> \kappa$ without using the abstract recursive call operation
in order to be constant time. To define the unroll operation, we map
non-recursive components ($X_a$) as they are using \textit{id} and map
abstract recursive components ($X_r$) to concrete recursive components
($\mu^{+}_\kappa F$) using the abstract \textit{cast} operation provided
by the $\McvPr_\kappa$ combinator. We can embed unroll operations
for regular datatypes such as natural numbers (the base $N$) and lists
(the base $L$), type-indexed datatypes such as powerlists (the base $P$),
and term-indexed datatypes such as vectors (the base $V$) in this way.
The embeddings of $\unIn_N$ and $\unIn_L$ are self explanatory.
For intuitive understanding of the embedding of $\unIn_P$, we provide
a transcription of the $\unIn_P$ into Haskell in Figure~\ref{fig:HaskellunInP}.
To embed unrolling operation for indexed datatypes we would often need
existential types (Figure~\ref{fig:fixiNonRecData}) and equality types.
We can encode equality types in \Fixi\ as a Leibniz equality over indices, \ie,
$(i=j) \triangleq \forall F^{A -> *}.F\{i\} -> F\{j\} \times F\{i\} -> F\{j\}$,
as discussed in \S\ref{Leibniz}.

However, not all datatypes seem to have embeddings of constant time 
unroll operations in this way, as in Figure~\ref{fig:embedMcvPr} and
Figure~\ref{fig:unInExamples}. For instance, the embeddings of
unroll operations for indirectly recursive datatypes such as
the rose tree datatype (the base $R$) are not constant due to the
use of $\textit{map}_\textit{List}$, which is obviously not constant
function as it is; We may be able to prove a meta-property that 
($\textit{map}_\texttt{List}\;\textit{cast}) : \texttt{List}(X_r\,X_a)
-> \texttt{List}(\mu^{+}_\kappa R\,X_a)$ can be safely optimized
to constant time identity function since the value of \textit{cast}
is given as \textit{id} by definition of $\McvPr_\kappa$, but that does
not mean that we have a constant time embedding of $\unIn_R$ within \Fixi.
Embeddings of unroll operations for \emph{truly nested datatypes}
such as bushes (the base $B$) are not known, since we have to cast
truly nested occurrences of $X_r$s in $(X_r(X_r\,X_a))$ into
a concrete recursive type constructor $\mu^{+}_\kappa R$ in order
to cast it into $\mu^{+}_\kappa B((\mu^{+}_\kappa B)X_a)$, which
is not obvious how to embed. Even if there was a way to embed such
a truly nested casting, it is not likely to be constant time either.

Apart from the limitations of constant-time undefinability of $\unIn_F$
discussed above, the embeddings illustrated in Figure~\ref{fig:unInExamples}
are not in spirit of Mendler-style. Note that the embeddings of $\unIn_F$ are
polytypic (different term encodings for each different $F$) rather than
polymorphic (one uniform term encoding whose type is polymorphic over $F$).
Recall that the key advantage of Mendler-style comes from being polymorhpic.

Fortunately, there does exists more proper Mendler-style embeddings
of the course-of-values combinators over arbitrary positive datatypes
using both iteration and coiteration schemes \cite{TODO}. Since coiteration
is embeddable in \Fi\ and co(-primitive-)recursion is embeddable in \Fixi,
these result directly applies without extending our calculi. However,
to our knowledge, course-of-values combinators over higher-kinded
type constructors (\ie, type constructors other than kind $*$) has not been
well studied enough, even in that setting of using both iteration/recursion
and coiteration/corecursion. That is, course-of-values combinators for
regular indirect recursive datatypes are very likely to be embeddable in
a calculus like \Fi\ or \Fixi\ directly applying the known results, but
we may need further investigation to assure ourselves for the behavior of
course-of-values combinators over higher-kinded datatypes.

We leave the search for embeddings for arbitrary positive datatypes,
including indirectly recursive datatypes and truly nested datatypes,
as future work, since coiteration and corecursion are out of the scope of
this dissertation.

\begin{figure}
\begin{singlespace}
\lstset{language=Haskell,
	basicstyle=\ttfamily\small,
%	keywordstyle=\color{ta4chameleon},
%	emph={List,Int,Bool},
%	commentstyle=\color{gray},
	literate =
		{forall}{{$\forall$}}1
%		{|}{{$\mid\;\,$}}1
%		{=}{{\textcolor{ta3chocolate}{$=\,\;$}}}1
		{::}{{$:\!\,:$}}1
		{->}{{$\to$}}1
	}
\begin{lstlisting}
data P r i = PC i (r (i,i)) | PN
type Powl i = Mu1 P i
pcons x = In1 . PC x
pnil = In1 PN

newtype Mu1 f i = In1 { unIn1 :: f(Mu1 f)i }

mcvpr1 :: (forall r i. (forall i. r i -> f r i) ->
                 (forall i. r i -> Mu1 f i) ->
                 (forall i. r i -> a i) ->
                 (f r i -> a i) )
       -> Mu1 f i -> a i
mcvpr1 phi = phi unIn1 id (mcvpr1 phi) . unIn1

unInP :: Mu1 P i -> P(Mu1 P) i
unInP = mcvpr1 phi where
  phi :: forall r i'. (forall i. r i -> P r i) ->
                (forall i. r i -> Mu1 P i) ->
                (forall i. r i -> P(Mu1 P) i) ->
                (P r i' -> P(Mu1 P) i')
  phi out cast call (PC x xs) = PC x (cast xs)
  phi out cast call PN = PN
\end{lstlisting}
\end{singlespace}
\caption{Embedding of $\unIn_P$ in Figure~\ref{fig:unInExamples}
	transcribed into Haskell}
\label{fig:HaskellunInP}
\end{figure}

\section{Metatheory} \label{sec:fixi:theory}

We can prove strong normalization of \Fixi\ by erasing term-indices in \Fixi\ 
types into \Fixw\ types. Since \Fixw\ is strongly normalizing \cite{AbeMat04},
the existence of a index erasure that maps a valid typing judgment on a term
in \Fixi\ to a valid typing judgment on the same term in \Fixw\ implies
strong normalization of \Fixi.

The definition of the index erasure operation and the proofs for
the related theorems are almost exactly the same as their counterparts
in System \Fi\ (see \S\ref{sec:fi:theory}). So, we simply illustrate
the definition and just give a very brief sketch of the proofs for the
theorems.

We define a meta-operation of index erasure that projects $\Fixi$ types
to $\Fixw$ types.
\begin{definition}[index erasure]\label{def:Fixierase}
\[ \fbox{$\kappa^\circ$}
 ~~~~ ~~
 *^\circ =
 *
 ~~~~ ~~
 (p\kappa_1 -> \kappa_2)^\circ =
 p{\kappa_1}^\circ -> {\kappa_2}^\circ
 ~~~~ ~~
 (A -> \kappa)^\circ =
 \kappa^\circ
\]
\[ \fbox{$F^\circ$}
 ~~~~
 X^\circ =
 X
 ~~~~ ~~~~
 (A -> B)^\circ =
 A^\circ -> B^\circ
 ~~~~ ~~~~
 (\mu F)^\circ =
 \mu F^\circ
\]
\[ \qquad
 (\lambda X^{p\kappa}.F)^\circ =
 \lambda X^{p\kappa^\circ}.F^\circ
 ~~~~ ~~~~
 (\lambda i^A.F)^\circ =
 F^\circ
\]
\[ \qquad
 (F\;G)^\circ =
 F^\circ\;G^\circ
 ~~~~ ~~~~ ~~~~ ~~~~ ~~
 (F\,\{s\})^\circ =
 F^\circ
\]
\[ \qquad
 (\forall X^\kappa . B)^\circ =
 \forall X^{\kappa^\circ} . B^\circ
 ~~~~ ~~~~
 (\forall i^A . B)^\circ =
 B^\circ
\]
\[ \fbox{$\Delta^\circ$}
 ~~~~
 \cdot^\circ = \cdot
 ~~~~ ~~
 (\Delta,X^{p\kappa})^\circ = \Delta^\circ,X^{p\kappa^\circ}
 ~~~~ ~~
 (\Delta,i^A)^\circ = \Delta^\circ
\]
\[ \fbox{$\Gamma^\circ$}
 ~~~~
 \cdot^\circ = \cdot
 ~~~~ ~~~~
 (\Gamma,x:A)^\circ = \Gamma^\circ,x:A^\circ
\]
\end{definition}

\begin{theorem}[index erasure on well-sorted kinds]
\label{thm:Fixierasesorting}
	$\inference{|- \kappa : \square}{|- \kappa^\circ : \square}$
\end{theorem}

\begin{theorem}[index erasure on well-formed type level contexts]
\label{thm:Fixierasetyctx}
\[ \inference{|- \Delta}{|- \Delta^\circ} \]
\end{theorem}

\begin{theorem}[index erasure on kind equality]\label{thm:Fixierasekindeq}
$ \inference{|- \kappa=\kappa':\square}
	{|- \kappa^\circ=\kappa'^\circ:\square}
$
\end{theorem}

\begin{theorem}[index erasure on well-kinded type constructors]
\label{thm:Fixierasekinding}
\[ \inference{|- \Delta & \Delta |- F : \kappa}
		{\Delta^\circ |- F^\circ : \kappa^\circ}
\]
\end{theorem}
\begin{theorem}[index erasure on type constructor equality]
\[ \inference{\Delta |- F=F':\kappa}
		{\Delta^\circ |- F^\circ=F'^\circ:\kappa^\circ}
\]
\label{thm:Fixierasetyconeq}
\end{theorem}

\begin{theorem}[index erasure on well-formed term level contexts]
\label{thm:Fixierasetmctx}
\[ \inference{\Delta |- \Gamma}{\Delta^\circ |- \Gamma^\circ} \]
\end{theorem}

\begin{theorem}[index erasure on index-free well-typed terms]
\label{thm:Fixierasetypingifree}
\[ \inference{ \Delta |- \Gamma & \Delta;\Gamma |- t : A}
		{\Delta^\circ;\Gamma^\circ |- t : A^\circ}
		{\enspace(\dom(\Delta)\cap\FV(t) = \emptyset)}
\]
\end{theorem}


We introduce an index variable selection meta-operation that selects all
the index variable bindings from the type level context.
\begin{definition}[index variable selection]
\[ \cdot^\bullet = \cdot \qquad
	(\Delta,X^{p\kappa})^\bullet = \Delta^\bullet \qquad
	(\Delta,i^A)^\bullet = \Delta^\bullet,i:A
\]
\end{definition}

\begin{theorem}[index erasure on well-formed term level contexts
		prepended by index variable selection]
\label{thm:Fixierasetmctxivs}
\[ \inference{\Delta |- \Gamma}{\Delta^\circ |- (\Delta^\bullet,\Gamma)^\circ}
\]
\end{theorem}

\begin{theorem}[index erasure on well-typed terms]
\label{thm:Fixierasetypingall}
\[ \inference{\Delta |- \Gamma & \Delta;\Gamma |- t : A}
		{\Delta^\circ;(\Delta^\bullet,\Gamma)^\circ |- t : A^\circ}
\]
\end{theorem}


\KYA{TODO has there been any studies on the logical consistencies of
	implicit calculus + equi-recursive type?}

