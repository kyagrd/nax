\section{The simply-typed lambda calculus}\label{sec:stlc}
\begin{figure}
\begin{singlespace}
\begin{minipage}{.46\textwidth}
	\begin{center}Church-style\end{center}
\def\baselinestretch{0}
\small
\begin{align*}
\textbf{term syntax} \\
t,s ::= &~ x           & \text{variable}    \\
      | &~ \l(x:A) . t & \text{abstraction} \\
      | &~ t ~ s       & \text{application} \\
\\
\textbf{type syntax} \\
A,B ::= &~ A -> B  & \text{arrow type} \\
      | &~ \iota   & \text{ground type}   \\
\end{align*}
\[ \textbf{typing context} \]\vspace*{-1em}
\begin{align*}\quad
\Gamma ::= &~ \cdot \\
	 | &~ \Gamma, x:A \quad (x\notin \dom(\Gamma)) \\
\end{align*}
\[ \textbf{typing rules}
	\qquad \framebox{$\Gamma |- t : A$} \]
\vspace*{-1em}
\begin{align*}
& \inference[\sc Var]{x:A \in \Gamma}{\Gamma |- x:A} \\
& \inference[\sc Abs]{\Gamma,x:A |- t : B}
		     {\Gamma |- \l(x:A).t : A -> B} \\
& \inference[\sc App]{\Gamma |- t : A -> B & \Gamma |- s : A}
		     {\Gamma |- t~s : B} \\
\end{align*}
\[ \textbf{reduction rules}
	\quad \framebox{$t --> t'$} \]
\vspace*{-1em}
\begin{align*}
& \inference[\sc RedBeta]{}{(\l(x:A).t)~s --> t[s/x]} \\
& \inference[\sc RedAbs]{t --> t'}{\l(x:A).t --> \l(x:A).t'} \\
& \inference[\sc RedApp1]{t --> t'}{t~s --> t'~s} \\
& \inference[\sc RedApp2]{s --> s'}{t~s --> t~s'} \\
\end{align*}
\end{minipage}
\begin{minipage}{.46\textwidth}
	\begin{center}Curry-style\end{center}
\def\baselinestretch{0}
\small
\begin{align*}
\textbf{term syntax} \\
t,s ::= &~ x           \\
      | &~ \l x    . t \\
      | &~ t ~ s       \\
\\
\textbf{type syntax} \\
A,B ::= &~ A -> B \\
      | &~ \iota  \\
\end{align*}
\[ \textbf{typing context} \]\vspace*{-1em}
\begin{align*}\quad
\Gamma ::= &~ \cdot \\
	 | &~ \Gamma, x:A \quad (x\notin \dom(\Gamma)) \\
\end{align*}
\[ \textbf{typing rules}
	\qquad \framebox{$\Gamma |- t : A$} \]
\vspace*{-1em}
\begin{align*}
& \inference[\sc Var]{x:A \in \Gamma}{\Gamma |- x:A} \\
& \inference[\sc Abs]{\Gamma,x:A |- t : B}
		     {\Gamma |- \l x   .t : A -> B} \\
& \inference[\sc App]{\Gamma |- t : A -> B & \Gamma |- s : A}
		     {\Gamma |- t~s : B} \\
\end{align*}
\[ \textbf{reduction rules}
	\quad \framebox{$t --> t'$} \]
\vspace*{-1em}
\begin{align*}
& \inference[\sc RedBeta]{}{(\l x   .t)~s --> t[s/x]} \\
& \inference[\sc RedAbs]{t --> t'}{\l x   .t --> \l x   .t'} \\
& \inference[\sc RedApp1]{t --> t'}{t~s --> t'~s} \\
& \inference[\sc RedApp2]{s --> s'}{t~s --> t~s'} \\
\end{align*}
\end{minipage}
~\\
\caption{Simply-typed lambda calculus in Church-style and Curry-style}
\label{fig:stlc}
\end{singlespace}
\end{figure}
We illustrate two styles of the simply-typed lambda calculus (STLC)
in Figure \ref{fig:stlc}. In both styles, a term can either be a variable,
an abstraction (\aka\ lambda term), or an application; and, a type can
either be an arrow type or a ground type. The distinction between
the two style comes from whether the abstraction has type annotation
in the term syntax. The difference in typing rules and reduction rules
follows from this difference in the term syntax. The type syntax are
exactly the same for both styles.

\paragraph{Remark on the ground type:}
Before we elaborate on each style, I'd like to make a remarks on 
the type syntax, in particular, on the ground type ($\iota$).
There would be no question for arrow types, which are types for functions,
since abstractions represent (certain implementations of) functions.
We need some ground types to populate types. Otherwise, if there weren't
any ground types, we won't have any types\footnote{If we allow infinite
types, then it is possible to do away with ground types. There exist
exotic lambda calculi with infinite types, but rather uncommon.}
-- then, such version of STLC will be very uninteresting since there cannot
be any well-typed terms satisfying the typing judgement according to
the typing rules. Here, I provide the most simple ground type ($\iota$),
which does not inhabit any terms (\aka\ the void type). Note that there
exists no term of type $\iota$. We can have functions over $\iota$,
such as ($\l(x:\iota).x$), the identity on $\iota$ .\footnote{Here,
	I present examples in Church-style since it is more succinct than
	writing typing judgments (\eg, $(\l x.t) : \iota -> \iota$)
	in the Curry-style.  But, the remark on the ground type $\iota$
	holds the same for both styles.}
However, there exist no term, to which we cannot apply ($\l(x:\iota).x$).
What we can do is to apply higher-order functions
(\eg, $\l(x_{f}:\iota -> \iota).\l(x_a:\iota).x_f~x_a$, which expects
an argument of type $\iota -> \iota$) to the functions over $\iota$.

When people use STLC to model a programming language (with simple types),
they usually provide richer set of ground types other than the void type
(\eg, unit, boolean, natural numbers). In such versions of STLC with further
extensions to the type syntax, they also need to extend the term syntax
by providing normal terms for the ground types (\eg, \textsf{true} and
\textsf{false} for booleans) and eliminators (\eg, if-then-else expression for
booleans) that can examine the normal terms. Here, having just the void type
is good enough for my purpose of leading up the discussion for
the polymorphic type systems, without complicating the term syntax.

\paragraph{Well-known properties of STLC (in both styles):}
type preservation (\aka\ subject reduction)
reduction preserves type
\begin{align*}
\inference{\Gamma |- t : A  & t --> t'}{\Gamma |- t' : A}
 &\qquad \text{type preservation, or, subject reduction}
\end{align*}
Strong normalization

\paragraph{In Church style,} the variable ($x$) in an abstraction
($\l(x:A).t$) has a type annotation ($A$). Intuitively, we may think of
the abstraction ($\l(x:A).t$) as a function that expects an argument of
the type ($A$) specified by the type annotation.

There are some interesting properties that hold in Church style,
but not in Curry style. Here, I discuss two of them:
\begin{itemize}
\item \emph{Uniqueness of typing}
\[ \inference{\Gamma |- t : A & \Gamma |- t : A'}{A = A'} \]

\item \emph{Type preservation over well-typed $\beta$-equivalence}
\begin{align*}
& \inference{t =_{\beta} t' & \Gamma |- t : A & \Gamma |- t' : A'}{A = A'} \\
& \text{where $=_{\beta}$ is the reflexive symmetric transitive closure of $-->$.}
\end{align*}
\end{itemize}

\emph{Uniqueness of typing}, described in the first item above,
holds in the Church-style STLC.  More specifically, given
a well-formed typing context $\Gamma$ and a term $t$ as input,
if the term is well-typed, that is, $\Gamma |- t : A$ for some type $A$,
then that $A$ is the unique such type. We can prove this by induction on
the derivation of the typing judgment.
For variables, it trivially holds since the variables appearing in
the typing contexts are unique.
For abstractions, we use induction on the derivation.
To use the induction hypothesis we should make sure that
the typing context ($\Gamma,x:A$) and the term $t$ of the premise
is uniquely determined. It is easy to see that they are uniquely determined
since all the peaces appearing in the input (\ie, the typing context and
the term) of the premise (in particular, $\Gamma$, $A$, and $t$) are
part of the input (in particular the term $\l(x:A).t$) of the conclusion.
Therefore, by induction hypothesis, $B$ is uniquely determined, and,
as a consequence, $A -> B$ is uniquely determined.
For applications, it is easy to show by induction for each of the premise.
This proof describes the essence of the type reconstruction algorithm for
the Church-style STLC.

Proving \emph{type preservation over well-typed $\beta$-equivalence},
described in the second item above, amounts to proving
\emph{type preservation over well-typed
$\beta$-reduction and $\beta$-expansion}, described below:
\begin{align}
\inference{t --> t' & \Gamma |- t : A & \Gamma |- t' : A'}{A = A'}
	\label{eqn:welltypedarrow}
\end{align}
That is, when a well-typed term ($t$) \emph{reduces} to
another well-typed term ($t'$) in single step ($t --> t'$),
the types of those two terms are identical ($A=A'$).
Since the claim above is symmetric, we can also say: when a well-typed term
($t'$) expands to another well-typed term ($t$) in single step ($t' <-- t$),
the types of those two terms are identical ($A'=A$).
Let us break down the claim (\ref{eqn:welltypedarrow}) above into two parts:
\[
\inference{t --> t' & \Gamma |- t : A}
          {\Gamma |- t' : A' ~~\text{implies}\quad A = A'} \qquad
	\begin{smallmatrix}
		\text{type preservation over} \\
  		\text{well-typed $\beta$-reduction}
	\end{smallmatrix}
\]
\[
\inference{t --> t' & \Gamma |- t' : A'}
          {\Gamma |- t : A \quad\text{implies}\quad A = A'} \qquad
	\begin{smallmatrix}
		\text{type preservation over} \\
  		\text{well-typed $\beta$-expansion}
	\end{smallmatrix}
\]~\vspace*{-3em}\\

We know that the former (type preservation over well-typed $\beta$-reduction)
holds because we already know of a stronger property,
type preservation over $\beta$-reduction, which we discussed earlier
(repeated below) that it is one of the properties that commonly hold
in both Church style and Curry style.
\begin{align*}
\inference{\Gamma |- t : A  & t --> t'}{\Gamma |- t' : A}
 &\qquad \text{type preservation, or, subject reduction}
\end{align*}

\begin{figure}
\begin{singlespace}
\begin{tabular}{lp{7cm}}
$t <-- (\l(x:\iota).x)~t$ &
relying on the property of the void type
that $\iota$ is not inhabited by any term
\\ ~ \\
$t <-- (\l(x:\iota -> \iota).t)~(\l(x:\iota).x~x)$ &
without relying on the property of $\iota$ : \par
apply a constant function to an already ill-typed term (self application)
\end{tabular}
\end{singlespace}
\caption{$\beta$-expansion to ill-typed terms}
\label{ill-typed_expand}
\end{figure}

So, what is interesting about the Church style STLC, in contrast to
the Curry-style STLC, is the latter part of the claim that
well-typed $\beta$-expansion preserves type. Unlike the former part of
the claim on $\beta$-reduction, where reduced term is always well-typed
(corollary of subject reduction), we really need the condition that
expanded term is well-typed ($\Gamma |- t : A$). This is because a well-typed
term can be expanded to a ill-typed term. In fact, we can always expand any
well-typed term to ill-typed terms (see Figure \ref{ill-typed_expand}).

The proof of (\ref{eqn:welltypedarrow}) is very simple.
Recall that we are that $t --> t'$, $\Gamma |- t : A$,
and $\Gamma |- t' : A'$; and we want to show $A = A'$.
We prove by using \emph{subject reduction} and \emph{uniqueness of typing},
as follows:
\[ \inference[(\emph{uniqueness of typing})]
	{ \inference[(\emph{subject reduction})\!\!\!]
		{t --> t' & \Gamma |- t : A}
		{\Gamma |- t' : A \phantom{a_f}} 
	& \Gamma |- t' : A' }
	{ A = A' }
\]

\paragraph{In Curry style,} there is no annotation on the variable in
an abstraction. Since the variable binding in the abstraction is no longer
fixed to a specific type, \emph{uniqueness of typing} does not hold,
unlike in Church style. For instance, the identity function ($\l x.x$)
could have one of any type that has of the form $A -> A$, such as:
\begin{quote}\vspace*{-1em}
\begin{singlespace}
$\Gamma |- \l x.x : \iota -> \iota$ \\
$\Gamma |- \l x.x : (\iota -> \iota) -> (\iota -> \iota)$ \\
$\Gamma |- \l x.x : (\iota -> (\iota -> \iota)) -> (\iota -> (\iota -> \iota))$ \\
$\Gamma |- \l x.x : ((\iota -> \iota) -> \iota) -> ((\iota -> \iota) -> \iota)$ \\
$\Gamma |- \l x.x : ((\iota -> \iota) -> (\iota -> \iota)) -> ((\iota -> \iota) -> (\iota -> \iota))$ \\
$~~~~ \vdots $
\end{singlespace}
\end{quote}
So, we read the typing judgment $\Gamma |- t : A$ in Curry style as
\begin{quote}
$t$ \emph{can have type} $A$ under the typing context $\Gamma$,
\end{quote}
unlike in Church style where we read the typing judgment as
\begin{quote}
$t$ \emph{has the type} $A$ under the typing context $\Gamma$.
\end{quote}
However, we don't consider the Curry-style STLC to be
a polymorphic type system since the typing for a variable
under a well-formed context is still unique. That is,
\[ \inference{\Gamma |- x : A & \Gamma |- x : A'}{A = A'} \]


Type preservation over well-typed $\beta$-reduction and $\beta$-expansion 
does not hold either, unlike in Church style. Even when a well-typed term
reduces to another well-typed term, they may be given different types.
Consider the reduction $(\l x'.x')(\l x.x) --> \l x.x$.
We can give different types to the term before the recuction and the
term after the reduction.
\[\setpremisesend{.1em} 
\inference[\sc App]
 {
   \inference[\sc Lam]
     { \inference[\sc Var]
         {x' : \iota -> \iota ~\in~ \cdot, x' : \iota -> \iota}
         {\cdot,x' : \iota -> \iota |- x': \iota -> \iota}
     }
     {\cdot |- \l x'.x' : (\iota -> \iota) -> (\iota -> \iota)}
 &
   \inference[\sc Lam]
     {\inference[\sc Var]{x:\iota ~\in~ \cdot,x:\iota}
                         {\cdot,x:\iota |- x:\iota} \phantom{x'}}
     {\cdot |- \l x.x : \iota -> \iota \phantom{(x')}}
 }
 {\cdot |- (\l x'.x')(\l x.x) : \iota -> \iota}
\]
\[\qquad\qquad\qquad\quad
\inference[\sc Lam]
  {\inference[\sc Var]{x:\iota->\iota ~\in~ \cdot,x:\iota->\iota}
                      {\cdot,x:\iota->\iota |- x:\iota->\iota} }
  {\cdot |- \l x.x : (\iota -> \iota) -> (\iota -> \iota)}
\]

%% does the set of possible types get larger after reduction even when
%% the only ground type is the void type? I am not sure. So, I won't
%% elaborate on this.

\KYA{TODO motivation for principal type scheme}

%%%% need to rewrite this
%%%%%%%%%%%% Well-typed expansion does not preserve types in the Curry style.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Type preservation for $\beta$-expansion does not to hold either,
%% unlike in Church style. More fundamentally, well-typedness is not preserved
%% for inverse $\beta$-reduction. The reason for this is exactly because
%% uniqueness of typing does not hold in Curry style. Consider the following
%% $\beta$-reduction:
%% \[(\l x_I. (x_I~s_1)~(x_I~s_2)) (\l x.x) --> ((\l x.x)~s_1)~((\l x.x)~s_2)\]
%% This is a perfectly fine reduction according to the reduction rules for the
%% Curry-style STLC in Figure \ref{fig:stlc}. However, there exist $s_1$ and
%% $s_2$ such that the right-hand side is well-typed but the left-hand side
%% is not.
%% 
%% The left-hand side cannot be well-typed, regardless of $s_1$ and $s_2$.
%% The variable $x_I$ appearing in the abstraction must have a type of the form
%% $A -> A$, since the abstraction is applied to the identity term $(\l x.x)$.
%% In the body of the abstraction, which is an application
%% $(x_I~s_1)~(x_I~s_2)$, we have a problem. Since $x_I$ has an arrow type
%% that expects an agrument of type $A$ and returns a result of type $A$,
%% both $(x_I~s_1)$ and $(x_I~s_2)$ have the same type $A$.  Thus,
%% the application $(x_I~s_1)~(x_I~s_2)$ cannot be well-typed, since
%% the function $(x_I~s_1)$ applied to the argument $(x_I~s_2)$ of type $A$
%% must have type $A -> A$. But, we know that $(x_I~s_1)$ has type $A$.
%% The fact that uniqeness of typing does not hold won't help us resolve
%% the contraticting typing requrements of $(x_I~s_1)$ here, because
%% the typing of a variable is still unique under a well-formed context.
%% There is no way to satisfy both $\Gamma |- x_I : A -> A$ and 
%% $\Gamma |- x_I : (A -> A) -> (A -> A)$ even in the Curry-style STLC.
%% 
%% There exist $s_1$ and $s_2$ such that the right-hand side is well-typed.
%% Actually, there are many such $s_1$ and $s_2$. I will just give two
%% instances of them. Try to justify them yourself. They are easy exercises.
%% One instance is to let $s_1 = (\l x_I . \l x . x_I~x)$, which is
%% a higher-order function, and $s_2 = (\l x. x)$. Since uniqueness typing
%% does not hold, we are able to find approprite types for each occcurence of
%% ($\l x.x$) appearing in the right-hand side. Another instance is having
%% both of them to be the identity term, that is, let $s_1 = (\l x . x)$ and
%% $s_2 = (\l x . x)$ as well.

