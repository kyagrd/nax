\section{Embedding course-of-values primitive recursion}
\label{sec:fixi:cv}

\lstset{language=Haskell,
	basicstyle=\ttfamily\small,
%	keywordstyle=\color{ta4chameleon},
%	emph={List,Int,Bool},
	commentstyle=\color{grey},
	literate =
		{forall}{{$\forall$}}1
%		{|}{{$\mid\;\,$}}1
%		{=}{{\textcolor{ta3chocolate}{$=\,\;$}}}1
		{::}{{$:\!\,:$}}1
		{->}{{$\to$}}1
		{=>}{{$\Rightarrow$}}1
		{\\}{{$\lambda$}}1
	}

To add a new Mendler style operation, we need to address several issues.
\begin{itemize}
\item First, we need to add an appropriate type-level fixpoint operation
that is used to build recursive types. This type-level operation needs to
capture not only the tyeing of the recursive knot, but also the additional
structure need to encode the new Mendler operation.
\item Second we need to encode the new operation. This means discovering the
characteristic equations that the operation should obey.
\item Third, we need to find an embedding that preserves the characteristic
equations in the host calculus.
\item In practice, the second and third steps are intimately entwined as
the equations and embedding are carefully designed (using a Church-style encoding)
to acheive the desired result.
\end{itemize}

To encode a Mendler style operator encoding course of values recursion,
one must not only satisfy the steps above, but also do this in a manner
that supports a single step unroll operation $\unIn_F$, which is the key step
to support course-of-values recursion. For example, recall the defintion
of fibonocci in Section ???.

Figure~\ref{fig:embedMcvPr} and Figure~\ref{fig:unInExamples}
illustrate the embedding of a new iso-recursive type operator ($\mu^{+}_\kappa$) and
illustrate the embedding of
the course-of-values primitive recursor ($\McvPr_\kappa$) in \Fixi. We also encode
both the roll and unroll operations ($\In_F$ and $\unIn_F$). These
embeddings are valid for
a fairly large class of positive base structures ($F$).

The embeddings of $\mu^{+}_\kappa$, $\McvPr_\kappa$, and $\In_F$
are very similar to the embeddings of $\mu_\kappa$, $\MPr_\kappa$,
and $\In_\kappa$ in the previous section where we discussed primitive recursion.
The differences are ...

\afterpage{ %%%%%%%%%%%%%%%%%%%%%%% begin afterpage
\begin{landscape}
\begin{figure}
\begin{singlespace}
\begin{align*}
\mu^{+}_\kappa &\;:~ 0(+\kappa -> \kappa) -> \kappa \\
\mu^{+}_\kappa &\triangleq
\l X_{\!F}^{0(+\kappa -> \kappa)}.\fix(\Phi^{+}_\kappa\,X_{\!F})\\
\Phi^{+}_\kappa &\;:~ 0(+\kappa -> \kappa) -> +\kappa -> \kappa \\
\Phi^{+}_\kappa &\triangleq \l X_{\!F}^{0(+\kappa -> \kappa)}.
\l X_c^{+\kappa}.\boldsymbol{\l}\mathbb{I}^\kappa.
\forall X^\kappa.
(\forall X_r^\kappa. (X_r \karrow{\kappa} X_{\!F}\,X_r)
		-> (X_r \karrow{\kappa} X_c)
		-> (X_r \karrow{\kappa} X)
		-> (X_{\!F}\,X_r \karrow{\kappa} X) ) -> X\,\mathbb{I}\\
~\\
\McvPr_\kappa &\;:~
	\forall X_{\!F}^{+\kappa-> \kappa}.\forall X^\kappa.
	(\forall {X_r}^{\!\!\kappa}.
	 (X_r \karrow{\kappa} X_{\!F}\,X_r) ->
	 (X_r \karrow{\kappa} \mu^{+}_\kappa X_{\!F}) ->
	 (X_r \karrow{\kappa} X) ->
	 (X_{\!F}\,X_r \karrow{\kappa} X) ) ->
	 (\mu^{+}_\kappa X_{\!F} \karrow{\kappa} X) \\
\McvPr_\kappa &\triangleq \l s.\l r.r\;s\\
~\\
\In_F &\;:~ F(\mu^{+}_\kappa F) \karrow{\kappa} \mu^{+}_\kappa F\\
\In_F &\triangleq
	\l t. \l s. s~\unIn_F\;\textit{id}\;\,(\McvPr_\kappa\;s)\;\,t \\
\end{align*}\vskip -2.5ex
Provided that there exists
$\unIn_{F} : \mu^{+}_\kappa F \karrow{\kappa} F(\mu^{+}_\kappa F)$
for the base structure $F:+\kappa -> \kappa$, 
such that $\unIn_F(\In_F\;t) -->+ t$
where the reduction is constant regardless of $t$
(steps may vary between each base structure $F$ though).
\end{singlespace} \vskip-3.5ex
\[\text{See Figure \ref{fig:unInExamples} for
embeddings of unroll operations ($\unIn_F$) for
some well-known positive base structures ($F$).}
\]
\caption{Embedding of the recursive type operators ($\mu^{+}_\kappa$),
	the Mendler-style course-of-values primitive recursors
	($\McvPr_\kappa$), and the roll operation ($\In_F$) in \Fixi,
        provided that the embedding of $\unIn_F$ exists}
\label{fig:embedMcvPr}
\end{figure}

\begin{figure}
\[\!\!\!\!\!\!\!
\begin{array}{llcll}
	& \text{\textbf{Regular datatypes}} \\
N &\!\!\!\triangleq \l X^{+*}.X + \textsf{Unit} &\qquad&
\unIn_N &\!\!\!\triangleq \McvPr_{*} (\l\_.\l\textit{cast}.\l\_.
	\l x. x\;(\texttt{InL}\circ\textit{cast})\;\texttt{InR})
	\\
L &\!\!\!\triangleq \l X_a^{+*}.\l X^{+*}.(X_a\times X) + \textsf{Unit} &&
\unIn_{(LA)} &\!\!\!\triangleq \McvPr_{*} (\l\_.\l\textit{cast}.\l\_.
	\l x. x\;(\texttt{InL}\circ(\textit{id}\times cast))\;\texttt{InR})
	\\
R &\!\!\!\triangleq \l X_a^{+*}.\l X^{+*}.(X_a\times \texttt{List} X) -> X &&
\unIn_{(RA)} &\!\!\!\triangleq \McvPr_{*} (\l\_.\l\textit{cast}.\l\_.
	\l x. x\;(\textit{id}\times \textit{fmap}_\texttt{List}\;cast) )
	\\
& \text{\textbf{Type-indexed datatypes}} \phantom{G^{G^{G^{G^{G^G}}}}}\\
P &\!\!\!\triangleq \l X^{+* -> *}.\l X_a^{+*}.
	X_a \times X(X_a \times X_a) + \textsf{Unit} &&
\unIn_P &\!\!\!\triangleq \McvPr_{+* -> *} (\l\_.\l\textit{cast}.\l\_.
	\l x. x \;(\texttt{InL}\circ(\textit{id}\times\textit{cast}))
		\;\texttt{InR})
	\\
B &\!\!\!\triangleq \l X^{+* -> *}.\l X_a^{+*}.
	X_a \times X(X\,X_a) + \textsf{Unit} &&
\unIn_B &\!\!\!\triangleq \McvPr_{+* -> *} (\l\_.\l\textit{cast}.\l\_.
 	\l x. x \;(\texttt{InL}\circ
 		(\textit{id}\times
 			(\textit{cast}\circ\textit{fmap}\;\textit{cast})))
 		\;\texttt{InR})
	\\
	& \text{\textbf{Term-indexed datatypes}} \phantom{G^{G^{G^{G^{G^G}}}}}
\end{array}
\]\vskip-4.5ex
\[
V \triangleq \l X_a^{*}.\l X^{\texttt{Nat} -> *}.\l i^{\texttt{Nat}}.
(\exists j^\texttt{Nat}.((i=\texttt{succ}\,j) \times X_a \times X\{j\})) +
(i=\texttt{zero})
\]
\[
\begin{array}{lll}
\texttt{VCons} &\!\!\!\triangleq \l x_a.\l x.
	\texttt{InL}(\mathtt{Ex_{Nat}}(\mathtt{Eq_{\,Nat}},x_a,x))
& : \;
\forall X_a^{*}. \forall X^{\texttt{Nat} -> *}. \forall i^\texttt{Nat}.
	X_a -> X\,\{i\} -> V\,X_a\,X\,\{\texttt{succ}\,i\}
	\\
\texttt{VNil} &\!\!\!\triangleq \texttt{InR}~\mathtt{Eq_{\,Nat}}
& : \;
\forall X_a^{*}. \forall X^{\texttt{Nat} -> *}. V\,X_a\,X\,\{\texttt{zero}\}
\end{array}
\]
\[
\unIn_{(V\,A)} \triangleq \McvPr_{\texttt{Nat} -> *}(\l\_.\l\textit{cast}.\l\_.
\l x. x \;(\texttt{InL}\circ
		(\textit{id}\times\textit{id}\times\textit{cast}))
	\;\texttt{InR})
\]
The notation $\exists j^A.B$ is a shorthand for $\exists_A(\l j^A.B)$
where $\exists_A$ is defined in Figure~\ref{fig:fixiNonRecData}.\\
$\mathtt{Ex_{A}} : \forall F^{A -> *}.\exists_A F$ and
$\mathtt{Eq_{A}} : \forall i^A.\forall j^A.(i=j)$ are
the data constructors of the existential type and the equality type.
\[\text{
See Figure \ref{fig:embedMcvPr} for the embedding of the Mendler-style
course-of-values primitive recursor ($\McvPr_\kappa$)}
\]
\caption{Embeddings of unroll operator ($\unIn_F$)
	for some well-known positive base structures ($F$).}
\label{fig:unInExamples}
\end{figure}

\end{landscape}
} %%%%%%%%%%%%%%%%%%%%%%% end of afterpage
%% [basicstyle={\ttfamily\small},language=Haskell,mathescape]

The embedding of unroll operations for some well-known positive datatypes
are illustrated in Figure~\ref{fig:unInExamples}. The idea is to use
$\McvPr_\kappa$ to define $\unIn_F$ for the base structure
$F:+\kappa -> \kappa$ without using the abstract recursive call operation
in order to be constant time. To define the unroll operation, we map
non-recursive components ($X_a$) as they are using \textit{id} and map
abstract recursive components ($X_r$) to concrete recursive components
($\mu^{+}_\kappa F$) using the abstract \textit{cast} operation provided
by the $\McvPr_\kappa$ combinator. We can embed unroll operations
for regular datatypes such as natural numbers (the base $N$) and lists
(the base $L$), type-indexed datatypes such as powerlists (the base $P$),
and term-indexed datatypes such as vectors (the base $V$) in this way.
The embeddings of $\unIn_N$ and $\unIn_L$ are self explanatory.
In fact, we can generalize \lstinline$mcvpr0 (\ _ cast _ ->  fmap cast)$
For intuitive understanding of the embedding of $\unIn_P$ and $\unIn_B$,
we provide transcriptions into Haskell in Figures~\ref{fig:HaskellunInP}
and \ref{fig:HaskellunInB}.
(see Figure~\ref{fig:HaskellFunctor1} for the defintions of \texttt{Mu1} and
\texttt{mcvpr1}). To embed unrolling operation for indexed datatypes we would
often need existential types (Figure~\ref{fig:fixiNonRecData}) and
equality types. We can encode equality types in \Fixi\ as a Leibniz equality
over indices, \ie, $(i=j) \triangleq \forall F^{A -> *}.F\{i\} -> F\{j\}$,
as discussed in \S\ref{Leibniz}.

\begin{figure}
\begin{singlespace}
\begin{lstlisting}
newtype Mu0 f = In0 { unIn0 :: f(Mu0 f) }

mcvpr0 :: Functor f => (forall r. (r -> f r) ->
                           (r -> Mu0 f) ->
                           (r -> a) ->
                           (f r -> a) )
       -> Mu0 f -> a
mcvpr0 phi = phi unIn0 id (mcvpr0 phi) . unIn0

newtype Mu1 f i = In1 { unIn1 :: f(Mu1 f)i }

mcvpr1 :: Functor1 f =>
         (forall r i'. Functor r => (forall i. r i -> f r i) ->
                              (forall i. r i -> Mu1 f i) ->
                              (forall i. r i -> a i) ->
                              (f r i' -> a i') )
       -> Mu1 f i -> a i
mcvpr1 phi = phi unIn1 id (mcvpr1 phi) . unIn1

class Functor1 h where
  fmap1  :: Functor f => (forall i j. (i -> j) -> f i -> g j)
                     -> (a -> b) -> h f a -> h g b
  -- fmap1 h = fmap1' (h id)

  fmap1' :: Functor f => (forall i. f i -> g i)
                     -> (a -> b) -> h f a -> h g b
  fmap1' h = fmap1 (\f -> h . fmap f)

instance (Functor1 h, Functor f) => Functor (h f) where
  fmap f = fmap1' id
        -- fmap1 (\f -> id . fmap f)

instance Functor (f (Mu1 f)) => Functor (Mu1 f) where
  fmap f = In1 . fmap f . unIn1
\end{lstlisting}
\end{singlespace}
\caption{$\mu_{*}$, $\McvPr_{*}$, and $\mu_{* -> *}$, $\McvPr_{* -> *}$
	transcribed into Haskell}
\label{fig:HaskellFunctor1}
\end{figure}

\begin{figure}
\begin{lstlisting}
data N r   = S r   | Z  deriving Functor
type Nat = Mu0 N
data L a r = C a r | N  deriving Functor
type List a = Mu0 (L a)
data R a r = F a [r]    deriving Functor -- relies on (Functor [])
type Rose a = Mu0 (R a)

unInN :: Mu0 N -> N(Mu0 N)
unInN = mcvpr0 (\ _ cast _ ->  fmap cast)
unInL :: Mu0(L a) -> (L a) (Mu0(L a))
unInL = mcvpr0 (\ _ cast _ ->  fmap cast)
unInR :: Mu0(R a) -> (R a) (Mu0(R a))
unInR = mcvpr0 (\ _ cast _ ->  fmap cast)
\end{lstlisting}
\label{fig:HaskellunInRegular}
\caption{Embedings of $\unIn_N$, $\unIn_{(L A)}$, $\unIn_{(R A)}$ into Haskell}
\end{figure}

\begin{figure}
\begin{singlespace}
\begin{lstlisting}
data P r i = PC i (r (i,i)) | PN
type Powl i = Mu1 P i

instance Functor1 P where
  fmap1 h f (PC x a) = PC (f x) (h (\(i,j) -> (f i,f j)) a)
  fmap1 _ _ PN = PN

unInP :: Mu1 P i -> P(Mu1 P) i
unInP = mcvpr1 (\ _ cast _ -> fmap1' cast id)
  -- mcvpr1 phi where
  --   phi _ cast _ (PC x xs) = PC x (cast xs)
  --   phi _ cast _ PN = PN
\end{lstlisting}
\end{singlespace}
\caption{Embedding of $\unIn_P$ in Figure~\ref{fig:unInExamples}
	transcribed into Haskell}
\label{fig:HaskellunInP}
\end{figure}


\begin{figure}
\begin{singlespace}
\begin{lstlisting}
data B r i = BC i (r (r i)) | BN
type Bush i = Mu1 B i

instance Functor1 B where
  fmap1 h f (BC x a) = BC (f x) (h (h f) a)
  fmap1 _ _ BN = BN

unInB :: Mu1 B i -> B (Mu1 B) i
unInB = mcvpr1 (\ _ cast _ -> fmap1' cast id)
  -- mcvpr1 phi where
  --   phi _ cast _ (BC x xs) = BC x (cast (fmap cast xs))
  --   phi _ cast _ BN = BN
\end{lstlisting}
\end{singlespace}
\caption{Embedding of $\unIn_B$ in Figure~\ref{fig:unInExamples}
	transcribed into Haskell}
\label{fig:HaskellunInB}
\end{figure}


However, not all datatypes seem to have embeddings of constant time 
unroll operations in this way, as in Figure~\ref{fig:embedMcvPr} and
Figure~\ref{fig:unInExamples}. For instance, the embeddings of
unroll operations for indirectly recursive datatypes such as
the rose tree datatype (the base $R$) are not constant due to the
use of $\textit{fmap}_\textit{List}$, which is obviously not constant
function. What we can do is to prove a meta-property that 
($\textit{fmap}_\texttt{List}\;\textit{cast}) : \texttt{List}(X_r\,X_a)
-> \texttt{List}(\mu^{+}_\kappa R\,X_a)$ can be safely optimized
to the constant time identity function since the value of \textit{cast}
is given as \textit{id} by definition of $\McvPr_\kappa$. But, that does
not mean that we have a constant time embedding of $\unIn_R$ within \Fixi.

For similar reasons, embeddings of unroll operations for
\emph{truly nested datatypes} \cite{AbeMatUus05} such as bushes
(the base $B$) are not likely to be constant either.
In the embedding of $\unIn_B$, we use
$\textit{fmap}\;\textit{cast}: (X_r(X_r\,X_a)) -> (X_r(\mu^{+}_{* -> *}B\,X_a))$
in order to cast the inner abstract recursive type $X_r\,X_a$ into
the concrete recursive type $\mu^{+}_{* -> *}B\,X_a$, before we do the outer
$\textit{cast} : (X_r(\mu^{+}_{* -> *}B\,X_a)) ->
                 (\mu^{+}_{* -> *}B(\mu^{+}_{* -> *}B\,X_a))$.
But this time, there is yet another subtlety other than worrying about
whether $\unIn_B$ is constant time. Note, we boldly assumed that
the abstract recursive type $r$ has an \textit{fmap} operation
(In Haskell, \texttt{{\bf\ttfamily Functor} r}). Previously, in the embedding
of $\unIn_R$ for the rose tree (Figure~\ref{fig:unInExamples}), we used
\textit{fmap} for \texttt{List}, which is a well known type to have
\textit{fmap}. In case of $\unIn_B$, we only know the kind of $r : +* -> *$
but nothing else since $r$ is abstract. So, we should rely on a more general
property that \textit{fmap} is well-defined for all covariant type constructors
of kind $+* -> *$. \KYA{TODO someone should have proved this? if so cite.
	but what about higher kinds?}

Note that the definition of \texttt{unInN}, \texttt{unInL}, \texttt{unInR}
in Figure~\ref{fig:HaskellunInRegular} are of the same form:
\lstinline$mvcvp0 (\ _ cast _ ->  fmap cast)$.  Also, note that
the definition of \texttt{unInP} in Figure~\ref{fig:HaskellunInP}
and \texttt{unInB} in Figure~\ref{fig:HaskellunInP} are of the same form:
\lstinline$mvcvp1 (\ _ cast _ ->  fmap1 cast id)$.
TODO We conjecture that ...

% Embeddings of unroll operations for term-indexed datatypes (e.g. vectors)
% are intuitively more simple than type-indexed datatypes (e.g. powerlists,
% bushes). Due to the erasure property, existence of unroll
% We will discuss the conditions when we can further NO, it's the other way
% around

\KYA{ TODO cite Monotone Inductive and Coinductive Constructors of Rank 2  - Matthes CSL paper }

\KYA{ TODO state a theorem about this in metatheory and
	cite some previous work on this maybe? }
\KYA{ TODO P do not need Functor requirement but $+* -> *$ kind already
        implies that so it will be true anyway}
\KYA{ TODO someone must have proved free theorems for higher-kinded cases? }


%% Apart from the limitations of constant-time undefinability of $\unIn_F$
%% discussed above, the embeddings illustrated in Figure~\ref{fig:unInExamples}
%% are not in spirit of Mendler-style. Note that the embeddings of $\unIn_F$ are
%% polytypic (different term encodings for each different $F$) rather than
%% polymorphic (one uniform term encoding whose type is polymorphic over $F$).
%% Recall that the key advantage of Mendler-style comes from being polymorhpic.
%% 
%% Fortunately, there does exists more proper Mendler-style embeddings
%% of the course-of-values combinators over arbitrary positive datatypes
%% using both iteration and coiteration schemes \cite{TODO}. Since coiteration
%% is embeddable in \Fi\ and co(-primitive-)recursion is embeddable in \Fixi,
%% the result directly applies without extending our calculi. However,
%% to our knowledge, course-of-values combinators over higher-kinded
%% type constructors (\ie, type constructors other than kind $*$) has not been
%% well studied enough, even in that setting of using both iteration/recursion
%% and coiteration/corecursion. That is, course-of-values combinators for
%% regular indirect recursive datatypes are very likely to be embeddable in
%% a calculus like \Fi\ or \Fixi\ directly applying the known results, but
%% we may need further investigation to assure ourselves for the behavior of
%% course-of-values combinators over higher-kinded datatypes.
%% 
%% We leave the search for embeddings for arbitrary positive datatypes,
%% including indirectly recursive datatypes and truly nested datatypes,
%% as future work, since coiteration and corecursion are out of the scope of
%% this dissertation.



