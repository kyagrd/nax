\section{System \Fw} \label{sec:fw}
System \Fw\ \cite{Gir72} extends the type syntax of System \F\ with lambda types
and application types (see Figure \ref{fig:fw}). Lambda types ($\l X^\kappa.F$)
and application types ($F\;G$), at the type level, are analogous to lambda terms
and applications at the term level. Type constructors are like functions, but
at the type level. Type constructors are categorized by kinds, just as terms
are categorized by types. Type constructors of kind $*$ are just \emph{types},
and do not expect any arguments. Type constructors that expect an argument
have arrow kinds ($\kappa -> \kappa'$). A type constructor of kind
$\kappa -> \kappa'$ expects another type constructor of kind $\kappa$
as an argument to produce yet another type constructor of kind $\kappa'$,
just as a function of type $A -> B$ expects another term of type $A$
as an argument, to produce yet another term of type $B$. By convention,
$A$ and $B$ stand for types (\ie, type constructors of kind $*$),
while $F$ and $G$ stand for type constructors or arbitrary kinds.

We can think of System \F\ as a restriction of System \Fw, where we only
allow types of kind $*$. That is, all the type variables appearing in
well-kinded types in System \F\ are of the star kind. Since there exists only
one kind ($*$) in System \F, the kinding rules of System \F\ need only to make
sure that type variables are bound in $\Delta$.

Since the kind structure of System \Fw\ is richer than the kind structure of
System \F, we need to keep track of the kind of the type variables in
the kinding context ($\Delta$). So, the kinding context is extended by
a type variable annotated by its kind ($X^\kappa$). The kinding rules of
System \Fw\ keep track of the kinds of type constructors as well as making
sure that the type variables are bound in $\Delta$.

The kinding rules, for the type syntax inherited from System \F:
\rulename{TVar}, \rulename{TArr}, \rulename{TAll} are similar to
their counterparts in System \F, except for this additional kinding annotation.
The kinding rules \rulename{TLam} and \rulename{TApp} state when the extensions
(lambda types and application types) to System \F\ are well-kinded.

The typing rules of System \Fw\ are almost identical to the typing rules of
System \F, except for one new rule \rulename{Conv}. The \rulename{Conv} rule
supports conversion between equivalent types.

\begin{itemize}
\item In the STLC, types are equal when they are syntactically identical.
\item In System \F, types are equal when they are $\alpha$-equivalent
(\ie, up to change of bound type variable names). For example,
$\forall X.X$ and $\forall X'.X'$ are considered to be same types in System \F.

\item
In System \Fw, we expect a richer notion of equality which incorporates
the notion of $\beta$-equivalence at the type level, since the type syntax of
System~\Fw\ has the structure of the STLC at the type level.
For instance, we want $(\lambda X^{*}.X) A = A$. 
\end{itemize}

The equality rules over the type constructors of System \Fw\ are
illustrated in Figure \ref{fig:eqtyfw}. The \rulename{EqTBeta} rule
describes the essence of $\beta$-equivalence.
Other rules describe the structural nature of equality (\rulename{EqTVar},
\rulename{EqTArr}, \rulename{EqTAll}, \rulename{EqTLam}, \rulename{EqTApp})
and transitivity of equality (\rulename{EqTTrans}).

%% syntax directed formalism???
%% http://pauillac.inria.fr/~herbelin/talks/cic.ps
%% there is a slide the refers to other paper and say that CIC is okay
%% since CIC is full. Is Fw also?

The complete syntax, kinding rules, and typing rules of System \Fw\
are illustrated in Figure \ref{fig:fw}. Since lambda binders exist
at both the term and type levels in System \Fw, we also have a choice of
either Church style (kind annotations on lambda types) or
Curry style (no kind annotations on lambda types) for the type syntax.
In this section (and, also throughout the dissertation), we consider
only the Church style type syntax, that is, the explicitly annotated kinds
on type-level lambdas. So, the distinction between the Church style and
the Curry style is only on the type syntax. The Church-style System \Fw,
on the left column of Figure \ref{fig:fw}, is a version of System \Fw\ with
the Church-style term syntax. The Curry-style System \Fw, on the right column,
is a version of System \Fw\ with the Curry-style term syntax.

The reduction rules of System \Fw\ (Figure \ref{fig:redfw}) are almost identical
to the reduction rules of System \F\ since the term syntax of System \Fw\ is
almost identical to the term syntax of System \F. Reduction rules are defined
only on the structure of terms, usually ignoring types.

The Church-style term syntax of System \Fw\ differs from the term syntax of
System \F\ in the type-abstraction ($\L X^\kappa.t$) terms. The difference is
the kind annotation on the type variable appearing in the System \Fw.
The Church-style term syntax is exactly the same as the term syntax of
System \F.

\begin{figure}
\begin{singlespace}
\begin{minipage}{.46\textwidth}
        \begin{center}Church style\end{center}\vspace*{-1em}
\def\baselinestretch{0}
\small
\begin{align*}
\textbf{term syntax} \\
t,s ::= &~ x               & \text{variable}    \\
      | &~ \l(x:A) . t     & \text{abstraction} \\
      | &~ t ~ s           & \text{application} \\
      | &~ \L X^\kappa . t & \text{type abstraction} \\
      | &~ t [G]           & \text{type application} \\
\textbf{type syntax} \\
F,G,A,B ::= &~ X                  & \text{variable type} \\
          | &~ A -> B             & \text{arrow type} \\
          | &~ \forall X^\kappa.B & \text{forall type}   \\
          | &~ \l X^\kappa.F      & \text{lambda type}   \\
          | &~ F ~ G              & \text{application type}   \\
\textbf{kind syntax} \\
\kappa ::= &~ \kappa -> \kappa' & \text{arrow kind} \\
         | &~ *                 & \text{star kind}   \\
\end{align*}
\[ \textbf{kinding rules} \quad \framebox{$ \Delta |- F:\kappa $} \]\vspace*{-1em}
\begin{align*}
& \inference[\sc TVar]{X^\kappa \in \Delta}{\Delta |- X:\kappa} \\
& \inference[\sc TArr]{\Delta |- A:* & \Delta |- B:*}{\Delta |- A -> B:*} \\
& \inference[\sc TAll]{\Delta,X^\kappa |- B:*}
                      {\Delta |- \forall X^\kappa.B:*} \\
& \inference[\sc TLam]{\Delta,X^\kappa |- F:\kappa'}
                      {\Delta |- \l X^\kappa.F:\kappa -> \kappa'} \\
& \inference[\sc TApp]{\Delta |- F : \kappa -> \kappa' & \Delta |- G : \kappa}
                      {\Delta |- F ~ G : \kappa'} \\
\end{align*}
\[ \textbf{typing rules} \quad \framebox{$ \Delta;\Gamma |- t : A $ } \]
\vspace*{-1em}
\begin{align*}
& \inference[\sc Var]{x:A \in \Gamma}{\Delta;\Gamma |- x:A} \\
& \inference[\sc Abs]{\Delta |- A:* & \Delta;\Gamma,x:A |- t : B}
                     {\Delta;\Gamma |- \l(x:A).t : A -> B} \\
& \inference[\sc App]{\Delta;\Gamma |- t : A -> B & \Delta;\Gamma |- s : A}
                     {\Delta;\Gamma |- t~s : B} \\
& \inference[\sc TyAbs]{\Delta,X^\kappa;\Gamma |- t : B}
                       {\Delta;\Gamma |- \L X^\kappa.t : \forall X^\kappa.B}
	 \begin{smallmatrix}(X\notin\FV(\Gamma))\end{smallmatrix} \\
& \inference[\sc TyApp]{\Delta;\Gamma |- t : \forall X^\kappa.B & \Delta |- G:\kappa}
                       {\Delta;\Gamma |- t[G] : B[G/X]} \\
& \inference[\sc Conv]{\Delta;\Gamma |- t : A & \Delta |- A = A' : *}
                      {\Delta;\Gamma |- t : A'}
\end{align*}
\end{minipage}
\begin{minipage}{.46\textwidth}
        \begin{center}Curry style\end{center}\vspace*{-1em}
\def\baselinestretch{0}
\small
\begin{align*}
\textbf{term syntax} \\
t,s ::= &~ x           \\
      | &~ \l x    . t \\
      | &~ t ~ s       \\
      \phantom{|} &~ \\
      \phantom{|} &~ \\
\textbf{type syntax} \\
F,G,A,B ::= &~ X                  \\
          | &~ A -> B             \\
          | &~ \forall X^\kappa.B \\
          | &~ \l X^\kappa.F      \\
          | &~ F ~ G              \\
\textbf{kind syntax} \\
\kappa ::= &~ \kappa -> \kappa' \\
         | &~ *                 \\
\end{align*}
\[ \textbf{kinding rules} \quad \framebox{$ \Delta |- F:\kappa$}\]\vspace*{-1em}
\begin{align*}
& \inference[\sc TVar]{X^\kappa \in \Delta}{\Delta |- X:\kappa} \\
& \inference[\sc TArr]{\Delta |- A:* & \Delta |- B:*}{\Delta |- A -> B:*} \\
& \inference[\sc TAll]{\Delta,X^\kappa |- B:*}{\Delta |- \forall X^\kappa.B:*} \\
& \inference[\sc TLam]{\Delta,X^\kappa |- F:\kappa'}
                      {\Delta |- \l X^\kappa.F:\kappa -> \kappa'} \\
& \inference[\sc TApp]{\Delta |- F : \kappa -> \kappa' & \Delta |- G : \kappa}
                      {\Delta |- F ~ G : \kappa'} \\
\end{align*}
\[ \textbf{typing rules} \quad \framebox{$ \Delta;\Gamma |- t : A $ } \]
\vspace*{-1em}
\begin{align*}
& \inference[\sc Var]{x:A \in \Gamma}{\Delta;\Gamma |- x:A} \\
& \inference[\sc Abs]{\Delta |- A:* & \Delta;\Gamma,x:A |- t : B}
                     {\Delta;\Gamma |- \l x   .t : A -> B} \\
& \inference[\sc App]{\Delta;\Gamma |- t : A -> B & \Delta;\Gamma |- s : A}
                     {\Delta;\Gamma |- t~s : B} \\
& \inference[\sc TyAbs]{\Delta,X^\kappa;\Gamma |- t : B}
                       {\Delta;\Gamma |- t : \forall X^\kappa.B}
	 \begin{smallmatrix}(X\notin\FV(\Gamma))\end{smallmatrix} \\
& \inference[\sc TyApp]{\Delta;\Gamma |- t : \forall X^\kappa.B & \Delta |- G:\kappa}
                       {\Delta;\Gamma |- t : B[G/X]} \\
& \inference[\sc Conv]{\Delta;\Gamma |- t : A & \Delta |- A = A' : *}
                      {\Delta;\Gamma |- t : A'}
\end{align*}
\end{minipage}
~\\
\caption{System \Fw\ in Church style and Curry style}
\label{fig:fw}
\end{singlespace}
\end{figure}

%% \begin{figure}
%% \begin{singlespace}
%% \begin{minipage}{.46\textwidth}
%%         \begin{center}Curry-Church-style\end{center}
%% \def\baselinestretch{0}
%% \small
%% \begin{align*}
%% \textbf{term syntax} \\
%% t,s ::= &~ x           & \text{variable}    \\
%%       | &~ \l x    . t & \text{abstraction} \\
%%       | &~ t ~ s       & \text{application} \\
%% \textbf{type syntax} \\
%% F,G,A,B ::= &~ X                  & \text{variable type}    \\
%%           | &~ A -> B             & \text{arrow type}       \\   
%%           | &~ \forall X^\kappa.B & \text{forall type}      \\
%%           | &~ \l X^\kappa.F      & \text{lambda type}      \\
%%           | &~ F ~ G              & \text{application type} \\
%% \textbf{kind syntax} \\
%% \kappa ::= &~ \kappa -> \kappa' & \text{arrow kind} \\
%%          | &~ *                 & \text{star kind}   \\
%% \end{align*}
%% \[ \textbf{kinding rules} \quad \framebox{$ \Delta |- F:\kappa $} \]\vspace*{-1em}
%% \begin{align*}
%% & \inference[\sc TVar]{X^\kappa \in \Delta}{\Delta |- X:\kappa} \\
%% & \inference[\sc TArr]{\Delta |- A:* & \Delta |- B:*}{\Delta |- A -> B:*} \\
%% & \inference[\sc TAll]{\Delta,X^\kappa |- B:*}{\Delta |- \forall X^\kappa.B:*} \\
%% & \inference[\sc TLam]{\Delta,X^\kappa |- F:\kappa'}
%%                       {\Delta |- \l X^\kappa.F:\kappa -> \kappa'} \\
%% & \inference[\sc TApp]{\Delta |- F : \kappa -> \kappa' & |- G : \kappa}
%%                       {\Delta |- F ~ G : \kappa'} \\
%% \end{align*}
%% \[ \textbf{typing rules} \quad \framebox{$ \Delta;\Gamma |- t : A $ } \]
%% \vspace*{-1em}
%% \begin{align*}
%% & \inference[\sc Var]{x:A \in \Gamma}{\Delta;\Gamma |- x:A} \\
%% & \inference[\sc Abs]{\Delta |- A:* & \Delta;\Gamma,x:A |- t : B}
%%                      {\Delta;\Gamma |- \l x   .t : A -> B} \\
%% & \inference[\sc App]{\Delta;\Gamma |- t : A -> B & \Delta;\Gamma |- s : A}
%%                      {\Delta;\Gamma |- t~s : B} \\
%% & \inference[\sc TyAbs]{\Delta,X^\kappa;\Gamma |- t : B}
%%                        {\Delta;\Gamma |- t : \forall X^\kappa.B} \\
%% & \inference[\sc TyApp]{\Delta;\Gamma |- t : \forall X^\kappa.B & \Delta |- G:\kappa}
%%                        {\Delta;\Gamma |- t : B[G/X]} \\
%% & \inference[\sc Conv]{\Delta;\Gamma |- t : A & \Delta |- A = A' : *}
%%                       {\Delta;\Gamma |- t : A'}
%% \end{align*}
%% \end{minipage}
%% \begin{minipage}{.46\textwidth}
%%         \begin{center}Curry-Curry-style\end{center}
%% \def\baselinestretch{0}
%% \small
%% \begin{align*}
%% \textbf{term syntax} \\
%% t,s ::= &~ x           \\
%%       | &~ \l x    . t \\
%%       | &~ t ~ s       \\
%% \textbf{type syntax} \\
%% F,G,A,B ::= &~ X                  \\
%%           | &~ A -> B             \\   
%%           | &~ \forall X.B \\
%%           | &~ \l X.F      \\
%%           | &~ F ~ G              \\
%% \textbf{kind syntax} \\
%% \kappa ::= &~ \kappa -> \kappa'  \\
%%          | &~ *                  \\
%% \end{align*}
%% \[ \textbf{kinding rules} \quad \framebox{$ \Delta |- F:\kappa $} \]\vspace*{-1em}
%% \begin{align*}
%% & \inference[\sc TVar]{X^\kappa \in \Delta}{\Delta |- X:\kappa} \\
%% & \inference[\sc TArr]{\Delta |- A:* & \Delta |- B:*}{\Delta |- A -> B:*} \\
%% & \inference[\sc TAll]{\Delta,X^\kappa |- B:*}{\Delta |- \forall X.B:*} \\
%% & \inference[\sc TLam]{\Delta,X^\kappa |- F:\kappa'}
%%                       {\Delta |- \l X.F:\kappa -> \kappa'} \\
%% & \inference[\sc TApp]{\Delta |- F : \kappa -> \kappa' & |- G : \kappa}
%%                       {\Delta |- F ~ G : \kappa'} \\
%% \end{align*}
%% \[ \textbf{typing rules} \quad \framebox{$ \Delta;\Gamma |- t : A $ } \]
%% \vspace*{-1em}
%% \begin{align*}
%% & \inference[\sc Var]{x:A \in \Gamma}{\Delta;\Gamma |- x:A} \\
%% & \inference[\sc Abs]{\Delta |- A:* & \Delta;\Gamma,x:A |- t : B}
%%                      {\Delta;\Gamma |- \l x   .t : A -> B} \\
%% & \inference[\sc App]{\Delta;\Gamma |- t : A -> B & \Delta;\Gamma |- s : A}
%%                      {\Delta;\Gamma |- t~s : B} \\
%% & \inference[\sc TyAbs]{\Delta,X^\kappa;\Gamma |- t : B}
%%                        {\Delta;\Gamma |- t : \forall X.B} \\
%% & \inference[\sc TyApp]{\Delta,X^\kappa;\Gamma |- t : B & \Delta |- G:\kappa}
%%                        {\Delta;\Gamma |- t : B[G/X]} \\
%% & \inference[\sc Conv]{\Delta;\Gamma |- t : A & \Delta |- A = A' : *}
%%                       {\Delta;\Gamma |- t : A'}
%% \end{align*}
%% \end{minipage}
%% ~\\
%% \caption{System \Fw\ in Curry-Church-style and Curry-Curry-style}
%% \label{fig:fw2}
%% \end{singlespace}
%% \end{figure}

\begin{figure}
\paragraph{Reduction rules for the Church-style System \Fw}
\begin{align*}
& \inference[\sc RedBeta]{}{(\l(x:A).t)~s --> t[s/x]}
&&\inference[\sc RedTy]{}{(\L X   .t)[A] --> t[A/X]} \\
& \inference[\sc RedAbs]{t --> t'}{\l x   .t --> \l x   .t'}
&&\inference[\sc RedTyAbs]{t --> t'}{\L X^\kappa   .t --> \L X^\kappa   .t'} \\
& \inference[\sc RedApp1]{t --> t'}{t~s --> t'~s}
&&\inference[\sc RedTyApp]{t --> t'}{t[A] --> t'[A]} \\
& \inference[\sc RedApp2]{s --> s'}{t~s --> t~s'}
\end{align*}
\paragraph{Reduction rules for the Curry-style System \Fw}
\begin{align*}
& \inference[\sc RedBeta]{}{(\l x   .t)~s --> t[s/x]} \\
& \inference[\sc RedAbs]{t --> t'}{\l x   .t --> \l x   .t'} \\
& \inference[\sc RedApp1]{t --> t'}{t~s --> t'~s} \\
& \inference[\sc RedApp2]{s --> s'}{t~s --> t~s'}
\end{align*}
\caption{Reduction rules for System \Fw}
\label{fig:redfw}
\end{figure}

\begin{figure}
\begin{align*}
& \inference[\sc EqTBeta]
        {\Delta,X^\kappa |- F : \kappa -> \kappa' & \Delta |- G : \kappa}
        {\Delta |- (\l X^\kappa.F)\;G = F[G/X] : \kappa'} \\
& \inference[\sc EqTVar]{X^\kappa \in \Delta}{\Delta |- X = X : \kappa} \\
& \inference[\sc EqTArr]{\Delta |- A=A':* & \Delta |- B=B':*}
                        {\Delta |- A -> B=A' -> B':*} \\
& \inference[\sc EqTAll]{\Delta,X^\kappa |- B=B':*}
                        {\Delta |- \forall X^\kappa.B=B':*} \\
& \inference[\sc EqTLam]
        {\Delta,X^\kappa |- F=F':\kappa'}
        {\Delta |- \l X^\kappa.F=\l X^\kappa.F':\kappa -> \kappa'} \\
& \inference[\sc EqTApp]
        {\Delta |- F=F' : \kappa -> \kappa' & \Delta |- G=G' : \kappa}
        {\Delta |- F ~ G = F' ~ G' : \kappa'} \\
& \inference[\sc EqTTrans]
        {\Delta |- F=F' : \kappa & \Delta |- F'=F'' : \kappa}
        {\Delta |- F=F'' : \kappa'}
\end{align*}
\caption{Type constructor equality rules for System \Fw}
\label{fig:eqtyfw}
\end{figure}

%% \paragraph{From Curry-Church-style to Curry-Curry-style.}
%% It is also possible to have a version of \Fw\ where the type syntax is also in Curry style.
%% That is, the forall type ($\forall X.B$) and the lambda type ($\l X.B$)
%% do not have kind annotations. We call this version of \Fw, where both terms
%% and types are unannotated, the Curry-Curry-style \Fw.
%% In Figure \ref{fig:fw2}, the Curry-Curry-style \Fw\ (right) is laid out
%% side-by-side to the Curry-Church-style \Fw\ (left).
%% 
%% Since we changed the type syntax of forall types and lambda types in
%% the Curry-Curry-style \Fw\ (\ie, removed the kind annotations from
%% the type constructor syntax), we need to adjust the kinding rules
%% involving forall types and lambda types. The rules we need to adjust are
%% the kinding rules \rulename{TAll} and \rulename{TLam}, and
%% the typing rules \rulename{TyAbs} and \rulename{TyApp}.
%% 
%% For the kinding rules, \rulename{TAll} and \rulename{TLam}, we simply need to
%% drop the kind annotations appearing in the forall type and
%% the lambda type in each rule. In Figure \ref{fig:fw2}, you can see that
%% that the difference between the left (Curry-Church-style) and
%% right (Curry-Curry-style) is the mssing kind annotations in these two rules.
%% 
%% How should we adjust the typing rules \rulename{TyAbs} and \rulename{TyApp}
%% for the Curry-Curry-style \Fw? A naive approach might be to adjust
%% the kind annotations (just as we did for the kinding rules) to
%% the changes below:
%% \begin{align*}
%% & \inference[\sc TyAbs]{\Delta,X^\kappa;\Gamma |- t : B}
%%                        {\Delta;\Gamma |- t : \forall X.B}
%% & \inference[\sc TyApp]{\Delta;\Gamma |- t : \forall X.B & \Delta |- G:\kappa}
%%                        {\Delta;\Gamma |- t : B[G/X]}
%% \end{align*}
%% The \rulename{TyAbs} rule above is fine. However, the \rulename{TyApp} rule
%% above is problematic because it fails to require that both $X$ and
%% $G$ have kind $\kappa$. To ensure that $X$ is of kind $\kappa$, we need to
%% adjust the \rulename{TyApp} rule as follows:
%% \begin{align*}
%% & \phantom{ \inference[\sc TyAbs]{\Delta,X^\kappa;\Gamma |- t : B}
%%                                  {\Delta;\Gamma |- t : \forall X.B} }
%% & \inference[\sc TyApp]{\Delta,X^\kappa;\Gamma |- t : B & \Delta |- G:\kappa}
%%                         {\Delta;\Gamma |- t : B[G/X]}
%% \end{align*}
%% Note, the first premise ($\Delta,X^\kappa;\Gamma |- t : B$) of
%% the \rulename{TyApp} rule is exactly the same as the premise of
%% the \rulename{TyAbs} rule.
%% 
%% \paragraph{Church-Curry-style \Fw}
%% Although not illustrated in Figures \ref{fig:fw} and \ref{fig:fw2},
%% we can imagine yet another version of \Fw\ with annotated terms
%% and unannotated types -- namely, the Church-Curry-style \Fw.
%% Since we make no use of this style in the thesis, we leave the details
%% as an exercise for the reader.


\subsection{Encodings of datatypes in System \Fw}
\label{sec:fw:data}
In System \Fw\ we can encode all the datatypes encodable in System \F\ (see
\S\ref{sec:f:data}) and more. In addition to the obvious type constructors,
one can encode indexed types, nested types, and even fixpoint operators
over type constructors.
\begin{itemize}

\item \emph{Type constructors} for polymorphic datatypes
can be encoded using lambda types that abstract over types.


\item \emph{Non-regular datatypes}, or \emph{nested datatypes}, can be encoded
using forall types that are polymorphic over type constructors.

\item With higher-kinded type constructors, we can even encode
the recursive type operator $\mu$ in System \Fw\ by abstracting
over non-star type constructors.
\end{itemize}

This additional expressive power comes from two different uses of
type-level constructs other than types of kind $*$.
\begin{itemize}

\item  \emph{Higher-kinded polymorphism} is the ability to
	universally quantify over both type constructors
	of arbitrary kinds.

\item 
\emph{Type constructors of higher kinds} or \emph{higher-kinded
type constructors} are type constructors that expect type constructors
as their arguments.
\end{itemize}

In fact we combine these two to define 
a family of kind-indexed recursive type operators $\mu_\kappa$ using both
higher-kinded type constructors and higher-kinded polymorphism.



\paragraph{Type constructors for polymorphic datatypes} expect
other types as arguments to produce a datatype. We can encode these 
type constructors in System \Fw. For example, the shorthand notations
(or, type synonyms) in \S\ref{sec:f:data}, such as $(\times)$ for pair types
and $(+)$ for sum types, can be encoded as as follows:\footnote{Here,
        I used a Haskell-ish notation of turning a infix binary operator
        into a prefix binary operator by surrounding the operator in parenthesis
        (\eg, $(+)\;X_1\,X_2 = X_1 + X_2$). I also annotated the kinds of
        the type constructors after the colon (:).}
\begin{align*}
(\times) &= \l X_1^{*}.\l X_2^{*}.(X_1 -> X_2 -> X) -> X &:~ * -> * -> * \\
     (+) &= \l X_1^{*}.\l X_2^{*}.(X_1 -> X) -> (X_2 -> X) -> X &:~ * -> * -> *
\end{align*}
Type constructors for polymorphic recursive datatypes are encodable as well.
For instance, we can encode the constructor \textit{List}
for the polymorphic list datatype:
\begin{align*}
        \textit{List} &= \l X_a^{*}.\forall X^{*}.(X_a -> X -> X) -> X -> X
        &:~ * -> *
\end{align*}
In System \F, type constructors, such as $(\times)$, $(+)$, and
\textit{List} are meta-level concepts (or, shorthand notations, macros)
that cannot be encoded within the type system of System \F.
In System \Fw, these datatype constructors are encodable as type constructors,
which are ordinary constructs of System \Fw.

\paragraph{Higher-kinded datatype constructors} that expect
not only types but also type constructors of arbitrary kinds as arguments
are encodable in System \Fw\ as well. For example, we can encode
\textit{Flip}, which flips the order of the first and second arguments of
a binary type constructor (\ie, $(\textit{Flip}\;F)\,A_1\,A_2 = F\,A_2\,A_1$),
and \textit{Comp}, which composes two unary type constructors
(\ie, $(\textit{Comp}\;F_1\,F_2)\,A = F_1\,(F_2\,A)$), as follows:
\begin{align*}
\textit{Flip} &= \l X_{\!f}^{*-> *-> *}.\l X_1^{*}.\l X_2^{*}.X_{\!f}\,X_2\;X_1
                     &:\;& (* -> * -> *) -> * -> * -> * \\
\textit{Compose} &= \l X_{\!f}^{*-> *}.\l X_g^{*-> *}.\l X^{*}.X_{\!f}\,(X_g\,X)
                     &:\;& (* -> *) -> (* -> *) -> * -> *
\end{align*}

\paragraph{Higher-kinded polymorphism} is the ability universally quantify
over type constructors as well as types. That is, we can have
$\forall X^\kappa.B$ where $\kappa$ is not the star kind.
We can encode \emph{non-regular (recursive) datatypes} in System \Fw\ using
higher-kinded polymorphism.

We mentioned that we can encode \emph{regular (recursive) datatypes}
in Systerm \F\ (\S\ref{sec:f:data}), but have not discussed
what regular datatypes are. A representative example of a regular datatype
is the polymorphic list type ($\forall X_a.\textit{List}\,X_a$).
We say that the polymorphic list type is regular since its recursive
component, the tail, has exactly the same type. That is, for any
non-empty list of type $\textit{List}\,A$, its tail must be of type $\textit{List}\,A$.
Many other well-known recursive datatypes are also regular (\eg, binary trees).

But, one can imagine a non-regular twist to the regular polymorphic list type
by insisting the recursive components (\ie, tails) have different
type arguments from the list they are part of. For instance, we may insist
that a list-like datatype of type ($\textit{Powl}\;A$) must have its tail be
of type $(\textit{Powl}\,(A\times A))$. That is, if the first element is
an integer (\eg, $1$), then the second element must be a pair of integers
(\eg, $(2,3)$), and the third elment must be a pair of pair of integers
(\eg, $((4,5),(6,7))$), and so on. We can depict an example of this list-like
datatype with three elements as: $[1,\,(2,3),\,((4,5),(6,7))]$.
This is a representative example of a non-regular datatype called powerlists.
Such datatypes are also called \emph{nested datatypes} %% TODO cite
since the the type constructor is applied to ever increasing complex arguments
(here they are nested, but one can imagine even richer kinds of complexity)
as we step further inside the recursive components.

We can encode the type constructor \textit{Powl} for powerlists using
higher-kinded polymorphism of System \Fw, as follows
(\cf\ encoding of \textit{List}):
\begin{align*}
\textit{Powl} &= \l X_a^{*}.\forall X^{* -> *}&.&
        (X_a -> X(X_a\times X_a) & -> & X\,X_a) & -> & X\,X_a & -> & X\,X_a \\
\textit{List} &= \l X_a^{*}.\forall X^{*}&.&
        (X_a -> X & -> & X) & -> & X & -> & X
\end{align*}
Unlike the encoding of \textit{List}, where $X$ is polymorphic over types
of kind $*$, the universally quantified variable $X$ in the encoding of
\textit{Powl} is polymorphic over constructors of kind $* -> *$.
Intuitively, $X$ in the list encoding corresponds to $\textit{List}\;X_a$
(\ie, the type constructor \textit{List} applied to its uniform argument $X_a$),
and, $X$ in the powerlist encoding corresponds to \textit{Powl} without
being applied to its argument so that it may be applied to a non-regular
argument (\eg, $X(X_a\times X_a)$). See \S\ref{mendler_nonreg} for more
examples and discussions on non-regular datatypes.

\paragraph{The recursive type operator $\mu$} builds a recursive type
($\mu F$) from a non-recursive base structure ($F:* -> *$).
Theories on recursive datatypes are often formulated in terms of
the recursive type operator $\mu$, which satisfies the property
that $\mu F = F (\mu F)$ for any $F: * -> *$. A recursive datatype ($\mu F$)
is built from its base structure ($F$) by applying the recursive operator.
For example, the natural number datatype can be built from the base structure
$F = \l X_r^{*}.X_r + \textit{Unit}$. Intuitively, we can understand this
base structure as a specification for natural numbers: a natural number is
either a successor of a recursive object ($X_r$)
or zero encoded as the unit object (\textit{Unit}).
From this base structure, we can define
$\textit{Nat} = \mu(\l X_r^{*}.X_r + \textit{Unit})$.
Let us write down the desired property of $\mu$ for $\textit{Nat}$.
\begin{align*}
\mu(\l X_r^{*}.X_r + \textit{Unit}) &=
(\l X_r^{*}.X_r + \textit{Unit})(\mu(\l X_r^{*}.X_r + \textit{Unit})) \\
\textit{Nat} &= (\l X_r^{*}.X_r + \textit{Unit})\,\textit{Nat} \\
\textit{Nat} &= \textit{Nat}\, + \textit{Unit}
\end{align*}
Note, the simplified last equation looks very similar to
the recursive datatype definitions for unary natural numbers
in functional languages, such as Haskell: \[ \qquad\qquad
\textbf{data}~\textit{Nat} = \texttt{Succ}~\textit{Nat}\,\mid\,\texttt{Zero} \]
See Chapter \ref{ch:mendler}
for more of the Haskell examples on recursive datatypes and $\mu$.

Although recursive datatypes are encodable in System \F\ (\S\ref{sec:f:data}),
extensions of System \F\ with $\mu$ have been studied %% TODO cite
since one can reason about the properties of recursive datatypes more
uniformly by factoring out the recursion at the type level as
the fixpoint $\mu$. In System \Fw, we can encode $\mu$ using
higher-kinded type constructors and higher-kinded polymorphism as follows:
\[
\mu =
 \l X_{\!f}^{* -> *}.
 \forall X'^{*}.(\forall X_r^{*}.(X_r -> X') -> X_{\!f}\,X_r -> X') -> X'
 ~:\; (* -> *) -> *
\]
Let us intuitively derive above the encoding of $\mu$ starting from
the impredicative encoding of natural numbers:
\begin{align*}
\textit{Nat}
        &= \forall X^{*} . (X -> X) -> X -> X \\
        &\cong \forall X^{*} . (X -> X) -> (\textit{Unit} -> X) -> X 
                &(\because \textit{Unit} -> X \cong X) \\
        &\cong \mu(\l X_r^{*}.\,X_r + \textit{Unit})
                & (\text{to show})
\end{align*}
We want to show that the impredicative encoding of natural numbers is
equivalent to the natural number type defined using $\mu$. We need to turn
the impredicative encoding of natural numbers into a non-recursive
base structure by abstract away the recursive component, which is
the underlined part below. That is, we replace the underlined $X$
with a new variable $X_r$:
\begin{align*}
\forall X^{*} . (\underline{X}\; -> X) -> (\textit{Unit} -> X) -> X \\
\forall X^{*} . (X_r -> X) -> (\textit{Unit} -> X) -> X
\end{align*}
Recall that
$X_r +\textit{Unit} = \forall X^{*} . (X_r -> X) -> (\textit{Unit} -> X) -> X$.
Recall that the idea behind the impredicative encoding is that we can eliminate
an object of the datatype into an arbitrary result type $X$. If we are to
encode datatypes constructed by $\mu$, we apply this idea of
impredicative encoding in two layers: for the base structure and for $\mu$.
We already know how to encode the base structure: with the encoding above,
we can eliminate to an arbitrary result type $X$. For $\mu$, we introduce
yet another variable $X'$ so that we can eliminate to an arbitrary result
type $X'$. Thus, the encoding for natural number type constructed using $\mu$
would be of the following form:
\[ \forall X'^{*}.(\;\dots\;\dots\;\dots\;\dots\;\dots (X_r + \textit{Unit}) -> X') -> X' \]
Since the recursive type contains the base structure, we would be able to
eliminate the recursive type, given that we know how to eliminate
the base structure $((X_r + \textit{Unit}) -> X')$.
However, this is not yet complete because we do not know how to eliminate $X_r$.
So, we require that we should also know how to eliminate $X_r$, as follows:
\[ \forall X'^{*}.
        (\forall X_r^{*}.(X_r -> X') -> (X_r + \textit{Unit}) -> X') -> X' \]
We can derive the encoding for $\mu$ (repeated below)
so that $\mu(\l X_r^{*}.X_r + \textit{Unit})$ is equivalent to above.
\[
\mu =
 \l X_{\!f}^{* -> *}.
 \forall X'^{*}.(\forall X_r^{*}.(X_r -> X') -> X_{\!f}\,X_r -> X') -> X'
 ~:\; (* -> *) -> *
\]
Note that $X_r$ is also universally quantified
in $(\forall X_r^{*}.(X_r -> X') -> X_{\!f}\,X_r -> X')$
locally.
See Chapter \ref{ch:mendler} %% TODO update the fwd ref to a section later
for an intuitive explanation for why $X_r$ should be universally quantified.

The (data) constructor for the recursive type operator $\mu$ is called $\In$
and the eliminator is called $\MIt$. The encodings of $\In$ and $\MIt$ as
Curry-style terms are as follows:
\[ \In = \l x_r. \l x_\varphi.x_\varphi\,(\MIt~x_\varphi)\,x_r
\qquad\qquad \MIt = \l x_\varphi.\l x_r.x_r\,x_\varphi \]
These ($\mu$, $\In$, and $\MIt$) are, in fact, encodings for
Mendler-style iteration, which will be discussed in \S\ref{sec:proof}.

\paragraph{A kind-indexed family of recursive type operators $\mu_\kappa$:}
The recursive type operator $\mu : (* -> *) -> *$ discussed so far can only
construct (non-mutually recursive) regular datatypes. For example,
\begin{align*}
\textit{Nat} &= \mu(\l X^{*}.X + \textit{Unit}) \\
\textit{List} &= \l X_a^{*}.\mu(\l X^{*}.(X_a\times X) + \textit{Unit})
\end{align*}
More generally, there is a family of recursive type operators
$\mu_\kappa : (\kappa -> \kappa) -> \kappa$ for each kind $\kappa$.
The $\mu$, which we discussed above, is $\mu_{*} : (* -> *) -> *$.
We can construct \textit{Powl}, which is a non-regular datatype, using another
recursive typer operator $\mu_{* -> *} : ((*-> *) -> (*-> *)) -> (*-> *) $
as follows (\cf\ \textit{List}).
\begin{align*}
\textit{Powl} &= \mu_{* -> *}(\l X^{* -> *}.\l X_a^{*}.
                        (X_a\times X(X_a\times X_a)) + \textit{Unit}) \\
\textit{List} &= \l X_a^{*}.\mu_{*}(\l X^{*}.(X_a\times X) + \textit{Unit})
\end{align*}
Note the difference where $X_a$ is bound in the definitions of \textit{Powl}
and \textit{List}. The encodings of $\mu_{*}$ and $\mu_{*-> *}$ in System \Fw\ 
are shown below:
\begin{align*}
\mu_{*} &=
 \l X_{\!f}^{* -> *}.\forall X'^{*}.
 (\forall X_r^{*}.(X_r -> X') -> (X_{\!f}\,X_r -> X')) -> X' \\
\mu_{* -> *} &=
 \l X_{\!f}^{(*-> *) -> (*-> *)}.\l X_a^{*}.\\&\qquad\quad \forall X'^{*-> *}.
 \big(\forall X_r^{*-> *}.
        (\forall X_a^{*}.X_r\,X_a -> X'\,X_a) -> \\&\qquad\qquad\qquad\qquad\qquad~
        (\forall X_a^{*}.X_{\!f}\,X_r\,X_a -> X'\,X_a)\big) -> X'\,X_a
\end{align*}
The genreal form for the encoding of $\mu_\kappa$
is as follows:
\begin{align*}
\mu_{\kappa} &=
 \l X_{\!f}^{\kappa -> \kappa}.\l \vec{X}^{\vec{\kappa}}.
 \forall X'^{*-> *}.
 \big(\forall X_r^{\kappa -> \kappa}.
 (\forall \vec{X}^{\vec{\kappa}}.X_r\,\vec{X} -> X'\,\vec{X}) -> \\
 &\qquad\qquad\qquad\qquad\qquad\qquad\qquad\quad
 (\forall \vec{X}^{\vec{\kappa}}.X_{\!f}\,X_r\,\vec{X} -> X'\,\vec{X})
 \big) -> X'\,\vec{X}
\end{align*}
where $\vec{X}$ denotes a sequence of $n$ variables
such that $n=0$ when $\kappa = *$, otherwise, $n = |\vec{\kappa}|$ when
$\kappa = \vec{\kappa} -> * = \kappa_1 -> \cdots -> \kappa_n -> *$.\footnote{
        $\kappa$ always end up with $*$ when it is an arrow kind
        since $->$ is right associative by convention.}
That is, we can simply erase all the $\l \vec{X}^{\vec{\kappa}}$,
$\forall \vec{X}^{\vec{\kappa}}$, and $\vec{X}$ from above when
$\kappa = *$, otherwise, $\l \vec{X}^{\vec{\kappa}}$ stands for
$\l X_1^{\kappa_1}.\cdots.\l X_n^{\kappa_n}$,
$\forall \vec{X}^{\vec{\kappa}}$ stands for
$\forall X_1^{\kappa_1}.\cdots.\forall X_n^{\kappa_n}$,
and $F\,\vec{X}$ stands for $F\,X_1\cdots X_n$
when $\kappa = \vec{\kappa} -> * = \kappa_1 -> \cdots -> \kappa_n -> *$.

The (data) constructor for the recursive type operator $\mu_\kappa$ is
called $\In_\kappa$ and the eliminator is called $\MIt_\kappa$.
The encodings of $\In_\kappa$ and $\MIt_\kappa$ as Curry-style terms are
exactly the same as for $\In$ and $\MIt$ for the star kind:
\[ \In_\kappa = \l x_r. \l x_\varphi.x_\varphi\,(\MIt~x_\varphi)\,x_r
\qquad\qquad \MIt_\kappa = \l x_\varphi.\l x_r.x_r\,x_\varphi \]
These ($\mu_\kappa$, $\In_\kappa$, and $\MIt_\kappa$) are, in fact,
encodings for Mendler-style iteration in \Fw, which will discussed in
\S\ref{sec:fi:data}.


\subsection{Strong normalization}\label{sec:fw:srsn}
Here, we will take the \emph{subject reduction} (Theorem\;\ref{thm:srfw})
(\aka\ \emph{type preservation}) for granted,\footnote{
	The proof for subject reduction of System~\Fw\ is similar to
	the proof for the subject reduction of System~\F.}
and focus our discussion on the \emph{strong normalization}
of System~\Fw.

\begin{theorem}[subject reduction]\label{thm:srfw}
$\inference{\Delta;\Gamma |- t : A  & t --> t'}{\Delta;\Gamma |- t' : A}$
\end{theorem}

\begin{figure}
\begin{singlespace}
\begin{description}
\item[Interpretation of kinds] as pointwise generalization of $\SAT$
        \[ [| \kappa |] = \SAT_\kappa \]
\item[Interpretation of type constructors]
        as function spaces over saturated sets of normalizing terms
        whose free type variables are substituted according to
        the given type constructor valuation ($\xi$):
\begin{align*}
[| X |]_\xi      &= \xi(X) \\ 
[| A -> B |]_\xi &= [|A|]_\xi -> [|B|]_\xi \\
[| \forall X^\kappa . B |]_\xi
        &= \bigcap_{\mathcal{F}\in[|\kappa|]} [|B|]_{\xi[X\mapsto\mathcal{F}]}
                \qquad\qquad\qquad (X\notin\dom(\xi)) \\
[| \l X^\kappa . F |]_\xi
        &= \bbl(\mathcal{G} \in [|\kappa|]) . [|F|]_{\xi[X\mapsto\mathcal{G}]}
                \qquad\quad~ (X\notin\dom(\xi)) \\
[| F \; G |]_\xi &= [|F|]_\xi ( [|G|]_\xi )
\end{align*}
\item[Interpretation of kinding and typing contexts]
        as sets of type constructor valuations and term valuations
        ($\xi$ and $\rho$):
\begin{align*}
[| \Delta        |] &= \{ \xi \in \dom(\Delta) -> \bigcup_{\kappa} [|\kappa|] \mid \xi(x)\in[|\Delta(x)|] ~\text{for all}~x\in\dom(\Delta) \} \\
[| \Delta;\Gamma |] &= \{ \xi;\rho \mid \xi\in[|\Delta|], \rho\in[|\Gamma|]_\xi \} \\
[| \Gamma        |]_\xi\ &= \{ \rho \in \dom(\Gamma) -> \SN \mid \rho(x)=[|\Gamma(x)|]_\xi ~\text{for all}~x\in\dom(\Gamma) \}
\end{align*}
\item[Interpretation of terms]
        as terms themselves whose free variables are substituted according to
        the given pair of type constructor and term valuations
        ($\xi$;$\rho$):
\begin{align*}
[| x      |]_{\xi;\rho} &= \rho(x) \\
[| \l x.t |]_{\xi;\rho} &= \l x . [|t|]_{\xi;\rho} \qquad (x\notin\dom(\rho)) \\
[| t ~ s  |]_{\xi;\rho} &= [| t |]_{\xi;\rho} ~ [| s |]_{\xi;\rho}
\end{align*}
\end{description}
\caption[Interpretation of System \Fw\ for proving strong normalization]
        {Interpretation of type constructors, kinding and typing contexts,
                and terms of System \Fw\ for the proof of strong normalization}
\label{fig:interpFw}
\end{singlespace}
\end{figure}
To prove strong normalization of System \F, we use the same proof strategy
as in the proof of strong normalization of System \F\ (\S\ref{sec:f:srsn}).
That is, we interpret types as saturated sets of normalizing terms as we did
for System \F. However, we need to generalize the interpretation of types to
the interpretation of type constructors. In the strong normalization proof of
System \F, we had a complete lattice $(\SAT,\subseteq)$. We generalize from
$(\SAT,\subseteq)$, which is for kind $*$ only, to
$(\SAT_\kappa,\sqsubseteq_\kappa)$ for an arbitrary kind $\kappa$,
as follows:
\begin{itemize}
\item The set $\SAT_\kappa$ is a generalization of $\SAT$ such that
\begin{align*}
        \SAT_{*} &= \SAT \\
        \SAT_{\kappa -> \kappa'} &= \SAT_\kappa -> \SAT_{\kappa'}
        \qquad \text{(\ie, functions from $\SAT_\kappa$ to $\SAT_\kappa'$)}.
\end{align*}

\item The relation $\sqsubseteq_\kappa$ is
        a pointwise generalization of $\subseteq$ such that
\begin{align*}
\mathcal{A} \sqsubseteq_{*} \mathcal{A'} &= \mathcal{A} \subseteq \mathcal{A'}\\
\mathcal{F} \sqsubseteq_{\kappa -> \kappa'} \mathcal{F'} &=
        \mathcal{F}(\mathcal{G}) \sqsubseteq_{\kappa'} \mathcal{F'}(\mathcal{G})
        ~\text{for all}~\mathcal{G}\in\SAT_\kappa
\end{align*}
\end{itemize}
It is easy to see that $(\SAT_\kappa,\sqsubseteq_\kappa)$ forms
a complete lattice by induction on $\kappa$. For kind $\star$,
it is obvious since we already know that $(\SAT,\subseteq)$ forms
a complete lattice. For an arrow kind $\kappa -> \kappa'$, we know that
$(\SAT_{\kappa'},\sqsubseteq_{\kappa})$ forms a complete lattice by induction.
It is easy to see that for every two element $\mathcal{F}_1, \mathcal{F}_2
\in \SAT{\kappa'},\sqsubseteq_{\kappa}$ there exist a greatest lower bound
($\mathcal{F}_1 \wedge \mathcal{F}_2$) and a greatest upper bound 
($\mathcal{F}_1 \vee \mathcal{F}_2$), defined pointwisely as follows:
\begin{align*}
(\mathcal{F}_1 \wedge \mathcal{F}_2)(\mathcal{G}) &=
   \mathcal{F}_1(\mathcal{G}) \wedge \mathcal{F}_2(\mathcal{G})
        ~\text{for all}~\mathcal{G}\in\SAT_\kappa \\
(\mathcal{F}_1 \vee \mathcal{F}_2)(\mathcal{G}) &=
   \mathcal{F}_1(\mathcal{G}) \vee \mathcal{F}_2(\mathcal{G})
        ~\text{for all}~\mathcal{G}\in\SAT_\kappa
\end{align*}
The top and bottom elements at an arrow kind $\bot_{\kappa -> \kappa'}$
are also defined pointwisely. Let $\bot_{\kappa -> \kappa'}$ be
the constant function that that always return $\bot_{\kappa'}$
(the bottom element at $\kappa'$, and, let $\top_{\kappa -> \kappa'}$ be
the constant function that that always return $\top_{\kappa'}$
(the top element of the lattice at $\kappa'$). It is easy to see that
$\bot_{\kappa -> \kappa'}$ and $\top_{\kappa -> \kappa'}$
are the bottom and top elements at kind $\kappa -> \kappa'$
by definition of $\sqsubseteq_{\kappa -> \kappa'}$.

Then, we can give interpretation of kind $\kappa$ as $\SAT_\kappa$.
That is, $[| \kappa |] = \SAT_\kappa$. An interpretation of a type constructor
of kind $\kappa$ should be a member of $[| \kappa |]$, \ie, $\SAT_\kappa$.
The interpretation of kinds, type constructors, contexts, and
terms of System \Fw\ are illustrated in Figure \ref{fig:interpFw}. 

We use the Curry-style System \Fw\ to present the strong normalization
proof. It is more convenient to interpret terms in Curry style since
the Curry-style terms syntax is simpler than the Church-style term syntax.
It is more convenient to interpret type constructors in Curry style since
the kind annotation makes it clear how to interpret the bound type variable $X$
in forall types and lambda types (\ie, for $X^\kappa$ choose from $[|\kappa|]$).

The proof of strong normalization amounts to proving the following theorem:
\begin{theorem}[soundness of typing]
$ \inference{\Delta;\Gamma|- t:A & \xi;\rho \in [|\Delta;\Gamma|]}
            {[|t|]_{\xi;\rho} \in [|A|]_\xi} $
\end{theorem}
\begin{proof}
We prove by induction on the typing derivation ($\Delta;\Gamma |- t:A$).

The cases for \rulename{Var}, \rulename{Abs}, and \rulename{App} are pretty
much the same as the strong normalization proof for System \F.
The cases for \rulename{TyAbs} and \rulename{TyApp} is almost the same
as the strong normalization proof for System \F, except that the type variable
can be of some kind $\kappa$ other than just the star kind.
We need to consider one more rule \rulename{Conv}, which is new in System \Fw.
Let us elaborate on the three cases of
\rulename{TyAbs} and \rulename{TyApp}, and \rulename{Conv}.

\paragraph{Case (\rulename{TyAbs})}
We need to show that
$ \inference{\Delta;\Gamma |- t : \forall X.B & \xi;\rho\in[|\Delta;\Gamma|]}
        {[|t|]_{\xi;\rho} \in [|\forall X^\kappa.B|]_\xi} $

By induction, we know that
\[ \inference{\Delta,X^\kappa;\Gamma |- t:B & \xi';\rho'\in[|\Delta,X;\Gamma|]}
        {[|t|]_{\xi';\rho'} \in [|B|]_{\xi'}} ~
        (X\notin\FV(\Gamma))
\]
Since this holds for all $\xi';\rho' \in [|\Delta,X^\kappa;\Gamma|]$ where
$X\notin\FV(\Gamma)$, it also holds for particular subset such that
$\xi' = \xi[X\mapsto\mathcal{F}]$ and $\rho'=\rho$ for all $\mathcal{F}\in[|\kappa|]$.
That is,
\[ [|t|]_{\xi[X\mapsto\mathcal{F}];\rho} \in [|B|]_{\xi[X\mapsto\mathcal{F}]}
        \quad \text{for all}~\mathcal{F}\in[|\kappa|] \]
From $X\notin\FV(\Gamma)$, we know that
$[|t|]_{\xi[X\mapsto\mathcal{F}];\rho} = [|t|]_{\xi;\rho}$
because $\rho$ is independent of what $X$ maps to.
So, we know that
\[ [|t|]_{\xi;\rho} \in [|B|]_{\xi[X\mapsto\mathcal{F}]}
        \quad \text{for all}~\mathcal{F}\in[|\kappa|] \]
By set theoretic definition, this is exactly what we wanted to show:
\[ [|t|]_{\xi;\rho} \in
        \bigcap_{\mathcal{F}\in[|\kappa|]} [|B|]_{\xi[X\mapsto\mathcal{F}]}
        = [|\forall X^\kappa.B|]_\xi
\]

\paragraph{Case (\rulename{TyApp})}
We need to show that
$ \inference{\Delta;\Gamma |- t : B[G/X] & \xi;\rho\in[|\Delta;\Gamma|]}
        {[|t|]_{\xi;\rho} \in [|B[G/X]|]_\xi} $.

By induction, we know that
$ \inference
        { \Delta;\Gamma |- t : \forall X^\kappa.B
        & \xi';\rho'\in[|\Delta;\Gamma|] }
        {[|t|]_{\xi';\rho'} \in [|\forall X^\kappa.B|]_{\xi'}} $.

Since this holds for all $\xi';\rho' \in [|\Delta,\Gamma|]$,
it also holds for $\xi'=\xi$ and $\rho'=\rho$. Then, we are done:
$ [|t|]_{\xi;\rho} \in [|\forall X^\kappa.B|]_{\xi}
        = \bigcap_{\mathcal{G}\in[|\kappa|]} [|B|]_{\xi[X\mapsto\mathcal{G}]}
        \subseteq [|B|]_{\xi[X\mapsto[|G|]_\xi]} = [|B[G/X]|]_\xi $.

\paragraph{Case (\rulename{Conv})}
We need to show that
$ \inference{\Delta;\Gamma |- t : A' & \xi;\rho\in[|\Delta;\Gamma|]}
        {[|t|]_{\xi;\rho} \in [|A'|]_\xi} $

By induction we know that 
$ \inference{\Delta;\Gamma |- t : A & \xi;\rho\in[|\Delta;\Gamma|]}
        {[|t|]_{\xi;\rho} \in [|A|]_\xi} $

If we can show that $[|A|]_\xi = [|A'|]_\xi$, we are done.

To show that $[|A|]_\xi = [|A'|]_\xi$,
we use the soundness of type constructor equality lemma
(Lemma \ref{lem:fw:soundtyeq}).
\end{proof}

\begin{corollary}[strong normalization]
        $\inference{\Delta;\Gamma |- t : A}{t \in \SN}$
\end{corollary}

\begin{lemma}[soundness of type equality] \label{lem:fw:soundtyeq}
$ \inference{\Delta |- F = F' : \kappa & \xi\in[|\Delta|]}
        {[|F|]_\xi = [|F'|]_\xi} $
\end{lemma}
\begin{proof}
The only interesting case is the \rulename{EqTBeta} rule.
The \rulename{EqTVar} is trivial and all other rules are handled by induction.
Let us elaborate on the \rulename{EqTBeta} case.

\paragraph{Case (\rulename{EqTBeta})} We need to show that
\[ \inference
        { \Delta |- (\l X^\kappa.F)\;G = F[G/X] : \kappa' & \xi\in[|\Delta|] }
        { [| (\l X^\kappa.F)\;G |]_\xi = [| F[G/X] |]_\xi }
\]

By applying the soundness of kinding lemma (Lemma \ref{lem:fw:soundki})
to the premises, we know that
\[ \inference
        {\Delta,X^\kappa |- F : \kappa -> \kappa' & \xi'\in[|\Delta,X^\kappa|]}
        {[|F|]_{\xi'} \in [|\kappa'|]}
\quad\text{and}\quad
   \inference{\Delta |- G : \kappa & \xi\in[|\Delta|]}{[|G|]_\xi \in [|\kappa|]}
\]

Since it should hold for arbitrary $\xi'$, it should also hold for
a particular $\xi'$ such that $\xi'=\xi[X\mapsto\mathcal{G}]$
for any $\mathcal{G} \in [|\kappa|]$. Therefore, we can rewrite
the left-hand side of the conclusion, which what we wanted to show,
into the right-hand side as follows:
\begin{align*}
[| (\l X^\kappa.F)\;G |]_\xi
&=[|(\l X^\kappa.F)|]_\xi ([|G|]_\xi) \\
&=(\bbl(\mathcal{G}\in[|\kappa|]).[|F|]_{\xi[X\mapsto\mathcal{G}]})([|G|]_\xi)\\
&=[|F|]_{\xi[X\mapsto[|G|]_\xi]} \\
&=[|F[G/X]|]_\xi
\end{align*}
\end{proof}

System \Fw\ has a richer kind structure than System \F, which only has one and
the only the star kind. So, the interpretation of type constructors would only
be well-defined when the type constructors are well-kinded. For example,
the interpretation of a type constructor application $[|F~G|]_\xi$
would only make sense when $[|F|]_\xi\in[|\kappa -> \kappa'|]$
and $[|G|]_\xi\in[|\kappa|]$ for some $\kappa$ and $\kappa'$.
The soundness of kinding lemma below states the property that
well-kinded type constructors indeed have well-defined interpretation.
\begin{lemma}[soundness of kinding]  \label{lem:fw:soundki}
$ \inference{\Delta |- F : \kappa & \xi\in[|\Delta|]}{[|F|]_\xi\in[|\kappa|]} $
\end{lemma}
\begin{proof}
We prove by induction on the kinding judgment.
\paragraph{Case (\rulename{TVar})}
Straightforward by definition of $[|\Delta|]$.

$[|X|]_\xi=\xi(X) \in [|\kappa|]$
since $\xi(X)\in[|\kappa|]$ for any $\xi\in[|\Delta|]$
when $X^\kappa \in [|\Delta|]$.

\paragraph{Case (\rulename{TArr})} By induction, straightforward.

\paragraph{Case (\rulename{TAll})}
We need to show that
$ \inference{\Delta |- \forall X^\kappa.B:* & \xi\in[|\Delta|]}
        {[|\forall X^\kappa.B|]_\xi\in[|*|]} $.

By induction, we know that
$ \inference{\Delta,X^\kappa |- B:* & \xi'\in[|\Delta,X^\kappa|]}
        {[|B|]_{\xi'} \in [|*|]} $.

Since it should hold for any $\xi'$, it also holds for
$\xi'=\xi[X\mapsto\mathcal{G}]$ for any $\mathcal{G}\in[|\kappa|]$.

Therefore,
$  [|\forall X^\kappa.B|]_\xi
 = \bigcap_{\mathcal{G}\in[|\kappa|]}[|B|]_{\xi[X\mapsto\mathcal{G}]}\in[|*|] $.

\paragraph{Case (\rulename{TLam})}
We need to show that
$ \inference{\Delta |- \l X^\kappa.B:* & \xi\in[|\Delta|]}
        {[|\forall X.B|]_\xi\in[|*|]} $.

By induction, we know that 
$ \inference{\Delta,X^\kappa |- F:\kappa' & \xi'\in[|\Delta,X^\kappa|]}
        {[|F|]_{\xi'} \in [|\kappa'|]} $.

Since it should hold for any $\xi$, it also holds for
$\xi'=\xi[X\mapsto\mathcal{G}]$ for any $\mathcal{G}\in[|\kappa|]$.

Therefore,
$  [|\l X^\kappa.F|]_\xi
 = \bbl(\mathcal{G}\in[|\kappa|]).[|F|]_{\xi[X\mapsto\mathcal{G}]}
        \in [|\kappa -> \kappa'|]$.

\paragraph{Case (\rulename{TApp})} By induction, straightforward.
\end{proof}

