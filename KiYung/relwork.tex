\chapter{Related work}\label{ch:relwork}
We introduce some more related work that have not been discussed
in the introduction or related work sections (\S\ref{sec:intro},
\S\ref{sec:related}) in the previous chapters.

\input{relwork_mcoit} %% sec:relwork:co

\input{relwork_mmult} %% sec:relwork:mult

\section{Mendler-style induction}
\label{sec:relwork:dep}
Dependently-typed version of primitive recursion is called induction.
We can formulate the Mendler-style induction over regular datatypes as follows.
\vspace*{-2em}
\begin{singlespace}
\[\begin{array}{ll}
\textbf{mind}_{*} \, :
& \!\!\forall (F:* -> *) (A: \mu_{*}f -> *). \\
& ~~ \big(\forall(r:*).\;(cast : r -> \mu_{*}F) \\
& ~\qquad\quad -> (call : (x:r) -> A\,(cast~x)) \\
& ~\qquad\quad -> (y: F\;r) -> a\,(\In_{*}(\textit{fmap}_{F}\;call\;y)) \big) 
-> (z:\mu_{*}\,f) -> A\;z
\end{array}
\]
\[
\textbf{mind}_{*} ~ \varphi ~ (\In_{*}\;x)
  ~=~ \varphi~~\textit{id}~~(\textbf{mind}_{*}~\varphi)~~x \]
\end{singlespace}\noindent
The definition of Mendler-style induction $\textbf{mind}$ is
essentionally the same as the Mendler-style primitive recursion $\MPr$,
but the type signature involves dependent types.
Note, the final answer type $A\;z$ is dependent on
the recursive argument $z:\mu_{*}F$.
Since $A: \mu_{*}F -> *$ expects a concrete recursive value,
we use $cast$ and $call$ in the type signature of $\varphi$ function
to cast $x:r$ and $y:F\,r$ into $\mu_{*}F$ values, so that
they can be passed to $A$.
In the type signature of $\textbf{mind}$, $cast$ comes before $call$
because the type signature of $call$ depends on $cast$.
When defining $\MPr$, $cast$ and $call$ can come in any order
since there is no dependency in the type signature of $\MPr$.

One important thing to notice about $\textbf{mind}_{*}$ is that
it is well-defined only over positivity $F$, because we relied on
the existence of $\textit{fmap}_F$ to write its type signature.
It is an open question whether one can formulate a Mendler-style induction
that works for negative datatypes.

The idea for $\textbf{mind}_{*}$ comes from
the discussion with Tarmo Uustalu. He described this on a whiteboard
     when we met with him at the University of Cambridge in 2011.

\section{Type-based termination and sized types}
\emph{Type based termination} (coined by \citet{BartheFGPU04}) stands for
approaches that integrates termination into type checking, as apposed to
syntactic approaches that reason termination over untyped term structures.
The Mendler-style approach is, of course, type-based.  In fact, the idea of
type-based termination was inspired by \citet{Mendler87,Mendler91}.
In Mendler-style, we know that the recursive functions defined using
the Mendler-style recursion schemes will terminate once they are
type correct (provided that the termination behaviors of
those recursion schemes are clearly studied).

\citet{abel06phd,Abel12talkFICS} summarizes the advantages of
type-based termination as follows:
\textbf{communication} (programmers can think in types),
\textbf{certification} (types are machine checkable certificate),
\textbf{a simple theoretical justification}
	(no additional complication for termination other than type checking),
\textbf{orthogonality} (only small parts of the language is affected,
	\eg, principled recursion schemes instead of general recursion),
\textbf{robustness} (type system extensions are less likely to
			disrupt termination checking),
\textbf{compositionality}\footnote{This is not listed in Abel's thesis,
				but comes from his invited talk in FICS 2012.}
	(need only types not the code for function definitions), and
\textbf{higher-order functions and higher-kinded datatypes}
	(works well even for higher-order functions and non-regular datatypes,
	as a consequence of compositionality).
In his dissertation \cite{abel06phd} (Section 4.4) on sized types,
Abel views the Mendler style approach as enforcing size restrictions
using higher-rank polymorphism as follows:
\begin{itemize}
\item The abstract recursive type $r$ in Mendler style corresponds to
	$\mu^\alpha F$ in his sized-type system (System \Fwhat),
	where the sized type
	for the value being passed in corresponds to $\mu^{\alpha+1} F$.
\item The concrete recursive type $\mu F$ in Mendler style corresponds to
	$\mu^\infty F$ since there is no size restriction.
\item By subtyping, a type with a smaller size index can be considered as
	the same type but with a larger size index.
\end{itemize}
This view is based on the same intuition, which we discussed in
Chapter \ref{ch:mendler}, why Mendler-style recursion schemes terminate for
positive datatypes -- since $r$-values are direct subcomponents, they should
have one less depth of $\In$ constructors than the value being passed in.
Abel's System \Fwhat\ can express primitive recursion quite naturally
due to subtyping. The casting operation $(r -> \mu F)$ in Mendler-style
primitive recursion corresponds to an implicit conversion by subtyping
from $\mu^\alpha F$ to $\mu^\infty F$ because $\alpha \leq \infty$.

TODO what about negative datatypes
in Mendler style
enforcing sized types without extending the syntax of size annotation,
and for this reason, he Mendler father of sized type
Only defined on MPr
TODO

\section{Logical Frameworks based on the $\lambda\Pi$-calculus}

Logical Framework (LF)

lambda pi calculus

term-indexing and term-dependency 
but lack polymorphism

System \Fi\
term-indexing and polymorhpism
but lack term-dependency.


termination checking is not type based

%% 
%% \section{TODO}

