\section{Mendler style recursion schemes}\label{sec:Mendler} I claim to
have organized the Mendler-style operators into a natural hierarchy. We
describe this hierarchy here. There are common patterns (or, general
forms) of Mendler-style recursion combinators that I use in my
dissertation (\S\ref{sec:mendler:intro}). These patterns have two
dimensions. The first dimension describes what and how the operator
computes, and the second dimension abstracts over the kind of a data
type. We call all Mendler operators that compute the same way, but over
different data types with different kinds,  a kind-indexed family of
operators. Mendler operators that compute things using a different
computation pattern belong to different families.

Despite the fact that different families compute things differently, all
families have a common structure. I discuss this common stucture first,
then I introduce several families of Mendler-style combinators
(\S\ref{sec:mendler:it}-\ref{sec:mendler:sf}) which I plan to support in
the Nax language design. Lastly, I postulate on other possible
generalizations and extensions (\S\ref{sec:mendler:etc}).

\subsection{Two level types and Mendler style recursion combinators}
\label{sec:mendler:intro}
In this section, I introduce the general pattern behind a Mendler-style recursion scheme.
We formulate recursive types in two levels,  by applying the recursive type operator
$\mu^\kappa$ to a non-recursive base structure $T$. 
We illustrated this in Figure \ref{fig:approaches}
in Section \ref{sec:relwork:other}. Figure \ref{fig:approaches}
only illustrates regular datatypes without indices
(i.e. where the $\kappa$ of $\mu^\kappa$ is kind $*$). Here, I will describe
the most general form where $\kappa$ of $\mu^\kappa$ has the form $\vec{\kappa}_i -> *$
(i.e. $(\vec{\kappa}_0 -> *)$ is $(*)$, and  $(\vec{\kappa}_1 -> *)$ is $(\kappa_1 -> *)$, and
$(\vec{\kappa}_2 -> *)$ is  $(\kappa_1 -> \kappa_2 -> *)$ etc.).

\paragraph{The pattern of recursive type construction.}
The general form of a non-recursive data type definition, which is to be used
as the base structure for a recursive types, is the following:
\begin{align*}
\textbf{data}~ T : \vec{\kappa}_p -> (\vec{\kappa}_i -> *) ->
                                      \vec{\kappa}_i -> *
~\textbf{where}~
&~ C_1 : \vec{\tau}_1 -> T\,\vec{p}\;r\;\vec{\tau_i}_{1} \\
&\quad \vdots \\
&~ C_n : \vec{\tau}_n -> T\,\vec{p}\;r\;\vec{\tau_i}_{n}
\end{align*}
The datatype constructor $T$ expects a series of type arguments $\vec{p}$, $r$,
and $\vec{i}$, whose kinds are $\vec{\kappa}_p$, $(\vec{\kappa}_i -> *)$, and
$\vec{\kappa}_i$, respectively. Thus, a value of this datatype would have
type $(T\,\vec{p}\,r\,\vec{i})$ where the type variables $\vec{p},r,\vec{i}$
are instantiated to certain types (or in the case of the $\vec{i}$, terms or types).
\begin{itemize}
\item The sequence of type variables $\vec{p}$ stand for the type parameters of the
type. Type parameters always appear regularly 
(\ie, they are always the same type variables $\vec{p}$\
no matter where they occur) in the type siguatures of
the data constructors $C_1,\cdots,C_n$. 

\item The type variable $r$ stands for
recursive ocurrences. Note it can have a rather complicted kind $(\vec{\kappa}_i -> *)$.

\item The sequence of type variables $\vec{i}$ stands for indices
that can vary (\eg, $\vec{\tau_i}_1,\vec{\tau_i}_n$) in the type signatures of
the data constructors $C_1,\cdots,C_n$. 

\item Note that classifying whether an argument is a parameteror or an index is
determined by its position-- whether it comes before or after $r$.

\end{itemize}
We discuss the pattern as it occurs for some common types
\begin{enumerate}

\item For non-parametrized types (or, monotypes) such as the natural numbers,
there are no parameters and no indices. For instance, the base structure
for natural numbers would have the form $N\;r$. 

\item For parametrized,
but non-indexed, types (or, regular polymorphic types), there are parameters
before $r$ but no indices after $r$. For instance, the base structure for
polymorphic lists would have the form $L\;p\;r$ where $p$ is the type of
the elements in the list. 

\item For indexed types, there are indices following $r$.
For instance, the base structure for length indexed lists would have the
form $Vector\;p\;r\;i$ where $p$ is the type of the elements in the list and
$i$ is the index that specifies the length of the list.

\end{enumerate}

To define the recursive types, we apply the recursive type operator ($\mu$) to
base structures. There is  family of recursive type operators $\mu^\kappa$
superscripted by kind $\kappa$, and its term constructor $\In^\kappa$ is also
superscripted by kind $\kappa$. The recursive type operator $\mu$
for regular datatypes in Figure \ref{fig:approaches} corresponds to $\mu^{*}$,
and its constructor is $\In^{*}$. In general the type operator $\mu^\kappa$
has kind $(\kappa -> \kappa) -> \kappa$ and the term constructor
$In^\kappa$ has type $f (\mu^\kappa\; f) -> \mu^\kappa\; f$ where
$f$ has kind $(\kappa -> \kappa)$.

One must use the recursive type operator of the appropriate kind,
which depends on the indices ($\vec{i}\,$) of the base structure.
For example, $\mu^{*}N$ is the natural number type;
$\mu^{*}(L\,p)$ is the list type; $\mu^{\textit{Nat}-> *}(V\,p)$ is the length indexed vector type.

In general, $\mu^\kappa : (\kappa -> \kappa) -> \kappa$ can be
applied to $T\,\vec{p} : \kappa -> \kappa$ to form a recursive type
(or, recursive type constructor, if there are indices)
$\mu^\kappa(T\,\vec{p}) : \kappa$. Note that datatypes become a type of kind $*$, 
only when they are fully appled. For example,
$T\,\vec{p}\,r\,\vec{i} : *$. 

Since we know that the recursive type is
well formed only when $T\,\vec{p} : \kappa -> \kappa$,
the next type argument $r$ must be of kind $\kappa$.
Also, we know that $\kappa$ should always be of the form
$\vec{\kappa} -> *$ where each of $\vec{\kappa}$ is the kind for
each of the indices $\vec{i}$. Note that in a well formed
type, $(\mu^\kappa\; f)$ and $f$ always have the same
kind $(\kappa -> \kappa)$.

\paragraph{The pattern of a Mendler-style operator type.}
Mendler style recursion combinators rely on
higher-rank polymorphism to ensure their normalization proprieties. 
Recall that, in Figure \ref{fig:approaches},
the type of $\varphi$ was required to be polymorphic over a type variable
$X$ (which corresponds to $r$ in this section).
The following is the general form of the type of a Mendler-style
recursion combinator in the presence of type indices:
\begin{multline*}
 \textsf{Mxxx} : \forall t . \forall a .
   \big(\, \forall r . \;
      \overbraceset{\begin{smallmatrix}
                        \text{abstract} \\
                        \text{recursive call} \\
                        \text{over $r$-structure}
                       \end{smallmatrix}}{
            (\forall\vec{i} . r\,\vec{i} -> a\,\vec{i}\,) }
   -> \overbraceset{\begin{smallmatrix}
                        \text{other} \\
                        \text{abstract operations} \\
                        \text{over $r$-structure}
                       \end{smallmatrix}}{
            (\forall\vec{i} . \cdots) -> \cdots }
   -> \overbraceset{\begin{smallmatrix}
                        \text{function body desc.:} \\
                        \text{combines a $t$ structure}\\
                        \text{filled with $r$-values} \\
                        \text{into an answer}
                       \end{smallmatrix}}{
            (\forall\vec{i} . t\, r\, \vec{i}  -> a\,\vec{i}\,) }
   \big) \\
 -> \underbraceset{\text{resulting recursive function}}{
       (\forall\vec{i} . (\mu^\kappa t)\,\vec{i} -> a\,\vec{i}\,) }
\end{multline*}

Different families have diferent specifications as to the number and
type of the {\it other abstract operations}. Members of the same family
differ over the number and kind of the indices $\vec{i}$.

One can think of a Mendler-style recursion combinator as a higher order
function. It returns a recursive function when applied
to a set of abstract operations. The operations are abstract over the 
(possibly indexed) type $r$. These operations must never rely on the structure
of $r$, and the higher-rank polymorphism enforces this.
We can think of the above as an encoding of the following
where $r$ is an abstract type:
\begin{multline*}
 \textsf{Mxxx} : \forall t . \forall a .
 \exists r.
  \big(  (\forall\vec{i} . r\,\vec{i} -> a\,\vec{i}\,)
   \times (\forall\vec{i} . \cdots) \times \cdots
   \times (\forall\vec{i} . t\, r\,\vec{i} -> a\,\vec{i}\,)
   \big) \\
 -> (\forall\vec{i} . (\mu^\kappa t)\,\vec{i} -> a\,\vec{i}\,)
\end{multline*}
The abstract recursive call operation $(\forall\vec{i} . r\,\vec{i} -> a\,\vec{i}\,)$ is available in
all the Mendler-style families we study. Each family (\textsf{xxx})
is distinguished by what other additional abstraction operations are available.
Note that the abstract operations manipulate values of type $r$ when we describe
the function body, but we can apply the resulting recursive function
to a concrete structure of type $(\mu^\kappa t)$. At runtime
$r$-values really are $(\mu^\kappa t)$-values, but
by using an abstract type $r$ while type-checking, we
can restrict the use of the recursive caller to those uses that are guaranteed to normalize. 

Recall that we apply
$\mu^\kappa$ to the datatype constructor after it is partially applied to its parameters 
(all the arguments of $T$ before $r$). So, the type variable $t$ is always
instantiated to $T\,\vec{p}$.

The type of \textsf{Mxxx} involves both higher-rank polymorphism and
indexed types. Both of these features make type inference difficult.
Firstly, type inference for higher-rank polymorphism is impossible in general.
Recall that in the Hindley-Milner type inference, terms have monomorphic types
by default and only limited form of polymorphic types (type schemes) are
introduced by the designated \textbf{let}-syntax.  However, if we limit
the use of higher-rank polymorphism only in Mendler style recursion combinators,
considering \textsf{Mxxx} as a designated syntax, we can do type inference.
Secondly, type inference for indexed types is impossible in general.
This is why programming languages like Haskell cannot infer types of programs
involving the GADTs extension, and proof assistant like Coq supporting
dependent types cannot support type inference in general. In Nax, we support
partial type inference (or, reconstruction) from small amount of annotations
($\psi$) only required on the Mendler style recursion combinators
($\textsf{Mxxx}^\psi$). We call these annotations ($\phi$) index transformers,
since they are type level functions that specify how to construct
the resulting type from the input indices. We shall see more cleary
what index transformers are throughout the examples in
\S\ref{sec:mendler:it}-\S\ref{sec:mendler:sf}.

\subsection{Mendler style iteration}\label{sec:mendler:it}
The iteration family \MIt\ is the most basic Mendler style recursion scheme,
which only support one abstract operation, abstract recursive call.
The type signature of \MIt\ is:
\[ \MIt : \forall t . \forall a .
   \big(\, \forall\, r\, . \;
         \overbraceset{\begin{smallmatrix}
                        \text{abstract} \\
                        \text{recursive call} \\
                        \text{over $r$-structure}
                       \end{smallmatrix}}{
            (\forall\vec{i} . r\,\vec{i} -> a\,\vec{i}\,) } \;
   -> \; \overbraceset{\begin{smallmatrix}
                        \text{function body desc.:} \\
                        \text{combines $r$-value} \\
                        \text{into an answer}
                       \end{smallmatrix}}{
            (\forall\vec{i} . r\,\vec{i} -> a\,\vec{i}\,) }
   \big)
 -> \; \overbraceset{\text{resulting recursive function}}{
          (\forall\vec{i} . (\mu^\kappa t)\,\vec{i} -> a\,\vec{i}\,) } 
\]
\begin{figure}
\begin{align*}
\text{Base structure:}\qquad\qquad
\textbf{data}~N : * -> * ~\textbf{where}~~
& \textit{Zero} : N\;r\\
& \textit{Succ} : r -> N\;r
\end{align*}
\[\text{Type synonym:}\qquad\qquad \textit{Nat} ~=~ \mu^{*} N\]
\begin{align*}
\text{Constructor functions:}\quad
&zero~~\,~=~ \In^{*} \textit{Zero} \\
&succ\;n ~=~ \In^{*} (\textit{Succ}\;n)
\end{align*}
\caption{Two level type definition of natural numbers and
         their constructor functions}
\label{fig:natdef}
\end{figure}
A typical example of is a length function for lists.
We can define the base structure for lists as follows:
\begin{align*}
\textbf{data}~L : * -> * -> * ~\textbf{where}~~
& \textit{Nil}~~\, : L\;p\;r \\
& \textit{Cons}    : r -> p -> L\;p\;r
\end{align*}
Then, we can define the \textit{length} function using the Mendler style
iteration combinator as follows:
\begin{align*}
\textit{length}~l = \MIt^{\{\}}~l~\textbf{with}~~
&  len ~\textit{Nil}~~~~~~~~~~~ = zero \\
&  len \;(\textit{Cons}\;x\;xs) = succ\,(len\;xs)
\end{align*}
Since the list type does not involve any indices, we give an empty index
transformer annotation ($\{\}$) on \MIt. The type signature for the length
function is $\textit{length}:\mu^{*}(L\;p) -> \mu^{*}N$ where $N$ is the
base structure for the natural number type. Let us assume that we have
type synonyms $\textit{List} = \mu^{*}(L\;p)$ and
$\textit{Nat} = \mu^{*}N $.\footnote{Nax implementation supports type synonyms.}
Then, we can say that $\textit{length}:\textit{List}\;p -> \textit{Nat}$.
This type of \textit{length} can be inferred by the type system of
the Nax language.

It is worth emphasizing that $len : r -> \textit{Nat}$ is an abstract recursive
call operation that expects $r$-values. Note $xs:r$ since the type signature
for \textit{Cons} expects its first argument to be of type $r$. Therefore,
Mendler style iteration does not have direct access to the tail of the list.
That is one cannot define a constant time tail function by just returning
$xs$ since its type is an abstract recursive type ($r$) rather than
a concrete list type ($List$). We shall see soon that the primitive recursion
family is able to express such functions naturally.

Mendler style recursion combinators generalize naturally to indexed types.
Let us look at some examples of Mendler style iteration over indexed types.
Before we move on for the primitive recursion family.

The following is the base structure for vectors, or length indexed lists:
\begin{align*}
\textbf{data}~V : * -> (Nat -> *) -> Nat -> * ~\textbf{where}~~
& \textit{VNil}~~\, : V\;p\;r\;\{`zero\} \\
& \textit{VCons}    : r\;\{n\} -> p -> V\;p\;r\;\{`succ\;n\}
\end{align*}
We use curly braces ($\{\dots\}$) to emphasize that they are \emph{term indices}
(\ie, term used as indices) in order to distinguish them from ordinary
type indices (\ie, types used as indices). The backquotes ($`$) prefixed
on $zero$ and $succ$ emphasizes that they are predefined values rather than
free type (or, index) variables (\eg, $p$,$r$,$n$) that may be generalized.

Then, we can define the length function for vectors using the Mendler style
iteration combinator as follows:
\begin{align*}
\textit{vlength}~l = \MIt^{\{\{n\} . \textit{Nat}\}}~l~\textbf{with}~~
&  vlen ~\textit{VNil}~~~~~~~~~~~ = zero \\
&  vlen \;(\textit{VCons}\;x\;xs) = succ\,(vlen\;xs)
\end{align*}
Note, the Mendler style iteration combinator $\MIt^\psi$ is annotated by
the index transformer $\psi = \{n . \textit{Nat}\}$, which is a constant
type level function that ignores the index $n$ and always returns the 
type $\textit{Nat}$. In general, type inference for programs involving
type indices are not possible. However, Nax can infer that
$vlengh : \textit{Vec}\;p\;\{n\} -> \textit{Nat}$, where
\textit{Vec} is a type synonym defined as
$\textit{Vec} = \mu^{\textit{Nat} -> *}(V\;p)$, based on the index transformer
annotation on \MIt.

Append function for vectors illustrates a more interesting use of
the index transformer annotation:
\begin{align*}
\textit{vappend}~\,l_1 =~ &
 \MIt^{\{\{n\} . \textit{Vec}\;p\;\{m\} \, -> \, \textit{Vec}\;p\;\{`plus\;n\;m\}\}}~l_1
 ~\textbf{with} \\
&\qquad\qquad\qquad\qquad  vapp ~\textit{VNil}~~~~~~~~~~~ ~ l_2 = l_2 \\
&\qquad\qquad\qquad\qquad  vapp \;(\textit{VCons}\;x\;xs) ~ l_2 = cons\;x\;(vapp\;xs\;l_2)
\end{align*}
where $nil = \In^{*} \textit{Nil}\;$ and
$\,cons\;x\;xs = \In^{*}(\textit{Cons}\;x\;xs)$.
The index transformer
$\{\{n\} . \textit{Vec}\;p\;\{m\} \, -> \, \textit{Vec}\;p\;\{`plus\;n\;m\}\}$
specifies that the append function applied to a list of length $n$,
shall return a function, which expects a vector of length index is $m$
and returns a vector of length $(plus\;n\;m)$, where $plus$ is the addition
function for natural numbers.

We can also use indexed types to encode mutually recursive types.
For instance, consider the following definitions:
\begin{align*}
&\textbf{data}~ \textit{Parity} = E \mid O \\
&\textbf{data}~ \textit{Pf}\, : (\textit{Nat} -> \textit{Parity} -> *) ->
                                    \textit{Nat} -> \textit{Parity} -> *
  ~\textbf{where}\\
&\quad \textit{BaseE}\, : \textit{Pf}~\,r\;\{`zero\}\;\{E\} \\
&\quad \textit{StepE}\; : r\;\{n\}\;\{O\} -> \textit{Pf}~\,r\;\{`succ\;n\}\;\{O\} \\
&\quad \textit{StepO}\; : r\;\{n\}\;\{E\} -> \textit{Pf}~\,r\;\{`succ\;n\}\;\{O\}
\end{align*}
Let $\textit{Proof} = \mu^{\textit{Nat} -> \textit{Parity} -> *} \textit{Pf}$,
$\textit{Even}\;\{n\} = \textit{Proof}~\{n\}\;\{E\}$, and
$\textit{Odd}\;\{n\} = \textit{Proof}~\{n\}\;\{O\}$ be type synonyms.
Then, \textit{Even} and \textit{Odd} are encodings of the following
mutually recursive datatypes:
\begin{align*}
&\textbf{data}~\textit{Even} : \textit{Nat} -> \textit{Parity} -> *
 ~\textbf{where} \\
&\quad \textit{BaseE}\, : \textit{Even}\;\{`zero\}\\
&\quad \textit{StepE}\; : \textit{Odd}\;\{n\} -> \textit{Even}\;\{`succ\;n\} \\
&\textbf{data}~\textit{Odd} : \textit{Nat} -> \textit{Parity} -> *
 ~\textbf{where} \\
&\quad \textit{StepO}\; : \textit{Even}\;\{n\} -> \textit{Odd}\;\{`succ\;n\}
\end{align*}
I will also include examples involving mutually recursive datatypes
in my dissertation.

It is known that \MIt\ for regular datatypes and indexed types with ordinary
type indices has a reduction preserving embedding into System \Fw\ (\ie, \MIt\
is definable in \Fw\ with constant reduction step difference).
In my dissertation, I will show that \MIt\ for term indexed types has a
reduction preserving embedding into System \Fi, which is an extension of \Fw.
Also, I will describe and prove properties of the inference algorithm of Nax,
and also discuss why index transformer is the sweet spot for the design of
type system suppering type inference in the presence of indexed types.

\subsection{Mendler style primitive recursion}\label{sec:mendler:pr}
The primitive recursion family \MPr\ is has an additional casting operation,
which explicitly converts a value of the abstract recursive type ($r$-value)
into a value of the concrete recursive type ($(\mu^\kappa t)$-value).
The type signature of \MPr\ is:
\begin{multline*}
 \MPr : \forall t . \forall a .
   \big(\; \forall\, r\, . \;
         \overbraceset{\begin{smallmatrix}
                        \text{abstract} \\
                        \text{recursive call}
                       \end{smallmatrix}}{
            (\forall\vec{i} . r\,\vec{i} -> a\,\vec{i}\,) } \;
   -> \; \overbraceset{\begin{smallmatrix}
                        \text{cast from $r$-values} \\
                        \text{to $(\mu^\kappa t)$-values} \\
                       \end{smallmatrix}}{
            (\forall\vec{i} . r\,\vec{i} -> (\mu^\kappa t)\,\vec{i}\,) } \;
   -> \;    (\forall\vec{i} . r\,\vec{i} -> a\,\vec{i}\,) \,
   \big) \\
 -> (\forall\vec{i} . (\mu^\kappa t)\,\vec{i} -> a\,\vec{i}\,)
\end{multline*}
Since \MPr\ has more operations than \MIt, it can express all the functions
that we can express with \MIt, but often more efficiently because of the
additional casting operation.

A typical example of primitive recursion is the factorial function:
\begin{align*}
\textit{factorial}~x = \MIt^{\{\}}~x~\textbf{with}~~
&  \textit{fac} ~cast ~\textit{Zero}~~~~\; = succ~zero \\
&  \textit{fac} ~cast \;(\textit{Succ}\;n) = mult~(succ\;(cast\;n))~(\textit{fac}\;n)
\end{align*}
where \textit{mult} is the multiplication function for natural numbers.
In addition to the abstract recursive call $\textit{fac} : r -> \textit{Nat}$,
\MPr\ supports the casting operation $cast : r -> \textit{Nat}$.
Therefore, we can convert from an abstract value ($n : r$) to
a concrete value ($cast\;n : \textit{Nat}$).

The casting operation enables us to define a constant time tail function for
lists as follows:
\begin{align*}
\textit{tail}~x = \MIt^{\{\}}~x~\textbf{with}~~
&  tl ~cast~\textit{Nil}~~~~~~~~~~~ = nil \\
&  tl ~cast\;(\textit{Cons}\;x\;xs) = cast\;xs
\end{align*}
We simply need to return $cast\;xs$ for the result
without recursing on $xs$ using $tl$. Nax can infer that
$\textit{tail} ~:~ \textit{List}\;p -> \textit{List}\;p$
Note that we needed to return some default value ($nil$) for the empty list case
($Nil$) because all functions defined via Mendler style recursion combinators
must be total. However, for length index lists (or, vectors), we can imagine
a version of a tail function
$\textit{vtail}\,:\textit{Vec}\;p\;\{`succ\;n\} -> \textit{Vec}\;p\;\{n\}$,
which only expects non-empty lists -- therefore, need not specify default
values for the empty list case. To express functions like $vtail$, which has
constraint on the input value, we need more advanced features in the type system
than what we have been discussing so far. We will discuss such possible
extensions to Mendler style recursion combinators in \S\ref{sec:mendler:etc}.

The Mendler style primitive recursion family \MPr\ needs a more complicated
calculus than \Fi, called \Fixw, in order to embed \MPr\ in a reduction
preserving manner. Just as I extended from \Fw\ to \Fi\ in order to
formalize the theory of \MIt\ involving term indices, I extend from \Fixw\
to \Fixi\ in order to formalize the theory of \MPr\ involving term indices.

\subsection{Mendler style course of values iteration \& primitive recursion}
Some computations are naturally expressed by recursing on multiple levels
down the structure of the input value (\eg, predecessor of predecessor,
tail of tail). Such patterns of recursion is called \emph{course of values}
recursion. Course of values recursion often appears in number sequences
defined by recurrence relations (\eg, Fibonacci's sequence).
We can extend \MIt\ and \MPr\ with a new abstract operation, which enables
us to express course of values recursive functions, as follows:
\label{sec:mendler:cv}
\begin{align*}
\!\!\!\!\!\!\!\!
 \McvIt\, :&\; \forall t . \forall a .
   \big( \forall r .
         (\forall\vec{i} . r\,\vec{i} -> a\,\vec{i}\,)
   -> \overbraceset{\begin{smallmatrix}
                     \text{open $r$-structure to} \\
                     \text{reveal $t$-structure} \\
                    \end{smallmatrix}}{
         (\forall\vec{i} . r\,\vec{i} -> t\,r) }
   ->    (\forall\vec{i} . r\,\vec{i} -> a\,\vec{i}\,)
   \big) \\
& -> (\forall\vec{i} . (\mu^\kappa t)\,\vec{i} -> a\,\vec{i}\,) \\
\!\!\!\!\!\!\!\!
 \McvPr :&\; \forall t . \forall a .
   \big( \forall r .   
         (\forall\vec{i} . r\,\vec{i} -> a\,\vec{i}\,)
   -> \overbraceset{\begin{smallmatrix}
                     \text{open $r$-structure to} \\
                     \text{reveal $t$-structure} \\
                    \end{smallmatrix}}{
         (\forall\vec{i} . r\,\vec{i} -> t\,r) }
   -> \overbraceset{\begin{smallmatrix}
                     \text{cast from $r$-values} \\
                     \text{to $(\mu^\kappa t)$-values} \\
                    \end{smallmatrix}}{
         (\forall\vec{i} . r\,\vec{i} -> (\mu^\kappa t)\,\vec{i}\,) }
   ->    (\forall\vec{i} . r\,\vec{i} -> a\,\vec{i}\,)
   \big)\\ 
& -> (\forall\vec{i} . (\mu^\kappa t)\,\vec{i} -> a\,\vec{i}\,)
\end{align*}
\McvIt\ stands for Mendler style course of values iteration,
and \McvPr\ stands for Mendler style course of values primitive recursion.

We can define the Fibonacci function using \McvIt\ as follows:
\begin{align*}
\textit{fibonacci}~x = \McvIt^{\{\}}~x~\textbf{with}~~
&  \textit{fib} ~out ~\textit{Zero}~~~~\; = succ~zero \\
&  \textit{fib} ~out \;(\textit{Succ}\;n) =
            \textbf{case}^{\{\}}~out\;n~\textbf{of} \\
&\qquad\qquad\qquad\qquad\quad
              \textit{Zero}~~~\, -> succ~zero \\
&\qquad\qquad\qquad\qquad\quad
              \textit{Succ}\;n'  -> plus\;(\textit{fib}\;n')\;(\textit{fib}\;n)
\end{align*}
Recall that we cannot inspect the structure of the predecessor $n$ since
its type is abstract (\ie, $n:r$). The $out : r -> \textit{Nat}\,$ operation
opens up the abstract structure ($r$) and reveals the base structure ($N$).
So, it becomes possible to destruct (or, pattern match against) $out\;n$,
and have access to the processor of predecessor $n'$. If needed, we can
traverse down three steps by applying $out$ to $n'$, and even further by
repeatedly applying $out$ to the inner structure. I also have examples
that traverses down many number of steps, which will appear in my dissertation.

An important aspect of the Mendler style course of values recursion is that
it only grantees normalization over positive recursive types. One of our
recent contribution is that we have reported a counterexample of \textsf{McvIt}
involving negative recursive type, which does not normalize. So, to be more
precise, the type signatures of \textsf{McvIt} and \textsf{McvPr} need to
be constrained ($\forall t \text{~such that~$t$ is positive}.\cdots$)
instead of being unconstrainedly polymorphic on $t$.

I strongly believe that we can have a reduction preserving embedding of
\McvIt\ and \McvPr\ into \Fixw\, and \Fixi\ taking term indices into
consideration.\footnote{I haven't written this down yet but I see it
is going to be quite straightforward.} The embedding would different from
the embedding of \MPr\ though. The embedding of a certain family of
the Mendler style recursion combinator is a pair of translation --
a translation of the recursive type operator and a translation of
the Mendler style recursion combinator. In general, the translation of
the recursive type operator $\mu^\kappa$ is different for each family
of the Mendler style recursion combinators, even though their target
calculi may coincide.

\subsection{Mendler style iteration with syntactic inverse}
Although \MIt\ is normalizing for negative recursive types, there exist
certain class of total functions over negative recursive types, which is
useful but not easily expressed in terms of \MIt. This class of functions
were studied in the conventional setting. My recent contribution is
the discovery of the new family of the Mendler style recursion combinators,
which can express those class of functions. We call this new family \MsfIt,
whose type is shown below:
\label{sec:mendler:sf}
\[
 \MsfIt : \forall t . \forall a .
   \big( \forall r.
            (\forall\vec{i} . r\,\vec{i} -> a\,\vec{i}\,)
   -> \overbraceset{\begin{smallmatrix}
                        \text{inverse from} \\
                        \text{answers to $r$-values} \\
                       \end{smallmatrix}}{
            (\forall\vec{i} . a\,\vec{i} -> r\,\vec{i}\,) }
   -> \;    (\forall\vec{i} . r\,\vec{i} -> a\,\vec{i}\,)
   \big)
 -> (\forall\vec{i} . (\mu^\kappa t)\,\vec{i} -> a\,\vec{i}\,)
\]
In addition to the abstract recursive call, \MsfIt\ supports abstract
inverse from answer values ($a$) to abstract recursive values ($r$).
Several examples and detailed discussions on \MsfIt\ can be found in
our recent work \cite{AhnShe11} (also known as \textit{msfcata}).
We \cite{AhnShe11} proved normalization properties of \MsfIt\ by
embeding \MsfIt\ into \Fw. I plan to extend the proof for \MsfIt\,
taking term indexed types into consideration, by embedding \MsfIt\
into \Fi, which is an extension of \Fw.

I am also planning to write more complex examples in the Nax language using \MIt
-- \emph{normalization by evaluation} and \emph{parallel reduction}.

I will also discuss why we have not extended the primitive recursion family
and the course of values family with syntactic inverse.

\subsection{Other possible extensions}\label{sec:mendler:etc}
D) indexed types

E) Extension in the presence of Definitional Equality constraints.

F) Extension in the presence of provable equality (examples?)

\subsection{summary???}
G) Theory?
   formalization, typing, dynamic semantics, type inference
   statements (and perhaps proofs) of properties that should hold.
   Strong normalization, soundness with respect to dynamic semantics,
   logical soundness (F-omega argument)

