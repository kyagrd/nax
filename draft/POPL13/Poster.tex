\documentclass[final]{beamer}
%% beamer 3.10: do NOT use option hyperref={pdfpagelabels=false} !

\mode<presentation> {
%% examples http://www-i6.informatik.rwth-aachen.de/~dreuw/latexbeamerposter.php
% \usetheme{Berlin}
%% you should define your own theme e.g. for big headlines using your own logos 
  \usetheme{I6pd2}
}
\usepackage[english]{babel}
\usepackage[latin1]{inputenc}
\usepackage{amsmath,amsthm,amssymb,latexsym,textcomp,setspace}
\usepackage{listings}
\usepackage[inference,ligature]{semantic}
\mathlig{->}{\to}
\mathlig{|-}{\vdash}
%\usepackage{times}\usefonttheme{professionalfonts}  % times is obsolete
\usefonttheme[onlymath]{serif}
\boldmath
\usepackage[orientation=landscape,size=a0,scale=1.4,debug]{beamerposter}

\newcommand{\dom}{\mathop{\mathsf{dom}}}
\newcommand{\FV}{\mathop{\mathrm{FV}}}

\newcommand{\Fw}{\ensuremath{\mathsf{F}_\omega}}
\newcommand{\Fi}{\ensuremath{\mathsf{F}_{\!i}}}
\definecolor{grey}{rgb}{0.8,0.8,0.8}
\newcommand{\newFi}[1]{\colorbox{grey}{\ensuremath{#1}}}



\lstset{language=Haskell,
	basicstyle=\ttfamily\small,
	keywordstyle=\color{ta4chameleon},
	commentstyle=\color{gray},
	literate =
		{forall}{{\textcolor{ta3chocolate}{$\forall$}}}1
		{=}{{\textcolor{ta3chocolate}{$=$}}}1
		{::}{{\textcolor{ta3chocolate}{$:\!\,:$}}}1
		{->}{{\textcolor{ta3chocolate}{$\to$}}}1
	}

\title[Fancy Posters]{{\VERYHuge System \Fi} {\Huge :}
		{\huge a Higher-Order Polymorphic $\lambda$-calculus} \\
		{\huge with Erasable Term Indices}
  }
\author[Ki Yung Ahn]{ Ki Yung $\,$Ahn $\,$ {\Large\texttt{kya@cs.pdx.edu}} }
\institute[Portland State University]{
	Department of Computer Science, Portland State University }
\date{2012-09}
\begin{document}
\begin{frame}[fragile]
%%   \vfill
%%   \begin{block}{Fontsizes}
%%     \centering
%%     {\tiny tiny}\par
%%     {\scriptsize scriptsize}\par
%%     {\footnotesize footnotesize}\par
%%     {\normalsize normalsize}\par
%%     {\large large}\par
%%     {\Large Large}\par
%%     {\LARGE LARGE}\par
%%     {\Huge Huge}\par
%%     {\veryHuge veryHuge}\par
%%     {\VeryHuge VeryHuge}\par
%%     {\VERYHuge VERYHuge}\par
%%   \end{block}
%% \vfill
\begin{columns}[t]

\begin{column}{.315\linewidth}

\begin{block}{Indexed Datatypes
	{\normalsize({\small a.k.a. }Lightweight Dependent Types)} }
\begin{itemize}
\item Indexed datatyeps are datatypes
	with \emph{static (compile-time) dependencies}.
%%        (c.f. full-fledged dependent types can have
%%        both static and dynamic dependencies)
	Also known as higer-kinded datatypes, higher-rank datatypes,
	or lightweight dependent types
\item Use of indexed datatypes, or the \textcolor{magenta}{\emph{lightweight approach}},
	has become popular
	over the past decade even in real-world functional programming due to
	the GADT extension in the Glasgow Haskell Compiler.
\end{itemize}
\end{block}

\begin{block}{Examples of Indexed Datatypes}
\begin{itemize}
\item Type-indexed datatypes
	$\quad$\textcolor{gray}{\normalsize(example code in Haskell)}
	\begin{itemize}
		\item Nested datatypes $\quad$
			\lstinline!data Powl a = PCons Powl (a,a) | PNil!
		\item Representation types in datatype generic programming
		\begin{lstlisting}
		data Rep t where
		  RInt  :: Rep Int
		  RBool :: Rep Bool
		  RPair :: Rep a -> Rep b -> Rep (a,b)
		  RFun  :: Rep a -> Rep b -> Rep (a -> b)
		\end{lstlisting}
	\end{itemize}
\item Term-indexed datatypes
	$\quad$\textcolor{gray}{\normalsize(example code in Nax)}
	\begin{itemize}
        	\item Length-indexed lists
		\begin{lstlisting}
		data Vec (a :: *) {n :: Nat} where
		  VCons :: a -> Vec a {i} -> Vec a {Succ i}
		  VNil  :: Vec {Zero}
		\end{lstlisting}
		\item de Bruijn terms indexed by size-indexed context
		\begin{lstlisting}
		data BTerm (c :: Nat -> *) {n :: Nat} where
		  BVar :: c {i} -> BTerm c {i}
		  BApp :: BTerm c {i} -> BTerm {i} -> BTerm c {i}
		  BAbs :: BTerm c {Succ i} -> BTerm c {i}
		\end{lstlisting}
	\end{itemize}
\end{itemize} %% $$\alpha=\gamma, \sum_{i}$$
\end{block}

\end{column}
%%%%%%%%%%%%%%%%%%%%%%%%% column sep %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{column}{.315\linewidth}

\begin{block}{Limitations of the Lightweight approach {\normalsize(so far)}}
Although extending existing programming languages with indexed datatypes
has been useful, it still suffers from the following problems:
\begin{itemize}
\item Increase \emph{confidence} but no \emph{guarantee} of correctness
	\begin{lstlisting}
	loop :: forall a . a    -- logically inconsistent type system
	loop = loop       -- allows proof of falsity
	\end{lstlisting}
\item Faked term indices in implementations (until recently)
	\begin{lstlisting}
	data Zero       -- code duplication at type level
	data Succ n     -- and cannot prevent (Succ Bool)
	\end{lstlisting}
\item Type checking/inference may be undecidable/impossible
	\begin{itemize}
		\item type equality check over term-indexed types
			relies on term equality, which is undecidable
			when diverging terms exist
		\item need \emph{annotation} for inference,
			but \emph{how much} and \emph{where}?
	\end{itemize}
\end{itemize}
\end{block}

\begin{block}{Motivating example: embedding datatypes}
\begin{itemize}
\item some items
\item some items
\item some items
\item some items
\end{itemize}
\end{block}


\end{column}
%%%%%%%%%%%%%%%%%%%%%%%%% column sep %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{column}{.315\linewidth}

\begin{block}{\Fi ~= {\normalsize Curry-style} \Fw\ + \{erasable term indices\}}
$\text{Variables}~~ x,i \qquad\quad \text{Type constructor variables}~~ X$ \\
$\text{Terms}~~~ r,s,t ~ ::= ~ x \mid \lambda x.t \mid r\;s \qquad\quad\text{\small(Curry-style terms)}$\\
$\text{Kinds}~~~~ \kappa ~ ::= ~ *
                                \mid \kappa -> \kappa
				\mid \newFi{A -> \kappa{\phantom{y}}\!\!} $\\
$\text{Type Constructors}$\\
$\quad A,B,F,G               ~ ::= ~ X
                                \mid A -> B
                                \mid \lambda X^\kappa.F
                                \mid F\,G
                                \mid \forall X^\kappa . B$\\
$~\qquad\qquad\qquad\qquad\qquad\qquad\qquad\quad
\mid \newFi{\lambda i^A.F
                                \mid F\,\{s\}
                                \mid \forall i^A . B}$ \\
$\text{Contexts}
\qquad \Delta                ~ ::= ~ \cdot
                                \mid \Delta, X^\kappa
                                \mid \newFi{\Delta, i^A}
\qquad \Gamma                ~ ::= ~ \cdot
                                \mid \Gamma, x : A 
$
\vskip-2ex\textcolor{grey}{\hrule}\vskip.7ex
$\text{Typing rules} \quad
\inference[($:$)]{ (x:A) \in \Gamma & \Delta |- \Gamma }
		 {\Delta;\Gamma |- x : A} ~~~
\newFi{
\inference[($:i$)]{ i^A \in \Delta & \Delta |- \Gamma }
		  {\Delta;\Gamma |- i : A}  }
$ \vskip-1ex ~ \\
$\text{Kinding rules} \quad
\newFi{
\inference[($@i$)]{ \Delta |- F : A -> \kappa & \Delta;\cdot |- s : A }
                  {\Delta |- F\,\{s\} : \kappa}  }
$
\vskip-1ex\textcolor{grey}{\hrule}\vskip.7ex
$\text{Index Erasure}
\qquad (A\to\kappa)^{\circ}=\kappa^{\circ} \qquad
(\Delta,i^A)^\circ = \Delta^\circ $ \\
$\qquad(\lambda i^{A}.F)^{\circ}=F^{\circ} \qquad
(F\,\{s\})^{\circ}\;=F^{\circ} \qquad
(\forall i^{A}.F)^{\circ}=F^{\circ}
$ \\
$ \text{Index Erasure Theorem {\small(for terms without index variables)} }$
\[
\inference{\Gamma;\Delta|- t:A ~~\text{derivable in \Fi}}
	  {\Delta^\circ;\Gamma^\circ|- t:A^\circ  ~~\text{derivable in \Fw}}
	  (\FV(t)\cap\dom(\Delta) = \emptyset)
\]
\vskip-1ex\textcolor{grey}{\hrule}\vskip.7ex
Strongly Normalization TODO\\
Logical Consistency TODO
\end{block}

\begin{block}{Contribution and Ongoing work}
\begin{itemize}
\item identifying the features needed for $\lambda$-calculi 
    to embed term-indexed datatypes, in isolation with other
    requirements % (e.g., large elimination)
\item design of a calculus useful for studying properties of
    term-indexed datatypes
    {\normalsize
	    (e.g., proof using \Fi\ that the eliminators for indexed datatypes
    	in \emph{Ahn\,\&\,Sheard,ICFP'11} are indeed normalizing) }
\item proof that the calculus enjoys a simple erasure property
    and inherits metatheoretic results from well-known calculi
\end{itemize}
\end{block}

\end{column}
\end{columns}

\end{frame}
\end{document}
