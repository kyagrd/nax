\section{Introduction}
\label{sec:intro}

%% theoretical core language for languages supporting
%% non-regular datatypes (\eg, nested datatypes) and
%% indexed datatypes (\eg, GADTs), but not fully dependent types.
%% 
%% embed recursive datatypes by Church encoding and show strong normalization
%% for the logical fragment of such a language

The introduction of Generalized Algebraic Datatypes (GADTs) to
functional languages such as Haskell and O'Caml has popularized
the use of indexed datatypes as a light-weight, type-based mechanism
to raise users' confidence that software systems maintain important properties.
A classic example is Louis-Julien Guillemette thesis\cite{guillemetteThesis}
which encodes the classic paper by Morrisett et al.\cite{tal-toplas} completely
in Haskell. The system embeds a multi-stage compiler, compiling from System F,
all the way to typed assembly language, using indexed types to show that
every stage preserves type information.

This impressive system provides confidence, but no guarantees, since it uses types to enforce
type preservation between the stages of the compiler. In Haskell, the non-terminating computation
can be assigned any type, so in practice, it is possible that this property is a consequence
of such a non-terminating computation in the program code.

On the other hand, the lambda calculus \Fw, is known to be strongly normalizing, and
through the use of Church encodings or Scott encodings of data structures is rich enough
to many data rich systems, such as compilers. Unfortunately, it is not known
how to express the kind of \emph{term-indexed datatypes} in \Fw\ that are necessary to
support Guillemette's system.

Xavier Leroy, in his CompCert system\cite{Leroy-Compcert-CACM}, showed that a much richer
language, the Calculus of Inductive Constructions (CIC), embedded in the Coq theorem prover,
is expressive enough to guarantee type preservation between compiler stages
(and quite a bit more). Unfortunately, this expressivity comes with a cost.
Programmers must learn to use both dependent types, and a new programming
paradigm, programming by code extraction.

Is there an expressive system, somewhere in between \Fw\ and dependent calculi?
Can we use indexed types (rather than dependent types) when they are all
we need? Can we program, rather than extract code?
The goal of this paper is to develop the theory necessary to begin to answer
these and related questions.

To approach this goal, we designed a calculus, System \Fi,
which extends System \Fw\ with as little feature as possible,
yet expressive enough to embed non-dependent \emph{term-indexed datatypes}
and their eliminators. Our contributions are:\vspace*{-3pt}
\begin{itemize}
\item identifying the features needed for the $\lambda$-calculus
    to embed term-indexed datatypes (\S\ref{sec:motiv}),
    in isolation of other features (e.g., large elimination, dependent types),
    \vspace*{-2pt}
\item design of the calculus, System \Fi\ (\S\ref{sec:Fi}), which is
    useful for studying the properties languages with term-indexed datatypes
    by embedding those datatypes into the calculus (\S\ref{sec:data})
%%    (e.g., we can use \Fi\ to give formal proof that the eliminators
%%    for GADTs appearing in our last year's ICFP paper \cite{AhnShe11} are
%%    indeed normalizing), \vspace*{-3pt}
    \vspace*{-2pt}
\item showing that the calculus enjoys a simple erasure property
    (\S\ref{ssec:erasure}) and inherits metatheoretic results
    from well-known calculi related to \Fi\ (\S\ref{ssec:sn}).
\end{itemize}\vspace*{-3pt}


\section{Motivation}
\label{sec:motiv}
It is well known that datatypes can be embedded into polymorphic lambda calculi
(e.g., \cite{AbeMatUus03}).  In System \textsf{F}, we can embed \emph{regular datatypes},
such as homogeneous lists:
\[\!\!\!\!\!\!\!\!\!
\begin{array}{ll}
\text{Haskell:} & \texttt{data List a = Nil | Cons a (List a)} \\
\text{System \textsf{F}:} & \texttt{{List}}\:\: A\:\:\triangleq\:\:\forall X.X\to(A\to X\to X)\to X ~~\;
\end{array}
\]
Note the use of the universally quantified type variable $X$
and the regularity of $(\texttt{List a})$ in the datatype definition.

In System \Fw, we can embed \emph{type-indexed datatypes}, which include
datatypes that are not regular. For example, we can embed powerlists with
heterogeneous elements where an element of type \texttt{a} is followed by
an element of type \texttt{(a,a)}:
\[
\begin{array}{ll}
\text{Haskell:} & \!\!\!\!\texttt{data Powl a = PNil | PCons a (Powl(a,a))} \\
\text{System \Fw:} & \!\!\!\!\texttt{{Powl}}\:\triangleq\:
\lambda A^{*}.\forall X^{*\to*}.\\ \qquad
& \qquad X A\to (A\to X(A\times A)\to X A)\to XA
\end{array}
\]
Note the non-regular occurrence \texttt{(Powl(a,a))} and
the use of the type constructor variable $X$ universally quantifying over
type constructors of kind $* -> *$.

\begin{figure}\noindent
\definecolor{shadecolor}{rgb}{1,0.9,0.7}
\!\!\!\!\!A functional language supporting term-indexed datatypes: \vspace*{-4.5pt}
\begin{lstlisting}[basicstyle={\ttfamily},language=Haskell]
data Nat = Z | S n
data Vec (a:*) {i:N} where
  VNil  : Vec a {Z}
  VCons : a -> Vec a {i} -> Vec a {S i}
\end{lstlisting}\noindent
\!\!\!System \Fi: \vspace*{-7pt}
\begin{multline*}\!\!\!\!\!\!\!
\texttt{{Vec}}\:\:\triangleq\:\:\lambda A^{*}.\lambda i^{\texttt{{N}}}.
\forall X^{\texttt{{Nat}}\to*}.\\
X\{\texttt{{Z}}\}\to
(\forall i^{\texttt{{Nat}}}.A\to X\{i\}\to X\{\texttt{{S}}\; i\})\to X\{i\}
\end{multline*}\vspace*{-10pt}
\caption{A Motivating Example: length-indexed lists}
\label{fig:motiv}
\end{figure}

What extensions to \Fw\ do we need to embed datatypes that are indexed by
terms (\texttt{Z}, \texttt{i}, \texttt{S i}), as well as types (\texttt{a}),
such as length-indexed lists (\verb|Vec a {i}|) in Figure \ref{fig:motiv}?
From the motivating example (Figure \ref{fig:motiv}), we learn that
the calculus would need four additional constructs:
index arrow kinds ($\texttt{{Nat}\ensuremath{\to}*}$),
index abstraction ($\lambda i^{\texttt{{Nat}}}.\cdots$),
index application ($X\{i\}$), and
index polymorphism ($\forall i^{\texttt{{Nat}}}.\cdots$).


