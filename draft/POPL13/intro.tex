\section{Introduction}
\label{sec:intro}

%% theoretical core language for languages supporting
%% non-regular datatypes (\eg, nested datatypes) and
%% indexed datatypes (\eg, GADTs), but not fully dependent types.
%% 
%% embed recursive datatypes by Church encoding and show strong normalization
%% for the logical fragment of such a language

The introduction of Generalized Algebraic Datatypes~(GADTs) to
functional languages such as Haskell and OCaml has popularized
the use of indexed datatypes as a light-weight, type-based mechanism
to raise the confidence of users that software systems maintain important
properties.  

A salient example is Guillemette's thesis~\cite{guillemetteThesis}
encoding the classic paper by~\citet{tal-toplas} completely
in Haskell. This impressive system embeds a multi-stage compiler, from
System~F all the way to typed assembly language using indexed types to
show that every stage preserves type information.
%
As such, it provides confidence but no guarantees.  Indeed, since in
Haskell the non-terminating computation can be assigned any type, it is in
principle possible that the type-preservation property is a consequence of
a non-terminating computation in the program code.

This drawback would be absent in an approach based on strongly normalizing
logical calculi; like System~\Fw, the higher-order
polymorphic lambda calculus, which is rich enough to express a wide
collection of data structures.  Unfortunately, the \emph{term-indexed
datatypes} that are necessary to support Guillemette's system are not
known to be expressible in System~\Fw.

In his CompCert system, Leroy~\cite{Leroy-Compcert-CACM} showed that the
much richer logical Calculus of Inductive Constructions~(CIC), which
constitutes the basis of the Coq proof assistant, is expressive enough to
guarantee type preservation, and more, between compiler stages.  This
approach, however, comes at a cost.  Programmers must learn to use both
dependent types and a new programming paradigm, programming by code
extraction.

Some natural questions thus arise: Is there an expressive system
supporting non-dependent indexed types, say sitting somewhere in between
\Fw\ and dependent calculi?  
Can one use non-dependent indexed types when they are all we
need?\marginpar{\bf MF: I don't understand the second question?}
Can one program, rather than extract code? 
The goal of this paper is to develop the theory necessary to begin
answering these and related questions.  

Our approach in this direction is to design a new foundational calculus,
System~\Fi, for functional programming languages with term-indexed
datatypes.  In a nutshell, System~\Fi is obtained by minimally extending
System~\Fw\ with type-indexed kinds.  Notably, this yields a logical
calculus that is expressive enough to embed non-dependent
\emph{term-indexed datatypes} and their eliminators. Our contributions in
this development are as follows.\vspace*{-5pt}
\begin{itemize}
\item 
  Identifying the features that are needed for a higher-order polymorphic
  $\lambda$-calculus to embed term-indexed datatypes~(\S\ref{sec:motiv}),
  in isolation from other features normally associated with such
  calculi~(e.g., general recursion, large elimination, dependent types).
  \vspace*{-1pt}
\item 
  The design of the calculus, System \Fi\ (\S\ref{sec:Fi}), and its use to
  study properties of languages with term-indexed datatypes, by embedding
  these into the calculus~(\S\ref{sec:data}).  For instance, one can use
  System~\Fi\ to prove that the Mendler-style eliminators
  for GADTs of~\cite{AhnShe11} are normalizing.
  \vspace*{-1pt}
\item 
  Showing that System~\Fi\ enjoys a simple erasure
  property~(\S\ref{ssec:erasure}) and inherits meta-theoretic
  results~(strong normalization and logical consistency) from well-known
  calculi~(System~\Fw\ and ICC) that enclose System~\Fi~(\S\ref{ssec:sn}).
\end{itemize}\vspace*{-3pt}


\section{Motivation}
\label{sec:motiv}
It is well known that datatypes can be embedded into polymorphic lambda
calculi by means of functional encodings~(e.g.,~\cite{AbeMatUus03}), such
as the Church and Boehm-Berarducci encodings.

In System~\textsf{F}, for instance, one can embed \emph{regular
datatypes}~\cite{BoehmBerarducci}, like homogeneous lists:
\[\!\!\!\!\!\!\!\!\!
\begin{array}{ll}
\text{Haskell:} & \texttt{data List a = Nil | Cons a (List a)} \\
\text{System \textsf{F}:} & \texttt{{List}}\:\: A\:\:\triangleq\:\:\forall X.X\to(A\to X\to X)\to X ~~\;
\end{array}
\]
In these, datatype constructors have algebraic structure that directly
translates into polymorphic operations on abstract types as encapsulated
by universal quantification.

In the more expressive System \Fw, one can encode more general
\emph{type-indexed datatypes} that go beyond the algebraic class.
For example, one can embed powerlists with
heterogeneous elements in which an element of type \texttt{a} is followed by
an element of the product type \texttt{(a,a)}:
\[
\begin{array}{ll}
\text{Haskell:} & \!\!\!\!\texttt{data Powl a = PNil | PCons a (Powl(a,a))} \\
\text{System \Fw:} & \!\!\!\!\texttt{{Powl}}\:\triangleq\:
\lambda A^{*}.\forall X^{*\to*}.\\ \qquad
& \qquad X A\to (A\to X(A\times A)\to X A)\to XA
\end{array}
\]
Note the non-regular occurrence (\texttt{Powl(a,a)}) in the definition of
(\texttt{Powl a}), and the use of universal quantification over
higher-order kinds.

%\begin{figure}\noindent
%\definecolor{shadecolor}{rgb}{1,0.9,0.7}
%\!\!\!\!\!A functional language supporting term-indexed datatypes: \vspace*{-4.5pt}
%\begin{lstlisting}[basicstyle={\ttfamily},language=Haskell]
%data Nat = Z | S n
%data Vec (a:*) {i:N} where
%  VNil  : Vec a {Z}
%  VCons : a -> Vec a {i} -> Vec a {S i}
%\end{lstlisting}\noindent
%\!\!\!System \Fi: \vspace*{-7pt}
%\begin{multline*}\!\!\!\!\!\!\!
%\texttt{{Vec}}\:\:\triangleq\:\:\lambda A^{*}.\lambda i^{\texttt{{N}}}.
%\forall X^{\texttt{{Nat}}\to*}.\\
%X\{\texttt{{Z}}\}\to
%(\forall i^{\texttt{{Nat}}}.A\to X\{i\}\to X\{\texttt{{S}}\; i\})\to X\{i\}
%\end{multline*}\vspace*{-10pt}
%\caption{A Motivating Example: length-indexed lists}
%\label{fig:motiv}
%\end{figure}

What about term-indexed datatypes?  What extension to System~\Fw\ is
needed to embed these, as well as type-indexed ones?  Our answer is
System~\Fi.

In a functional language supporting term-indexed datatypes, we envisage
that the classic example of homogeneous length-indexed lists would be
defined along the following lines:
\begin{lstlisting}[basicstyle={\ttfamily},language=Haskell]
 data Nat = Z | S Nat
 data Vec (a:*) {i:Nat} where
   VNil  : Vec a {Z}
   VCons : a -> Vec a {i} -> Vec a {S i}
\end{lstlisting}\noindent
Here the type constructor~{\tt Vec} is defined to admit parameterisation
by both type and term indices.  For instance, the type 
(\verb|Vec (List Nat) {S S Z}|) is that of two-di\-men\-sion\-al
vectors of lists of natural numbers.  By design, our syntax directly
reflects the different type and term indexing by indicating the latter in
curly brackets.  This feature has been directly transferred from
System~\Fi, where it is used as a mechanism for guaranteeing the static
nature of term indexing.

The encoding of the vector datatype in System~\Fi\ is as follows: 
\vspace*{-5pt}
\begin{multline*}\!\!\!\!\!\!\!
\texttt{{Vec}}\:\:\triangleq\:\:\lambda A^{*}.\lambda i^{\texttt{{Nat}}}.
\forall X^{\texttt{{Nat}}\to*}.\\
X\{\texttt{{Z}}\}\to
(\forall j^{\texttt{{Nat}}}.A\to X\{j\}\to X\{\texttt{{S}}\; j\})\to X\{i\}
\end{multline*}
Without going into the details of the formalism, which are given in the
next section, one sees that such a calculus incorporating term-indexing
structure needs four additional constructs.
\begin{enumerate}
\item 
  Type-indexed kinding~$A\to\kappa$ (as $\texttt{{Nat}\ensuremath{\to}*}$
  in the example above) where the compile-time nature of term-indexing
  will be reflected in the enforcement that $A$ be a closed type~(see
  rule~$(Ri)$ in \Fig{Fi}).
\item 
  Term-index abstraction~$\lambda i^A.F$~(as $\lambda
  i^{\texttt{{Nat}}}.\cdots$ in the example above) for constructing (or
  introducing) type-indexed kinds~(see rule~$(\lambda i)$ in
  \Fig{Fi}).  
\item 
  Term-index application~$F\{s\}$ (as $X\{{\tt Z}\}$, $X\{j\}$, and
  $X\{\texttt{S}\;j\}$ in the example above) for destructing (or
  eliminating) type-indexed kinds~(see rule~$(@i)$ in \Fig{Fi}). 
\item 
  Term-index polymorphism~$\forall i^A.B$ (as $\forall
  j^{\texttt{{Nat}}}.\cdots$ in the example above) where the compile-time
  nature of polymorphic term-indexing will be reflected in the enforcement
  that the variable~$i$ be static of closed type~$A$.
\end{enumerate}

\textbf{MF: I'll try to add something about erasure here a bit later on}

