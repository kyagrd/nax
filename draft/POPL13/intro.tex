\section{Introduction}
\label{sec:intro}

%% theoretical core language for languages supporting
%% non-regular datatypes (\eg, nested datatypes) and
%% indexed datatypes (\eg, GADTs), but not fully dependent types.
%% 
%% embed recursive datatypes by Church encoding and show strong normalization
%% for the logical fragment of such a language

The introduction of Generalized Algebraic Datatypes~(GADTs) to
functional languages such as Haskell and OCaml has popularized
the use of indexed datatypes as a light-weight, type-based mechanism
to raise the confidence of users that software systems maintain important
properties.  

A salient example is Guillemette's thesis~\cite{guillemetteThesis}
encoding the classic paper by~\citet{tal-toplas} completely
in Haskell. This impressive system embeds a multi-stage compiler, from
System~F all the way to typed assembly language using indexed types to
show that every stage preserves type information.
%
As such, it provides confidence but no guarantees.  Indeed, since in
Haskell the non-terminating computation can be assigned any type, it is in
principle possible that the type-preservation property is a consequence of
a non-terminating computation in the program code.

This drawback would be absent in an approach based on strongly normalizing
logical calculi; like System~\Fw, the higher-order
polymorphic lambda calculus, which is rich enough to express a wide
collection of data structures.  Unfortunately, the \emph{term-indexed
datatypes} that are necessary to support Guillemette's system are not
known to be expressible in System~\Fw.

In his CompCert system, Leroy~\cite{Leroy-Compcert-CACM} showed that the
much richer logical Calculus of Inductive Constructions~(CIC), which
constitutes the basis of the Coq proof assistant, is expressive enough to
guarantee type preservation, and more, between compiler stages.  This
approach, however, comes at a cost.  Programmers must learn to use both
dependent types and a new programming paradigm, programming by code
extraction.

Some natural questions thus arise: Is there an expressive system
supporting non-dependent indexed types, say sitting somewhere in between
\Fw\ and dependent calculi?  
Can one use non-dependent indexed types when they are all we
need?\marginpar{\bf MF: I don't understand the second question?}
Can one program, rather than extract code? 
The goal of this paper is to develop the theory necessary to begin
answering these and related questions.  

Our approach in this direction is to design a new foundational calculus,
System~\Fi, for functional programming languages with term-indexed
datatypes.  In a nutshell, System~\Fi is obtained by minimally extending
System~\Fw\ with type-indexed kinds.  Notably, this yields a logical
calculus that is expressive enough to embed non-dependent
\emph{term-indexed datatypes} and their eliminators. Our contributions in
this development are as follows.\vspace*{-5pt}
\begin{itemize}
\item 
  Identifying the features that are needed for a higher-order polymorphic
  $\lambda$-calculus to embed term-indexed datatypes~(\S\ref{sec:motiv}),
  in isolation from other features normally associated with such
  calculi~(e.g., general recursion, large elimination, dependent types).
  \vspace*{-1pt}
\item 
  The design of the calculus, System \Fi\ (\S\ref{sec:Fi}), and its use to
  study properties of languages with term-indexed datatypes, by embedding
  these into the calculus~(\S\ref{sec:data}).  For instance, one can use
  System~\Fi\ to prove that the Mendler-style eliminators
  for GADTs of~\cite{AhnShe11} are normalizing.
  \vspace*{-1pt}
\item 
  Showing that System~\Fi\ enjoys a simple erasure
  property~(\S\ref{ssec:erasure}) and inherits meta-theoretic
  results~(strong normalization and logical consistency) from well-known
  calculi~(System~\Fw\ and ICC) that enclose System~\Fi~(\S\ref{ssec:sn}).
\end{itemize}\vspace*{-3pt}


\section{Motivation}
\label{sec:motiv}
It is well known that datatypes can be embedded into polymorphic lambda calculi
(e.g., \cite{AbeMatUus03}) using
functional encodings such as the Church encoding.
In System \textsf{F}, we can embed \emph{regular datatypes},
such as homogeneous lists:
\[\!\!\!\!\!\!\!\!\!
\begin{array}{ll}
\text{Haskell:} & \texttt{data List a = Nil | Cons a (List a)} \\
\text{System \textsf{F}:} & \texttt{{List}}\:\: A\:\:\triangleq\:\:\forall X.X\to(A\to X\to X)\to X ~~\;
\end{array}
\]
Note the use of the universally quantified type variable $X$
and the regularity of $(\texttt{List a})$ in the datatype definition.

In System \Fw, we can embed \emph{type-indexed datatypes}, which include
datatypes that are not regular. For example, we can embed powerlists with
heterogeneous elements where an element of type \texttt{a} is followed by
an element of type \texttt{(a,a)}:
\[
\begin{array}{ll}
\text{Haskell:} & \!\!\!\!\texttt{data Powl a = PNil | PCons a (Powl(a,a))} \\
\text{System \Fw:} & \!\!\!\!\texttt{{Powl}}\:\triangleq\:
\lambda A^{*}.\forall X^{*\to*}.\\ \qquad
& \qquad X A\to (A\to X(A\times A)\to X A)\to XA
\end{array}
\]
Note the non-regular occurrence \texttt{(Powl(a,a))} and
the use of the type constructor variable $X$ universally quantifying over
type constructors of kind $* -> *$.

\begin{figure}\noindent
\definecolor{shadecolor}{rgb}{1,0.9,0.7}
\!\!\!\!\!A functional language supporting term-indexed datatypes: \vspace*{-4.5pt}
\begin{lstlisting}[basicstyle={\ttfamily},language=Haskell]
data Nat = Z | S n
data Vec (a:*) {i:N} where
  VNil  : Vec a {Z}
  VCons : a -> Vec a {i} -> Vec a {S i}
\end{lstlisting}\noindent
\!\!\!System \Fi: \vspace*{-7pt}
\begin{multline*}\!\!\!\!\!\!\!
\texttt{{Vec}}\:\:\triangleq\:\:\lambda A^{*}.\lambda i^{\texttt{{N}}}.
\forall X^{\texttt{{Nat}}\to*}.\\
X\{\texttt{{Z}}\}\to
(\forall i^{\texttt{{Nat}}}.A\to X\{i\}\to X\{\texttt{{S}}\; i\})\to X\{i\}
\end{multline*}\vspace*{-10pt}
\caption{A Motivating Example: length-indexed lists}
\label{fig:motiv}
\end{figure}

What extensions to \Fw\ do we need to embed datatypes that are indexed by
terms (such as \texttt{Z}, \texttt{i}, and \texttt{S i}), as well as indexed by types (\texttt{a})?
The classical example of such a type is the length-indexed lists
(\verb|Vec a {i}|) outlined in Figure \ref{fig:motiv}.
From this motivating example, we learn that
the calculus would need four additional constructs:
\begin{itemize}
\item index arrow kinds ($\texttt{{Nat}\ensuremath{\to}*}$),
\item index abstraction ($\lambda i^{\texttt{{Nat}}}.\cdots$),
\item index application ($X\{i\}$), and
\item index polymorphism ($\forall i^{\texttt{{Nat}}}.\cdots$).
\end{itemize}


