\section{Introduction}
During the past decade, the functional programming community achieved
partial success in their goal of maintaining fine-grained properties
by moderate extensions to the type system of functional languages
\cite{CheHin03,CheHin02,Xi03}.
This approach is often called \emph{``lightweight''}\footnote{e.g.,
  \url{http://okmij.org/ftp/Computation/lightweight-dependent-typing.html} }
in contrast to proof assistant based on a fullly dependent types
(\eg, Coq, Agda).
The Generalized Algebraic Data Type (GADT) extension implemented
in the Glasgow Haskell Compiler (GHC) has promoted the lightweight approach
widely avialibe to everyday functional programming tasks.
OCaml encodings of GADTs has been reported \cite{ManStu09}
and recent versions of OCaml supports GADTs natively \cite{GarNor11}.

Unfortunately, most practical language implementations that support
the lightweight approach lack \textbf{logical consistency} and
\textbf{type inference}. In addition, they often lack term indexing,
so \textbf{term indices are faked} (or, simulated) by additional
type structure replicating the requisite term structure.
A recent extension in GHC, datatype promotion \cite{YorgeyWCJVM12},
attempts to address the issue of term indices, but the issues of
logical consistency and type inference still remain.

Nax is a programming language designed to support indexed datatypes,
while resolving all the three issues mentioned above.
More specifically,
\begin{description}
\item[$(1)$ Nax is strongly normalizing and logically consistent.]~\\
Types in Nax can be given logical interpretations as propositions
and the programs of those types as proofs of those propositions.
Background theories behind strong normalization and logical consistency of Nax
are Mendler-style recursion \cite{AhnShe11} and System \Fi\ (to be published).

\item[$(2)$ Nax supports Hindley--Milner-style type inference.]~\\
Type annotations are only required in the GADT declarations and
the index transformers attached to Mendler-style recursion combinators
(for recursive cases) and case expressions (for non-recursive cases).
Nax does not need annotations for every top-level functions, which are usually
required for bidirectional type checking in dependently typed proof assistants.

\item[$(3)$ Nax programs are expressive and concise.]~\\
Nax programs are similar in size to their Haskell and Agda equivalents
(Sect.\;\ref{sec:example}), yet they still retain logical consistency
and type inference. Despite the features unique to Nax
(Table\;\ref{tbl:naxfeatures}), it does not necessary add verbosity.

\item[$(4)$ Nax supports term indices within a relatively simple type system.]
The type system of Nax (Sect.\;\ref{ssec:sorting}) is based on
two sorted universes ($\star$ and $\square$), just like Haskell,
yet it can express deeply indexed datatypes (Sect.\;\ref{ssec:sortingEx})
used in dependently typed languages, which are based on countably many
stratified universes ($\star_1,\star_2,\dots$).
\end{description}
The detailed mechanism behind (1) and (2) above are beyond of the scope of
this paper, to be discussed in sequel publications and Ki Yung's dissertation.
In this article, we demonstrate that programming with indexed datatypes in Nax
is as handy as in Haskell or Agda, going through a series of examples --
a type preserving evaluator (Sect.\;\ref{ssec:eval}),
a generic path datatype (Sect.\;\ref{ssec:glist}), and
a stack safe compiler (Sect.\;\ref{ssec:compile}).
Then, we discuss the key design principles behind indexed datatypes in Nax
(Sect.\;\ref{ssec:sorting}) and its strength and limitations
(Sect.\;\ref{ssec:sortingEx}).

