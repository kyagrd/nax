\section{System \Fi}
\label{sec:Fi}
System \Fi\ is a higher-order polymorphic lambda calculus with term indices.
In other words, System \Fi\ is an extension of System \Fw\ by term indices.
The complete syntax and rules of \Fi\ are described in \Fig{Fi} and
\Fig{eqFi}. The syntax and rules highlighted by \newFi{\text{grey boxes}}
are the extensions new to \Fi, which are not originally part of \Fw.
That is, the system we obtain by excluding all the grey boxes from \Fig{Fi}
and \Fig{eqFi} is a version of \Fw. In particular, it is a version of \Fw\
with Curry style terms and typing contexts separated into two zones
(\ie, type level and term level). Terms are Curry style. That is,
term level abstractions are unannotated ($\lambda x.t$), and
type generalization ($\forall I$) and type instantiation ($\forall E$) are
implicit at term level. Types remain Church style as usual. That is,
type level abstractions are annotated by kinds ($\lambda X^\kappa.F$).
Typing contexts are separated into type level contexts ($\Delta$) and
term level contexts ($\Gamma$). We expect readers to be familiar to \Fw\
and focus on describing new constructs of \Fi, which are in grey boxes.

\begin{figure}
\begin{framed}
\paragraph{Syntax:}
\begin{align*}
\!\!\!\!\!\!\!\!&\text{Kinds}
 	& \kappa		&~ ::= ~ *
				\mid \kappa -> \kappa
				\mid \newFi{A -> \kappa}
\\
\!\!\!\!\!\!\!\!&\text{Type Constructors}
	& A,B,F,G		&~ ::= ~ X
				\mid \lambda X^\kappa.F
				\mid \newFi{\lambda i^A.F}
				\mid F\,G
				\mid \newFi{F\,\{s\}}
				\mid A -> B
				\mid \forall X^\kappa . B
				\mid \newFi{\forall i^A . B}
\\
\!\!\!\!\!\!\!\!&\text{Terms}
	& r,s,t			&~ ::= ~ x \mid \newFi{i}
                                \mid \lambda x.t \mid r\;s
\\
\!\!\!\!\!\!\!\!&\text{Typing Contexts}
	& \Delta		&~ ::= ~ \cdot
				\mid \Delta, X^\kappa
				\mid \newFi{\Delta, i^A} \\
&	& \Gamma		&~ ::= ~ \cdot
				\mid \Gamma, x : A
\end{align*}

\paragraph{Well-formed typing contexts:}
\[ \fbox{$|- \Delta$}
 ~~~~ ~~~~
   \inference{}{|- \cdot}
 ~~~~
   \inference{|- \Delta & \Delta |- \kappa:\square}
             {|- \Delta,X^\kappa}
      \big( X\notin\dom(\Delta) \big)
 ~~~~ \newFi{
   \inference{|- \Delta & \cdot |- A:*}
             {|- \Delta,i^A}
      \big( i\notin\dom(\Delta) \big) }
\]
\[ \fbox{$\Delta |- \Gamma$}
 ~~~~
   \inference{|- \Delta}{\Delta |- \cdot}
 ~~~~
   \inference{\Delta |- \Gamma & \Delta |- A:*}
             {\Delta |- \Gamma,x:A}
      \big( x\notin\dom(\Gamma) \big)
\]


\paragraph{Sorting:} \fbox{$|- \kappa : \square$}
\[ \inference[($A$)]{}{|- *:\square}
 ~~~~
   \inference[($R$)]{|- \kappa:\square & |- \kappa':\square}
                    {|- \kappa -> \kappa' : \square}
 ~~~~
   \newFi{
   \inference[($Ri$)]{\cdot |- A:* & |- \kappa:\square}
                     {|- A -> \kappa : \square} }
\]

\paragraph{Kinding:} \fbox{$\Delta |- F : \kappa$}
\[ \inference[($Var$)]{X^\kappa\in\Delta & |- \Delta}
                       {\Delta |- X : \kappa}
 ~~~~ \newFi{
   \inference[($Conv$)]{ \Delta |- A : \kappa
                       & \Delta |- \kappa = \kappa' : \square }
                       {\Delta |- A : \kappa'} }
\]
\[
  \inference[($\lambda$)]{|- \kappa:\square & \Delta,X^\kappa |- F : \kappa'}
                          {\Delta |- \lambda X^\kappa.F : \kappa -> \kappa'}
 ~~~~
   \inference[($@$)]{ \Delta |- F : \kappa -> \kappa'
                    & \Delta |- G : \kappa }
                    {\Delta |- F\,G : \kappa'}
\]
\[ \newFi{
  \inference[($\lambda i$)]{\cdot |- A:* & \Delta,i^A |- F : \kappa}
                            {\Delta |- \lambda i^A.F : A->\kappa} }
 ~~~~ \newFi{
   \inference[($@i$)]{ \Delta |- F : A -> \kappa
                     & \Delta;\cdot |- s : A }
                     {\Delta |- F\,\{s\} : \kappa} }
\]
\[ \inference[($->$)]{\Delta |- A : * & \Delta |- B : *}
                     {\Delta |- A -> B : * }
 ~~~~
   \inference[($\forall$)]{|- \kappa:\square & \Delta, X^\kappa |- B : *}
                          {\Delta |- \forall X^\kappa . B : *}
 ~~~~ \newFi{
   \inference[($\forall i$)]{\cdot |- A:* & \Delta, i^A |- B : *}
                            {\Delta |- \forall i^A . B : *} }
\]

\paragraph{Typing:} \fbox{$\Delta;\Gamma |- t : A$}
\[ \inference[($:$)]{x:A \in \Gamma & \Delta |- \Gamma} 
                    {\Delta;\Gamma |- x:A}
 ~~~~ \newFi{
   \inference[($:i$)]{i^A \in \Delta & \Delta |- \Gamma} 
                     {\Delta;\Gamma |- i:A} }
 ~~~~
   \inference[($=$)]{\Delta;\Gamma |- t : A & \Delta |- A = B : *}
                    {\Delta;\Gamma |- t : B}
\]
\[
   \inference[($->$$I$)]{\Delta |- A:* & \Delta;\Gamma,x:A |- t : B}
                        {\Delta;\Gamma |- \lambda x.t : A -> B}
 ~~~~ ~~~~
   \inference[($->$$E$)]{\Delta;\Gamma |- r : A -> B & \Delta;\Gamma |- s : A}
                        {\Delta;\Gamma |- r\;s : B}
\]
\[ \inference[($\forall I$)]{|- \kappa:\square & \Delta, X^\kappa;\Gamma |- t : B}
                            {\Delta;\Gamma |- t : \forall X^\kappa.B}
			    (X\notin\FV(\Gamma))
 ~~~~ ~~~~
   \inference[($\forall E$)]{ \Delta;\Gamma |- t : \forall X^\kappa.B
                            & \Delta |- G:\kappa }
                            {\Delta;\Gamma |- t : [G/X]B}
\]
\[ \newFi{
   \inference[($\forall I i$)]{\cdot |- A:* & \Delta, i^A;\Gamma |- t : B}
                              {\Delta;\Gamma |- t : \forall i^A.B}
   \left(\begin{matrix}
		i\notin\FV(t),\\
		i\notin\FV(\Gamma)\end{matrix}\right) }
 ~~~~ \newFi{
   \inference[($\forall E i$)]{ \Delta;\Gamma |- t : \forall i^A.B
                              & \Delta;\cdot |- s:A}
                              {\Delta;\Gamma |- t : [s/i]B} }
\]
\end{framed}
\caption{Syntax and Typing rules of \Fi}
\label{fig:Fi}
\end{figure}

\begin{figure}
\begin{framed}
\paragraph{Kind equality:} \fbox{$|- \kappa=\kappa' : \square$}
\[ \inference{}{|- * = *:\square}
 ~~~~
   \inference{ |- \kappa_1 = \kappa_1' : \square
             & |- \kappa_2 = \kappa_2' : \square }
             {|- \kappa_1 -> \kappa_2 = \kappa_1' -> \kappa_2' : \square}
 ~~~~ \newFi{
   \inference{\cdot |- A=A':* & |- \kappa=\kappa':\square}
             {|- A -> \kappa = A' -> \kappa' : \square} }
\]
\[ \inference{|- \kappa=\kappa':\square}
             {|- \kappa'=\kappa:\square}
 ~~~~
   \inference{ |- \kappa =\kappa' :\square
             & |- \kappa'=\kappa'':\square}
             {|- \kappa=\kappa'':\square}
\]
~\\
\paragraph{Type constructor equality:} \fbox{$\Delta |- F = F' : \kappa$}
\[ \inference{\Delta |- X:\kappa }{\Delta |- X=X:\kappa}
 ~~~~
   \inference{\Delta,X^\kappa |- F:\kappa & \Delta |- G:\kappa}
             {\Delta |- (\lambda X^\kappa.F)\,G = [G/X]F:\kappa'}
 ~~~~ \newFi{
   \inference{\Delta,i^A |- F:\kappa & \Delta;\cdot |- s:A}
             {\Delta |- (\lambda i^A.F)\,\{s\} = [s/x]F:\kappa} }
\]
\[ \inference{|- \kappa:\square & \Delta,X^\kappa |- F=F' : \kappa'}
             {\Delta |- \lambda X^\kappa.F=\lambda X^\kappa.F':\kappa-> \kappa'}
 ~~~~
   \inference{\Delta |- F=F':\kappa->\kappa' & \Delta |- G=G':\kappa}
             {\Delta |- F\,G = F'\,G' : \kappa'}
\]
 ~~~~
\[ \newFi{
   \inference{\cdot |- A:* & \Delta,i^A |- F=F' : \kappa}
             {\Delta |- \lambda i^A.F=\lambda i^A.F' : A -> \kappa} }
 ~~~~ \newFi{
   \inference{\Delta |- F=F':A->\kappa & \Delta;\cdot |- s=s':A}
             {\Delta |- F\,\{s\} = F'\,\{s'\} : \kappa} }
\]
\[ \inference{|- \kappa:\square & \Delta,X^\kappa |- B=B':*}
             {\Delta |- \forall X^\kappa.B=\forall X^\kappa.B':*}
 ~~~~ \newFi{
   \inference{\cdot |- A:* & \Delta,i^A |- B=B':*}
             {\Delta |- \forall i^A.B=\forall i^A.B':*} }
\]
\[ \inference{\Delta |- A=A':* & \Delta |- B=B':*}{\Delta |- A-> B=A'-> B':*}
 ~~~~
   \inference{\Delta |- F = F' : \kappa}{\Delta |- F' = F : \kappa}
 ~~~~
   \inference{\Delta |- F = F' : \kappa & \Delta |- F' = F'' : \kappa}
             {\Delta |- F = F'' : \kappa}
\]
~\\
\paragraph{Term equality:} \fbox{$\Delta;\Gamma |- t = t' : A$}
\[ \inference{\Delta;\Gamma |- x:A}{\Delta;\Gamma |- x=x:A}
 ~~~~
   \inference{\Delta;\Gamma,x:A |- t:B & \Delta;\Gamma |- s:A}
             {\Delta;\Gamma |- (\lambda x.t)s=[s/x]t : B}
\]
\[ \inference{\Delta |- A:* & \Delta;\Gamma,x:A |- t=t':B}
             {\Delta;\Gamma |- \lambda x.t = \lambda x.t'\;s':B}
 ~~~~
   \inference{\Delta;\Gamma |- r=r':A-> B & \Delta;\Gamma |- s=s':A}
             {\Delta;\Gamma |- r\;s=r'\;s':B}
\]
\[ \inference{\Delta;\Gamma |- t=t':A}{\Delta;\Gamma |- t'=t:A}
 ~~~~
   \inference{\Delta;\Gamma |- t=t':A & \Delta;\Gamma |- t'=t'':A}
             {\Delta;\Gamma |- t=t'':A}
\]
\[ \inference{|- \kappa:\square & \Delta, X^\kappa;\Gamma |- t=t' : B}
             {\Delta;\Gamma |- t=t' : \forall X^\kappa.B}
	     (X\notin\FV(\Gamma))
 ~~~~ ~~~~
   \inference{ \Delta;\Gamma |- t=t' : \forall X^\kappa.B
             & \Delta |- G:\kappa }
             {\Delta;\Gamma |- t=t' : [G/X]B}
\]
\[ \newFi{
   \inference{\cdot |- A:* & \Delta, i^A;\Gamma |- t=t' : B}
             {\Delta;\Gamma |- t=t' : \forall i^A.B}
   \left(\begin{smallmatrix}
		i\notin\FV(t),\\
		i\notin\FV(t'),\\
		i\notin\FV(\Gamma)\end{smallmatrix}\right) }
 ~~~~ \newFi{
   \inference{ \Delta;\Gamma |- t=t' : \forall i^A.B
             & \Delta;\cdot |- s:A}
             {\Delta;\Gamma |- t=t' : [s/x]B} }
\]
~\\
\paragraph{Reduction:} \fbox{$t \rightsquigarrow t'$}
$ \inference{}{(\lambda x.t)\,s \rightsquigarrow [s/x]t}
 ~~~~
   \inference{t \rightsquigarrow t'}{\lambda x.t \rightsquigarrow \lambda x.t'}
 ~~~~
   \inference{r \rightsquigarrow r'}{r\;s \rightsquigarrow r'\;s}
 ~~~~
   \inference{s \rightsquigarrow s'}{r\;s \rightsquigarrow r\;s'}
$
\end{framed}
\caption{Equality rules and Reduction rules for \Fi}
\label{fig:eqFi}
\end{figure}

\subsection{The constructs new to \Fi}

\paragraph{Typing contexts}
Typing contexts are split into two zones:
type level contexts ($\Delta$) for type level bindings
and term level contexts ($\Gamma$) for term level bindings.
We have a new form of index variable bindings ($i^A$) that can appear in
type level contexts in addition to type variable bindings ($X^\kappa$).
There is only one form of term level binding ($x:A$) that can appear in
term level contexts.

A type level context $\Delta$ is well-formed when it is either empty,
extended by a type variable binding $X^\kappa$ whose kind $\kappa$ is
well-sorted under $\Delta$, or extended by an index binding $i^A$
whose type $A$ is well-kinded under the empty type level context.
Similarly to the well-sorted rule ($Ri$) for indexed arrow kinds,
we require $A$ of $i^A$ to be well-kinded in the empty type level context
($\cdot$), since no bindings are introduced at kind level in \Fi.

A term level context $\Gamma$ is well-formed under a type level contexts
$\Delta$ when it is either empty or extended by a term variable binding
$x:A$ whose type $A$ is well-kinded under $\Delta$.


\paragraph{Kinds and their sorting rules}
We extend the kind syntax of \Fw\ by indexed arrow kinds of the form
\newFi{A -> \kappa}. The formation of indexed arrow kinds is
governed by the sorting rule \newFi{(Ri)}. The rule $(Ri)$ specifies that
an indexed arrow kind $A -> \kappa$ is well-sorted when $A$ is well-kinded
under the empty type level context ($\cdot$) and $\kappa$ is well-sorted.
We avoid dependent kinds (\ie, kinds depending on type level or value level
bindings) by requiring $\cdot |- A$. The type $A$ appearing in
the index arrow kind $A -> \kappa$ must be well-kinded under
the empty type level context ($\cdot$), since no bindings are
introduced at kind level in \Fi.

\paragraph{Type constructors and their kinding rules}
We extend the type constructor syntax by three constructs,
and extend the kinding rules accordingly for these new constructs.

\newFi{\lambda i^A.F} is the type level abstraction over an index
(or, index abstraction). Index abstractions introduce indexed arrow kinds
by the kinding rule \newFi{(\lambda i)}. Note, we have a new form of binding
$i^A$ in the kinding rule ($\lambda i$).
We will explain what this binding means when we discuss contexts.

\newFi{F\,\{s\}} is the type level index application. In contrast to
the ordinary type level application ($F\,G$) whose argument being applied is
a type constructor ($G$), the argument of the index application ($F\,\{s\}$) is
a term ($s$). We use the curly bracket notation around the index argument to
emphasize the distinction from ordinary type arguments and also to emphasize
that $s$ is an index term, which is erasable. Index applications eliminate
indexed arrow kinds by the kinding rule \newFi{(@i)}. Note, we type check
the index term ($s$) under the current type level context paired with
the empty term level context ($\Delta;\cdot$) since we do not want
the index term ($s$) to depend on any term level bindings.

\newFi{\forall i^A . B} is an index polymorphic type.
The formation of indexed polymorphic types is governed by
the kinding rule \newFi{\forall i}, which is very similar to
the formation rule ($\forall$) for ordinary polymorphic types.

In addition to the rules ($\lambda i$), ($@ i$), and ($\forall i$),
we need a conversion rule \newFi{(Conv)} at kind level. This is because
the new extension to the kind syntax $A -> \kappa$ involves types.
Since kind syntax involves types, we need more than simple structural
equality over kinds. The equality over kinds is the usual structural
equality extended by type equality when comparing indexed arrow kinds
(see \Fig{eqFi}).

\paragraph{Terms and their typing rules}
The term syntax is extended by index variables (\newFi{i}), since terms used
as indices may have index variables as well as term variables
(\eg, $\lambda i^A.F\{(\lambda x.x\;i)\,(\lambda x.x)\}$).
The term variables ($x$) are introduced from
term level abstractions ($\lambda x.t$).
The index variables ($i$) are introduced from
index abstraction ($\lambda i^A.F$) and
index polymorphic types ($\forall i^A.B$). However, the distinction between
$x$ and $i$ is in fact only a convention for the convenience of readability.
An equivalent but more succinct description of the system would be possible
by having only $x$ for both term and index variables instead of having two
kinds of variables $x$ and $i$.

Since \Fi\ has index polymorphic types ($\forall i^A . B$),
we need typing rules for index polymorphism:
\newFi{(\forall I i)} for index generalization
and \newFi{(\forall E i)} for index instantiation.

The index generalization rule ($\forall I i$) is similar to
the type generalization rule ($\forall I$), except the additional
side condition $\big(i\notin\FV(t)\big)$. This side condition prevents
terms from accessing the type level index variables introduced by index
polymorphism. Otherwise, without this side condition, $\forall$-binder
would be no longer behave as polymorphism but powerful enough to behave as
dependent functions, which are usually denoted by the $\Pi$-binder in
dependent type theories. The side condition on generalization rules
for polymorphism is fairly standard in dependently typed languages supporting
distinctions between polymorphism (or, erasable arguments) and
dependent functions (\eg, IPTS[TODO cite Nathans' thesis], ICC[TODO cite]).
The rule ($\forall I$) for ordinary type generalization rule does not need
a side condition because type variables cannot appear in the syntax of terms.

The index instantiation rule ($\forall E i$) is similar to
the type instantiation rule ($\forall E i$), except that
we type check the index term $s$ to be instantiated for $i$
in the current type level context paired with the empty term level context
($\Delta;\cdot$) rather than the current term level context.
Since index terms are at type level, they should not depend on
term level bindings.

In addition to the rules ($\forall I i$) and ($\forall E i$) for
index polymorphism, we need an additional variable rule \newFi{(:i)}
to be able to access the index variables already in scope. Terms ($s$) used
at type level in index applications ($F\{s\}$) should be able to access
index variables already in scope. For example, $\lambda i^A.F\{i\}$ should be
well-kinded under a context where $F$ is well-kinded,
justified by the following derivation:
\[ \inference[($\lambda i$)]
      { \cdot |- A:* &
	\inference[($@i$)]{ \Delta, i^A |- F : A -> \kappa
                          & \inference[($:i$)]{ i^A\in \Delta,i^A
                                              & \Delta |- \cdot }
                                              {\Delta,i^A;\cdot |- i:A}
                          }
                          {\Delta, i^A |- F\{i\} : \kappa} }
      {\Delta |- \lambda i^A.F\{i\} :\kappa}
\]



\subsection{Metatheory?}

Before go on we prove subjected reduction and strong normalization, we need to
check some basic well-formedness properties for the derivations of \Fi.
We want to show that the sorting, kinding, and typing derivations give
well-formed results under well-formed contexts. That is, sorting derivations
result in well-formed sorts (Proposition \ref{prop:wfsort}),
kinding derivations result in well-sorted kinds under well-formed
type level contexts (Proposition \ref{prop:wfkind}), and typing derivations
result in well-kinded types under well-formed type and term level contexts
(Proposition \ref{prop:wftype}).

Since the definitions of sorting, kinding, and typing rules are
mutually recursive, these three properties should really be considered as
one big property (illustrated below) in order to be more rigorous about
the induction principle used in the proof.
\begin{proposition*}[The big well-formedness propoerty of \Fi,
		roughly\footnote{Technically,
    this is not yet completely rigorous since there are three more forms of
    judgments in the mutually recursive definition. The \emph{kind equality},
    \emph{type equality}, and \emph{term equality} rules are part of
    the mutually recursive definition along with the sorting, kinding, and
    typing rules. So, the complete description of the big well-formedness
    property will consist of six cases, which correspond to
    Proposition \ref{prop:wfsort}, Proposition \ref{prop:wfkind},
    Proposition \ref{prop:wftype}, Lemma \ref{lem:wfeqkind},
    Lemma \ref{lem:wfeqtype}, and Lemma \ref{lem:wfeqterm}.  }  ]~
\begin{quote}
\begin{itemize}
\item[case] \fbox{$ |- \kappa : \square $}\qquad\quad
 $ \inference{ |- \kappa : \mathfrak{s} }{ \mathfrak{s}=\square } $
 \qquad\qquad\qquad~~ \text{(corresponds to Proposition \ref{prop:wfsort})} \\
\item[case] \fbox{$ \Delta |- F : \kappa $}\qquad\quad
 $ \inference{ |- \Delta & \Delta |- F : \kappa}{ |- \kappa:\square } $
 \qquad \text{(corresponds to Proposition \ref{prop:wfkind})}\\
\item[case] \fbox{$ \Delta;\Gamma |- t:A $}\quad
 $ \inference{ \Delta |- \Gamma & \Delta;\Gamma |- t : A}{ \Delta |- A : * } $
 \qquad \text{(corresponds to Proposition \ref{prop:wftype})}\\
\end{itemize}
\end{quote}
\end{proposition*}\noindent
The big well-formedness property about derivations for a judgment,
which can be either one of the three forms --
\fbox{$ |- \kappa : \square $} (sorting),
\fbox{$ \Delta |- F : \kappa $} (kinding), and
\fbox{$ \Delta;\Gamma |- t:A $} typing.
That is, a derivation for a judgment of either sorting, kinding, or typing
results in either a well-formed sort (when it is a sorting judgment),
a well-sorted kind (when it is a kinding judgment), or
a well-kinded type (when it is a typing judgment),
under well-formed contexts for the judgment (no context for sorting judgments,
$\Delta$ for kinding judgments, and $\Delta;\Gamma$ for typing judgments).
We can prove the big well-formedness property of \Fi\ by induction on
the derivation of a judgment, which can be either one of the three forms.
Here, I illustrate the proof for the three propositions as if they were
separate proofs. During the proof description, the proof for each proposition
references the other properties (which is yet another application of the
induction hypothesis of the big well-formedness property), since it gives
more intuitive proof sketch that way. So, when I say ``by induction''
during the proofs, what I really mean is the induction hypothesis of
the big well-formedness property.

\begin{proposition}[sorting derivations result in well-formed sorts]
\label{prop:wfsort}
$ \inference{ |- \kappa : \mathfrak{s} }{ \mathfrak{s}=\square } $
\end{proposition}
\begin{proof}Obvious since $\square$ is the only sort in \Fi.\end{proof}

\begin{proposition}[kinding derivations under well-formed contexts
	       	result in well-sorted kinds]
\label{prop:wfkind}
\[ \inference{ |- \Delta & \Delta |- F : \kappa}{ |- \kappa:\square }
\]
\end{proposition}
\begin{proof} By induction on the derivation.
\begin{itemize}
\item[case] ($Var$)
	Trivial by the second well-formedness rule of $\Delta$.
\item[case] ($Conv$) \\
	By induction and Lemma \ref{lem:wfeqkind}.
\item[case] ($\lambda$) \\
	By induction and Proposition \ref{prop:wfsort} we know
	that $|- \kappa:\square$.\\
	By the second well-formedness rule of $\Delta$,
	we know that $|- \Delta,X^\kappa$ since we already know
	that $|- \kappa:\square$ and $|- \Delta$ from the property statement.\\
	By induction, we know that $|- \kappa':\square$
	since we already know that $|- \Delta,X^\kappa$ and
	that $\Delta,X^\kappa|- F:\kappa'$ from induction hypothesis.\\
	By the sorting rule ($R$), we know that $|- \kappa -> \kappa':\square$
	since we already know that $|- \kappa:\square$ and $|- \kappa':\square$.
\item[case] ($@$)
	By induction, easy.
\item[case] ($\lambda i$)\\
	By induction and Proposition \ref{prop:wftype} we know
	that $\cdot|- A:*$.
	By the third well-formedness rule of $\Delta$,
	we know that $|- \Delta,i^A$ since we already know that $\cdot|- A:*$ and
	that $|- \Delta$ from the property statement.\\
	By induction, we know that $|- \kappa:\square$
	since we already know that $|- \Delta,i^A$ and
	that $\Delta,i^A|- F:\kappa$ from the induction hypothesis.\\
	By the sorting rule ($Ri$), we know that $|- A -> \kappa:\square$
	since we already know that $\cdot |- A:*$ and $|- \kappa:\square$.
\item[case] ($@i$)
	By induction and Proposition \ref{prop:wftype}, easy.
\item[case] ($->$)
	Trivial since $|- * : \square$.
\item[case] ($\forall$)
	Trivial since $|- * : \square$.
\item[case] ($\forall i$)
	Trivial since $|- * : \square$.
\end{itemize}
\end{proof}

The basic structure of the proof for the following proposition is similar to
above. So, I illustrate the proof for most of the cases, which can be done
by applying the induction hypothesis, rather bravely. I elaborate more on
interesting cases ($\forall E$) and ($\forall Ei$) which involve substitutions
in the types entailed from the typing judgments.
\begin{proposition}[typing derivations under well-formed contexts result in
	well-sorted kinds]
\label{prop:wftype}
\[ \inference{ \Delta |- \Gamma & \Delta;\Gamma |- t : A}{ \Delta |- A : * }
\]
\end{proposition}
\begin{proof} By induction on the derivation.
\begin{itemize}
\item[case] ($:$)
	Trivial by the second well-formedness rule of $\Gamma$.
\item[case] ($:i$)
	Trivial by the third the well-formedness rule of $\Delta$.
\item[case] ($=$)
	By induction and Lemma \ref{lem:wfeqtype}.
\item[case] ($->$$I$)
	By induction and well-formedness of $\Gamma$.
\item[case] ($->$$E$)
	By induction.
\item[case] ($\forall I$)
	By induction and well-formedness of $\Delta$.
\item[case] ($\forall E$)\\
	By induction we know that $\Delta |- \forall X^\kappa.B : *$.\\
	By the kinding rule ($\forall$), which is the only kinding rule
	able to derive $\Delta |- \forall X^\kappa.B : *$, we know
	that $\Delta,X^\kappa |- B : *$.\\
	Then, we use the type substitution lemma (Lemma \ref{lem:tysubst}).
\item[case] ($\forall Ii$)
	By induction and well-formedness of $\Delta$.
\item[case] ($\forall Ei$)\\
	By induction we know that $\Delta |- \forall i^A.B : *$.\\
	By the kinding rule ($\forall i$), which is the only kinding rule
	able to derive $\Delta |- \forall i^A.B : *$, we know
	that $\Delta,i^A |- B : *$.\\
	Then, we use the index substitution lemma (Lemma \ref{lem:ixsubst}).
\end{itemize}
\end{proof}

\begin{lemma}\label{lem:wfeqkind}
$ \inference{|- \kappa = \kappa':\square}
	{|- \kappa:\square \quad |- \kappa':\square} $
\end{lemma}
\begin{proof}
	By induction on the derivation of kind equality
	and using the sorting rules.
\end{proof}

\begin{lemma}\label{lem:wfeqtype}
$ \inference{\Delta |- F = F':\kappa}
	{\Delta |- F:\kappa \quad \Delta |- F':\kappa} $
\end{lemma}
\begin{proof}
	By induction on the derivation of type equality
	and using the kinding rules.
	Also use the type substitution lemma (Lemma \ref{lem:tysubst})
	and the index substitution lemma (Lemma \ref{lem:ixsubst}).
\end{proof}

\begin{lemma}\label{lem:wfeqterm}
$ \inference{\Delta,\Gamma |- t = t':\kappa}
	{\Delta,\Gamma |- t:\kappa \quad \Delta,\Gamma |- t':\kappa} $
\end{lemma}
\begin{proof}
	By induction on the derivation of term equality
	and using the typing rules.
	Also use the term substitution lemma (Lemma \ref{lem:tmsubst}).
\end{proof}

\begin{lemma}[type substitution]\label{lem:tysubst}
$ \inference{\Delta,X^\kappa |- F:\kappa' & \Delta |- G:\kappa}
	{\Delta |- [G/X]F:\kappa'} $
\end{lemma}

\begin{lemma}[index substitution]\label{lem:ixsubst}
$ \inference{\Delta,i^A |- F:\kappa & \Delta;\cdot |- s:A}
	{\Delta |- [s/i]F:\kappa} $
\end{lemma}

\begin{lemma}[term substitution]\label{lem:tmsubst}
$ \inference{\Delta;\Gamma,x:A |- t:B & \Delta;\cdot |- s:A}
	{\Delta,\Gamma |- [s/x]B:\kappa} $
\end{lemma}




\begin{proposition}[anti-dependency on arrow kinds]
\[ \inference{ |- \Delta,X^\kappa
             & \Delta,X^\kappa |- F : \kappa' }
             { X\notin\FV(\kappa') }
\]
\end{proposition}

\begin{proposition}[anti-dependency on indexed arrow kinds]
\[ \inference{ |- \Delta,i^A
             & \Delta,i^A |- F : \kappa }
             { i\notin\FV(\kappa) }
\]
\end{proposition}

\begin{proposition}[anti-dependency on arrow types]
\[ \inference{ \Delta |- \Gamma,x:A
             & \Delta;\Gamma,x:A |- t : B }
             { x\notin\FV(B) }
\]
\end{proposition}

\begin{remark} Our system is more strong??? than anti-dependency on arrow types
TODO
\end{remark}

\begin{definition}[index erasure]
\[ \fbox{$\kappa^\circ$}
 ~~~~
 *^\circ =
 *
 ~~~~
 (\kappa -> \kappa')^\circ =
 \kappa^\circ -> \kappa^\circ
 ~~~~
 (A -> \kappa)^\circ =
 \kappa
\]
\[ \fbox{$F^\circ$}
 ~~~~
 X^\circ =
 X
 ~~~~
 (\lambda X^\kappa.F)^\circ =
 \lambda X^{\kappa^\circ}.F^\circ
 ~~~~
 (\lambda i^A.F)^\circ =
 F^\circ
 ~~~~
 (F\;G)^\circ =
 F^\circ\;G^\circ
 ~~~~
 (F\,\{s\})^\circ =
 F^\circ
\]
\[ ~~~~ ~~~~ ~~~~
 (A -> B)^\circ =
 A^\circ -> B^\circ
 ~~~~
 (\forall X^\kappa . B)^\circ =
 \forall X^{\kappa^\circ} . B^\circ
 ~~~~
 (\forall i^A . B)^\circ =
 B^\circ
\]
\[ \fbox{$\Delta^\circ$}
 ~~~~
 \cdot^\circ = \cdot
 ~~~~
 (\Delta,X^\kappa)^\circ = \Delta^\circ,X^{\kappa^\circ}
 ~~~~
 (\Delta,i^A)^\circ = \Delta^\circ
\]
\[ \fbox{$\Gamma^\circ$}
 ~~~~
 \cdot^\circ = \cdot
 ~~~~
 (\Gamma,x:A)^\circ = \Gamma^\circ,x:A^\circ
\]
\end{definition}

\begin{lemma}[index erasure on well-formed type level contexts]
If $|- \Delta$ then $|- \Delta^\circ$.
\end{lemma}

\begin{lemma}[index erasure on well-formed term level contexts]
If $\Delta |- \Gamma$ then $\Delta^\circ |- \Gamma^\circ$.
\end{lemma}

\begin{lemma}[index erasure on well-sorted kinds]
If $|- \Delta$ and $\Delta |- \kappa : \square$
then $\Delta^\circ |- \kappa^\circ : \square$.
\end{lemma}

\begin{lemma}[index erasure on well-kinded type constructors]
If $|- \Delta$ and $\Delta |- F : \kappa$
then $\Delta^\circ |- F^\circ : \kappa^\circ$.
\end{lemma}

\begin{theorem}[index erasure on well-typed terms]
If $\Delta |- \Gamma$ and $\Delta;\Gamma |- t : A$
then $\Delta^\circ;\Gamma^\circ |- t : A^\circ$.
\end{theorem}

%%%%% TODO
%% Some simple index erasure example
%% 
%% Subject reduction
%% 
%% Lectures on Curry Howard Isomrophism --


\begin{comment}
\subsection{\Fi\ in regards to PTS}
We describe \Fw\ and CC as an instances of the Pure Type System (PTS),
and then describe \Fi\ as an extension of \Fw\ and a restriction of CC.

%% \begin{figure}
\[\text{Syntax}~~~~~ a,b,A,B ::= s \mid x \mid b~a \mid \lambda x:A.B
                                   \mid (x:A) -> B \]
\[\text{Typing}~~~~~\]
\[
 \inference[Ax]{|-\Gamma & (s_1,s_2)\in\calA}{\Gamma |- s_1 : s_2}
 ~~~~
 \inference[Var]{|-\Gamma & (x:A)\in\Gamma}{\Gamma |- x:A} 
 ~~~~
 \inference[Conv]{\Gamma |- a:A & \Gamma |- B:s & A=B}{\Gamma |- a:B}
\]
\[
 \inference[Pi]{\Gamma |- A:s_1 & \Gamma,x:A |- B:s_2 & (s_1,s_2,s_3)\in\calR}
               {\Gamma |- (x:A)-> B : s_3}
\]
\[
 \inference[Lam]{\Gamma |- (x:A)-> B : s & \Gamma,x:A |- b:B}
                {\Gamma |- \lambda x:A.b : (x:A)-> B}
 ~~~~
 \inference[App]{\Gamma |- b:(x:A)-> B & \Gamma |- a:A}{\Gamma |- b\;a:[a/x]B}
\]

\[\text{Context}~~~~~
 \inference{}{|-\cdot}
 ~~~~
 \inference{x\notin\dom(\Gamma) & |-\Gamma}{|-\Gamma,x:A}
\]
%% \caption{Pure Type System}
%% \label{fig:PTSrule}
%% \end{figure}

PTS is instantiated by the triple $(\calS,\calA,\calR)$ where
$\calS$ is the set of sorts ($s,s_1,s_2,s_3\in\calS$ in the PTS typing rules),
$\calA\subset\calS\times\calS$ is the set of axioms (used in Ax rule), and
$\calR\subset\calS\times\calS\times\calS$ is the set of rules (used in Pi rule).

\Fw\ is an instance of PTS where
\[\calS=\{*,\square\}
  ~~~~~
  \calA=\{(*,\square)\}
  ~~~~~
  \calR=\{(*,*,*),(\square,*,*),(\square,\square,\square)\}
\]
Each element in $\calR$ stands for certain ability of dependency:
$(*,*,*)$ enables functions at the value level
(values depending on values)
$(\square,*,*)$ enables parametric polymorphism
(values depending on types)
$(\square,\square,\square)$ enables functions at the type level
(types depending on types).

CC extends \Fw\ with one additional rule
$(*,\square,\square)$, which enables types depending on values
(\emph{dependent types}, or, types with \emph{value dependency}).
That is, CC is an instance of PTS where
\[\calS=\{*,\square\}
  ~~~~~
  \calA=\{(*,\square)\}
  ~~~~~
  \calR=\{(*,*,*),(\square,*,*),(\square,\square,\square)
         ,(*,\square,\square)\}\]


Normalization of \Fi\ is automatic since \Fi\ is a strict subset of CC,
which is known to be strongly normalizing.

\subsection{examples}
For better intuition, let us see some examples what we can express and
what we cannot in \Fi.
\newcommand{\List}{\mathsf{List}}
\newcommand{\Vect}{\mathsf{Vec}}

\paragraph{Ordinary (parametric) polymorphism} is obviously possible,
since \Fi\ is an extension of \Fw. Note, $\Gamma |- (x:*) -> B : *$
where $\Gamma,x:* |- B:*$, since $(\square,\star,\star) \in\calR$.
If you'd prefer \Fw\-like syntax we could use alternative notation
$\forall(x:*).B$ for $(x:*) -> B$. With the support of ordinary polymorphism,
we can write functions over polymorphic lists as follows
where $\List : * -> *$ (details of the function body is omitted):
\[ (\Lambda a:*.\lambda x:\List~a. \cdots) : \forall(a:*).\List~a -> \List~a \]
The uppercase lambda ($\Lambda$) is an alternative notation in flavour of \Fw
for the ordinary lowercase lambda ($\lambda$)
More generally, we can be polymorphic over any \Fw\ kind such as $* -> *$.
For instance, $\forall(x:* -> *).B$.

\paragraph{Polymorphism over indexed values} is also possible.
Note, $\Gamma |- (x:A) -> B : *$ where $\Gamma |- A:*$ and $\Gamma,x:A |- B:*$.
With the support of polymorphism over indexed values, we can write functions
over type indexed lists as follows (details of the function body is omitted)
where $\Vect : \Nat -> *$:
\[
(\Lambda n:\Nat.\lambda x:\Vect~n. \cdots) : \forall(n:\Nat).\Vect~n -> \Vect~n 
\]
More generally, $\Gamma |- (x:\ka) -> B : *$ where $\Gamma, x:\ka |- B:*$
can be written as $\forall(x:\ka).B$ in flavour of \Fw.

We call the (parametric) polymorphism of \Fi, which includes
both the ordinary polymorphism of \Fw\ and the polymorphism involving indices,
\emph{generalized polymorphism}.

To be more precise, this is not exactly the polymorphism we would expect
in functional languages with indexed types (\eg, GADT extension in Haskell),
since we usually expect index variables like $n$ bound by $\Lambda$ to be
erasable (or, computationally irrelevant) in contrast to the variables bound
by ordinary $\lambda$. Here in PTS, which is in Church style, $n$ can also
appear as computationally relevant in the function body. Unlike ordinary
polymorphism where the polymorphic variable is a type variable that cannot
live in value world, nothing prevents the index variables like $n$ to be used
in the value level. This is what Abel and Matthes in CSL 04 paper meant that
the Church style becomes richer than the Curry style as we move from \Fw\ to
a dependently typed setting such as CC. I think it is better to formalize
in Curry style if we want to capture the erasure property of polymorphism
correctly in \Fi.

\paragraph{Large eliminations resulting in constant kinds} are possible.
Large eliminations are type computations depending on values.  For example,
computing an $n$-ary boolean function type given a natural number index $n$
can be defined as follows (details of the function body is omitted):
\[
(\lambda n:\Nat. \stackrel{n}{\overbrace{\Bool-> \cdots-> \Bool}}\;\, -> \Bool)
  : (n:\Nat) -> *
\]
Note, the resulting kind ($*$) is constant, being independent of $n$.
So, the example above is a large elimination resulting in a constant kind,
which does not involve any kind computation.

However, large eliminations resulting in varying kinds that depend on
input index values are not possible, unless you use the let syntax to make
the input index values available (then, the input indices do not vary
at runtime after all). For example, large elimination computing an $n$-ary
type constructor given a natural number index $n$ line the following
is \emph{not} possible to define in \Fi:
\[
(\lambda n:\Nat. \cdots \cdots)
  : (n:Nat) -> \,\;\stackrel{n}{\overbrace{* -> \cdots -> *}}\;\, -> *
\]
This restriction is to make the kind inference doable.
\end{comment}
