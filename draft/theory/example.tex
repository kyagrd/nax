
\section{Nax by Example}\label{sec:bg}

In this section we introduce programming in our implementation of Nax by providing
examples. An example usually consists of several parts.

\begin{itemize}
\item Introducing data definitions to describe the data of interest. Recursive
data is introduced in two stages. We must be careful to separate parameters
from indices when using indices to describe static properties of data.

\item Introduce macros, either by explicit defintion, or by automatic derivation
to limit the amount of explicit notation that must be supplied by the programmer.

\item Write a series of definitions that describe how the data is to be
manipulated. Deconstruction of recursive data can only be performed with Mendler style operators
to ensure strong normalization.

\end{itemize}

\subsection{Two level types}\label{2level}
Non recurisive datatypes are introduced by the \verb+data+ declaration.
The data declaration can include arguments. The kind and separation of
arguments into parameters and a indices is infered. For example, 
the three non-recursive data types, \verb+Bool+, \verb+Either+, and 
\verb+Maybe+, familiar to many functional programmers, are introduced
in a manner almost identical manner to traditional functional languages.

{\small
\begin{verbatim}   
data Bool = False | True
data Either a b = Left a | Right b
data Maybe a = Nothing | Just a
\end{verbatim}}
Kind inference infers the kinds:
(\verb+Bool: *+), (\verb+Either: * -> * -> *+), and 
(\verb+Maybe: * -> *+), where \verb+*+ is the kind of ordinary types that
classify values.

To introduce a recursive type, we first introduce a non recursive datatype
that uses a parameter where the usual recursive components occur. By design,
normal parameters of the introduced type are written first (\verb+a+ in \verb+L+)
and the parameter to stand for the recursive component is written last
(the \verb+r+ of \verb+Nat+, and the \verb+r+ of \verb+L+).
{\small
\begin{verbatim}
data N r = Zero | Succ r        -- the fix point of N will the natural numbers
data L a r = Nil | Cons a r     -- the fix point of (L a) will be polymorphic lists   
\end{verbatim}}

Kind inference infers the following kinds:
(\verb+N: * -> *+),  (\verb+L: * -> * -> *+). 
A recursive type can be defined as the fixpoint of a (perhaps partially applied)
non recursive type constructor. Thus the traditional natural numbers are typed by \verb+Mu[*] N+
and the traditional lists with components of type \verb+a+ are typed by
\verb+Mu[*] (L a)+.  Note that the \verb+Mu+ type operator is itself specialized with a kind argument inside
square brackets (\verb+[ _ ]+). The fixpoint operator (\verb+Mu[k] f+) is well formed only
if the operand \verb+f+ has kind \verb+k -> j+, in which case the (\verb+Mu[k] f+) type
has kind \verb+j+. Since both \verb+N+ and \verb+(L a)+ have kind \verb+* -> *+,
the types  \verb+Mu[*] N+ and \verb+Mu[*] (L a)+ have kind \verb+*+, i.e. they 
are both types, not type constructors.

\subsection{Creating values}

Values of a particular data type are created by use of constructor functions. For
example \verb+True+ and \verb+False+ are constructor (constants) of type \verb+Bool+.
(\verb+Left 4+) is a value of type (\verb+Either Int a+). Values of recursive types
(i.e. those values with types such as (\verb+Mu[k] f+) are formed by using the \verb+In+
expression. Thus \verb+Nil+ has type \verb+L a+, and \verb+(In[*] Nil)+ has type
(\verb+Mu[*] (L a)+). In general, applying the operator \verb+(In[k])+ injects a term of
type \verb+f(Mu[k] f)+ to the recursive type (\verb+Mu[k] f+). Thus a list of Bool could be
created using the term \verb+(In[*] (Cons True  (In[*] (Cons False  (In[*] Nil)))))+. 
A general rule of thumb, is to apply \verb+In[k]+ to terms of non-recursive type
to get terms of recursive type. Writing programs using two level types, and recursive
injections has definite benefits, but it surely makes programs harder to write. Thus
we have provided Nax with a simple but powerful synonym (macro) facility.

\subsubsection{Synonyms, constructor functions, and derivation}\label{macro}

We may codify that some type is the fixed point of another, once and for all, by introducing
a type synonym (macro).

{\small
\begin{verbatim}
synonym Nat = Mu[*] N
synonym List a = Mu[*] (L a)     
\end{verbatim}}

In a similar manner we can introduce constructor functions that create
recursive values without explicit mention of \verb+In+ at their
call sites (potentially many), but only at their site of defintion (exactly once).

{\small
\begin{verbatim}
zero = In[*] Zero
succ n = In[*] (Succ n)

nil = In[*] Nil
cons x xs = In[*] (Cons x xs)
\end{verbatim}}
This is such a common occurence that recursive synonyms and recursive constructor functions
can be automatically derived. With automatic synonym and constructor derivation
using Nax is both concise ans simple. The clause ``\verb+deriving fixpoint List+"
causes the \verb+synonym+ for \verb+List+ to be automatically defined. It
also defines the constructor functions \verb+nil+ and \verb+cons+.
By convention, the constructor functions are named by dropping the initial
upper-case letter in the name of the non-recursive constructors to lower-case.
To illustrate, we provide side-by-side comparisons
of Haskell and two different uses of Nax.

\vspace*{0.1in}
\begin{tabular}{l|l|l}
{\em Haskell}  & {\em Nax with synonyms} &  {\em Nax with derivation} \\ \hline
\begin{minipage}[t]{.26\linewidth}
{\small
\begin{verbatim}
data List a 
  = Nil 
  | Cons a (List a)
  
x = Cons 3 (Cons 2 Nil)  
\end{verbatim}}
\end{minipage}

& 

\begin{minipage}[t]{.34\linewidth}
{\small
\begin{verbatim}
data L a r 
     = Nil 
     | Cons a r
  
synonym List a = Mu[*] (L a)
nil = In[*] Nil
cons x xs = In[*] (Cons x xs)

x = cons 3 (cons 2 nil)  
\end{verbatim}}
\end{minipage}

&

\begin{minipage}[t]{.26\linewidth}
{\small
\begin{verbatim}
data L a r 
     = Nil 
     | Cons a r
  deriving fixpoint List

x = cons 3 (cons 2 nil)    
\end{verbatim}}
\end{minipage}

\end{tabular}


\subsection{Mendler operators for non-indexed types}
There are no restrictions on what kind of datatypes
can be defined, or on the construction of values using constructor
functions and \verb+In[k]+ in Nax. To ensure strong normalization, analysis of constructed
terms is restricted to non-recursive types. This manifests in the lack of
a pattern that matches the construction (\verb+In[*] x+). Simple pattern matching functions
over non-recursive data is supported. For example:

\vspace*{.1in}
\begin{tabular}{l|l}
\begin{minipage}[l]{.42\linewidth}
{\small
\begin{verbatim}
not True = False
not False = True
\end{verbatim}}
\end{minipage}

& 

\begin{minipage}[l]{.50\linewidth}
{\small
\begin{verbatim}
unJust0 (Just x) = x
unJust0 Nothing  = 0
\end{verbatim}}
\end{minipage}
\end{tabular}
\vspace*{.1in}

Analysis of recursive data is performed with Mendler style operators. In our
implementation we provide 4 Mendler style operators: \verb+mcata+ (fold or catamorphism), 
\verb+mprim+ (primitive recursion), \verb+mhist+ (courses of values recursion),
and \verb+msfcata+ (fold for recursive types with negative occurrences). {\em Do not}
worry if these look strange at first. They will be disccused in greater detail
below. {\em Do notice} that these programs are simple and concise.

\vspace*{.1in}
\begin{tabular}{l|l}
\begin{minipage}[l]{.42\linewidth}
{\small
\begin{verbatim}
length y = 
   mcata y with
     len Nil = 0
     len (Cons x xs) = 1 + len xs

tail x = 
  mprim x with
    tl cast Nil = []
    tl cast (Cons y ys) = (cast ys )
\end{verbatim}}
\end{minipage}

& 

\begin{minipage}[l]{.50\linewidth}
{\small
\begin{verbatim}

factorial x =
  mprim x with
    fact cast Zero = 1
    fact cast (Succ n) = 
        (1 + nat2int(cast n)) * fact n
                      
fibonocci n =
  mhist n with
    fib out Zero = 1
    fib out (Succ n) = 
        case (out n) of
          Zero -> 1
          (Succ m) -> fib n + fib m 
\end{verbatim}}
\end{minipage}
\end{tabular}
\vspace*{.1in}

In Nax, one uses a \verb+case+ expression to analyze
a non-recursive type, and a Mendler style operator analyze
a recursive value. Unlike a
case statement (which only allows the user to specify patterns against which the
argument is matched), a Mendler operator introduces additional names (variables),
in addition to the variables occuring in the patterns, that
provide additional functionality. For example compare the \verb+case+ expression
to the \verb+mcata+ expression. In the \verb+case+, each line following the \verb+of+
indicates a possible match of the scrutinee \verb+x+. In the \verb+mcata+,
each equation following the \verb+with+, binds the variable $\newFi{f}$, and
matches the pattern to a value related to the scrutinee \verb+x+.

\vspace*{.1in}
\begin{tabular}{l|l}
\begin{minipage}[t]{.42\linewidth}
\begin{tabbing}
\verb+case+  x \verb+of+ \\
\verb+  + \= \verb+(Cons x xs)+ \= $\to$  \= $e_{2}$ \\
\> \verb+Nil+ \> $\to$  \> $e_{1}$ \\
\end{tabbing}
\end{minipage}

& 

\begin{minipage}[t]{.50\linewidth}
\begin{tabbing}
\verb+mcata+  x \verb+with+ \\
\verb+  + \= \newFi{f} \= \verb+(Cons x xs)+ \= =  \= $e_{1}$ \\
          \> \newFi{f} \> \verb+Nil+         \> =  \> $e_{2}$ \\
\end{tabbing}
\end{minipage}
\end{tabular}
\vspace*{.1in}

The number and type of the additional variables depends upon which Mendler
operation is used to analyze the scrutinee. In each case the scrutinee
is a value of some recursive type (\verb+Mu+[*] \verb+T+) for a non-recursive
type constructor \verb+T+. Each pattern has type \verb+T r+, for some
abstract type \verb+r+. The additional variables introduced ($\newFi{f}$ and $\newFi{g}$)
are functions that safely manipulate some form of the abstract type \verb+r+.

\vspace*{.1in}
\begin{tabular}{l|l|l}
\begin{minipage}[t]{.25\linewidth}
{\small
\begin{tabbing}
\verb+mcata+  x \verb+with+ \\
\verb+  + \= \newFi{f} \= $\text{pat}_{i}$ \= =  \= $e_{i}$ \\
\end{tabbing}
$x$: \verb+Mu+[*] T \\
$f$: r $\to$ \text{ans} \\
$p_{i}$: T r \\
$e_{i}$: \text{ans} \\
\\
\begin{verbatim}
mcata phi (In[*] x) 
   = phi (mcata phi) x
\end{verbatim}}   
\end{minipage}
& 

\begin{minipage}[t]{.35\linewidth}
{\small
\begin{tabbing}
\verb+mprim+  x \verb+with+ \\
\verb+  + \= \newFi{f} \= \newFi{g} \= $\text{pat}_{i}$ \= =  \= $e_{i}$ \\
\end{tabbing}
$x$: \verb+Mu+[*] T \\
$f$: r $\to$ \text{ans} \\
$g$: r $\to$ \verb+Mu+[*] T \\
$p_{i}$: T r \\
$e_{i}$: \text{ans} \\
\\
\begin{verbatim}
mprim phi (In[*] x) 
  = phi (mprim phi) (In[*]) x
\end{verbatim}}  
\end{minipage}

& 

\begin{minipage}[t]{.25\linewidth}
{\small
\begin{tabbing}
\verb+mhist+  x \verb+with+ \\
\verb+  + \= \newFi{f} \= \newFi{g} \= $\text{pat}_{i}$ \= =  \= $e_{i}$ \\
\end{tabbing}
$x$: \verb+Mu+[*] T \\
$f$: r $\to$ \text{ans} \\
$g$: r $\to$ T r \\
$p_{i}$: T r \\
$e_{i}$: \text{ans} \\
\begin{verbatim}
mhist phi (In[*] x) 
    = phi (mhist phi) out x
  where out (In[*] x) = x
\end{verbatim}}
\end{minipage}

\end{tabular}
\vspace*{.1in}

Mendler observed that each operator can be defined
by the equation at the bottom of its figure, and by abstracting
values of type  \verb+Mu[*] T+ into some unknown abstract type \verb+r+, one can safely use
types to insure termination.  Operationally
if the \verb+phi+ function will work for some unknown type \verb+r+
it will work for the actual type \verb+Mu[*] T+, but because it cannot
assume that \verb+r+ has any particular structure, the function is
guaranteed to terminate by a parametricity argument. In Nax we use special
syntax, to get around the requirement of impredicative types that would be used
to guarantee that the type \verb+r+ is abstract.

With these explanations under our belt, let's look back at our four examples.


  
\subsection{Types with static indices}\label{sec:bg:ixty}


\subsection{Mendler operators for indexed types}

A representative example of a term
indexed type is the length indexed list type (often called the vector type).
A regular polymorphic list type ($\sfList\;a$) is parametrized by a type
parameter ($a$), which can be instantiated to a specific type, while the
vector type ($\sfVec\;a\;\{n\}$) has an additional term index ($n$), which
can be instantiated to a specific natural number value. The curly brackets
($\{\cdots\}$) around $n$ is to syntactically distinguish term indices from
other type arguments. 

\subsection{Recursive types of unrestricted polarity but restricted elimination}
\label{sec:bg:recty}
TODO

\subsection{Mendler style iteration and recursion combinators}
\label{sec:bg:Mendler}


\section{Examples}\label{sec:examples}

