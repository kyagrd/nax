\section{Summary and Ongoing Work} \label{sec:concl}
System~\Fi\ is a strongly-normalizing, logically-consistent, higher-order
polymorphic lambda calculus that was designed to support the
definition of datatypes indexed by both terms and types.
In terms of expressivity, System~\Fi\ sits between System~\Fw\ and ICC.
We designed System~\Fi\ as a tool to reason about programming
languages with term-indexed datatypes. System \Fi\ can express
large class of term-indexed datatypes, even including nested term
indices.

One limitation of System \Fi\ is that it cannot express type level
data structures such as lists that contain type elements.
We envision to overcome this limitation by extending System \Fi\ 
with first-class datatype descriptions \cite{DagMcb12}, which reflects
the structure of types at term level.

Our goal is to to build a unified programming and reasoning system,
which supports
(1) wide class of datatypes including nested term-indexed datatypes
and negative datatypes,
(2) logically consistent reasoning about program properties, and
(3) Hindley--Milner-style type inference.
For this, we are designing and implementing Nax \cite{AhnSheFioPit12},
which is based on System \Fi. Nax is given semantics in terms of System~\Fi.
That is, all the primitive language constructs of Nax that are not present
in \Fi\ have translations into System \Fi. Such constructs include
Mendler-style recursion combinators, recursive type operator, and
pattern matching.

Some language features we want to include in Nax seem to go beyond \Fi.
There are recursion schemes that guarantee normalization due to certain use
of indices in datatypes. For instance, some recursive computations may always
makes a natrual number term-index decrease by every recursive call.
Although we know that such computations obviously terminate, we cannot express
them in System \Fi, since term-indices in \Fi\ are erasable -- \Fi\ only
accepts terms that are already type-correct in \Fw.
We plan to explore extensions to \Fi\ that enable such computations
while maintailing logical consistency.

