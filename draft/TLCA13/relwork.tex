\section{Related Work} \label{sec:relwork}

In the practical setting of programming language implementations,
\citet{YorgeyWCJVM12}, inspired by \citet{SHE}, designed an extension
to Haskell, allowing datatypes to be used as kinds. For instance, \texttt{Bool}
is promoted to a kind (\ie, $\texttt{Bool}:\square$) and its data constructors
\texttt{True} and \texttt{False} are promoted to types. To support this,
they extended System $F_{\!C}$ (The Glasgow Haskell Compiler's (GHC) intermediate core language), 
naming the extension System $F_{\!C}^\uparrow$.
The key difference between $F_{\!C}^\uparrow$ and \Fi\ is the kind syntax, as illustrated below: \vspace*{-2pt}
\[\qquad\quad
\begin{array}{ll}
F_{\!C}^\uparrow\,\textbf{kinds}: &
\kappa ::= * \mid \kappa -> \kappa \mid F \vec{\kappa} \mid \mathcal{X} \mid \forall \mathcal{X}.\kappa \mid \cdots \\
\,\Fi\,\,\textbf{kinds}: &
\kappa ::= * \mid \kappa -> \kappa \mid A -> \kappa \phantom{A^{A^A}}
\end{array}  
\] ~\vspace*{-6pt}\\
In $F_{\!C}^\uparrow$, all type constructors ($F$) are promotable to the 
kind level and become kinds when fully applied to other kinds
($F\vec\kappa$). On the other hand, in \Fi,  a type can only appear
as the domain of an index arrow kind ($A-> \kappa$). This seemingly small
difference allows $F_{\!C}^\uparrow$ to be a much
more expressive language than \Fi. The promotion of
a type constructor, for instance, $\texttt{List}:* -> *$ to a kind constructor
$\texttt{List}:\square-> \square$ enables type-level data structures
such as $\mathtt{[Nat,Bool,Nat-> Bool]:List\,*}$. Type-level
data structures motivate type-level computations over promoted data.
This is made possible by type families\footnote{
	A GHC extension to define type-level functions in Haskell.}.
The promotion of polymorphic types naturally motivates
kind polymorphism ($\forall \mathcal{X}.\kappa$), which is known to
break strong normalization and cause logical inconsistency \cite{Girard72}.
In a functional {\em programming language},
inconsistency is not an issue. However, when studying
term-indexed datatypes in a logically consistent calculi, we need
a more conservative approach, as in System \Fi.

