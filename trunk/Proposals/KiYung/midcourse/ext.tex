\section{Possibilities for further extensions}\label{sec:ext}
There are many extensions that would make Nax more attractive
as a programming language. Here, I list some of them.

\paragraph{Extending the syntax of index transformer annotations:}
In \S\ref{sec:mendler:etc}, we have already seen that we need extend
to the index transformer syntax to support
\emph{equality constraints}.

Another possible extension to the index transformer syntax is to allow
\emph{type level computations}, which eventually reduced to a type,
to appear in the body of an index transformer. The current index
transformer syntax only allow the body of index transformers to be a type.
The only possible variation on the return type would be the term indices
when the return type is a term indexed type. However, we can imagine
a function that returns totally unrelated types (\eg, \textit{Bool} and Nat)
depending on the input indices. To support functions of such type, we need
to allow case expressions in the body of an index transformer, which examines
a term and returns a type. For example, consider the following definition:
\begin{align*}
\textit{foo}~x =
 \MIt^{\left\{\{n\} . \begin{smallmatrix}\textbf{case}\;n\;\textbf{of}
                                        &\textit{Zero}~~~  -> \textit{Bool} \\
                                        &\textit{Succ}\;m\;-> \textit{Nat}\;
                                        \end{smallmatrix}
       \right\}}~\;x~\;\textbf{with}
&\quad  f ~\textit{VNil}~~~~~~~~~~~ = \textit{True} \\
&\quad  f \;(\textit{VCons}\;x\;xs) = zero
\end{align*}
 (\eg, \textbf{case} n \textbf{of} \textit{Zero} )
The function $foo$ taking a length indexed list as an input, and returns
$\textit{True} : \textit{Bool}$ when the list is empty, but returns
$zero : \textit{Nat}$ otherwise. Such an extension is not a problem regarding
type safety and logical consistency, since the target calculi \Fi\ and \Fixi\
already has the ability to express type level computation. However, we are
unsure of its ramifications over the type inference algorithm of Nax. In my
thesis, I will elaborate on the argument that such an extension does not
interfere with type safety and logical consistency, and also investigate
its ramifications over the type inference algorithm of Nax.

\paragraph{Allowing non-termination in the language:}
Recall that the motivation behind my thesis is to contribute to 
building a seamless system where programmers can both write
(functional) programs and formally reason about those programs.
Those programs include non-terminating ones.

I don't propose to come up with a full solution integrating logic and
programming in my thesis work. But I will certainly summarize the recent
work \cite{} of the Trellys project group, trying to bridge the two worlds of
logic and programming by a modal type system. This will give a better context
for the Nax language and its contributions.

\paragraph{Kind polymorphism:}
The calculi \Fi\ and \Fixi\ are polymorphic at type level but monomorphic at
kind level, just like \Fw. Support for polymorphism at kind level is another
dimension of a language extension. When we have kind polymorphism, we can
have one recursive type operator $\mu$, which has a polymorphic kind, instead
of family recursive type operator superscripted by kinds ($\mu^\kappa$).
Recently, \citet{YorWeiCrePeyVytMag12} proposed $F_C^{\uparrow}$, which is
an extension to $F_C$ (the core language of Glasgow Haskell Compiler)
with kind polymorphism and a limited form of term indexed types.
Although the kind polymorphism extension enables further generalizations and
abstractions over the type structure, we need extra caution when we consider
logical consistency -- too much (impredicative) polymorphism at kind level may
lead to inconsistency. Dependently typed proof assistants, such as Coq and Agda,
need not consider this issue of kind polymorphism (or, more generally,
universe polymorphism) affecting consistency, since they simply limit
impredicative polymorphism, being based on predicative type systems.
However, I choose to base the theory Nax on an impredicative type system,
extending from \Fw, since I believe impredicative polymorphism is
more natural for typing programs, which might not necessarily be proofs.

Although I don't plan to include kind polymorphism in the Nax design for
my thesis work, I will certainly summarize the related work and try to
contemplate on what considerations we may need when we try to adopt
extensions like kind polymorphism in Nax.

\paragraph{Other possible extensions:}
Some extensions to Hindley-Milner type system, such as first class polymorphism
and qualified types, would also be posisble for Nax. I won't go into any
details on these issues in the thesis, but I will give pointers to related work
on those subjects.

Mendler style recursion schemes for full dependent types are well defined for
positive datatypes\footnote{Not in published work, but a well-known folklore
among researchers who studied the Mendler style.}. I will briefly introduce
Mendler style recursion combinator in a dependently typed setting in my thesis.

