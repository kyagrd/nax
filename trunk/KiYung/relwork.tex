\chapter{Related work}\label{ch:relwork}
We introduce some more related work that have not been discussed
in the introduction or related work sections (\S\ref{sec:intro},
\S\ref{sec:related}) in the previous chapters.

\input{relwork_mcoit} %% sec:relwork:co

\input{relwork_mmult} %% sec:relwork:mult

\section{Mendler-style induction}
\label{sec:relwork:dep}
Dependently-typed version of primitive recursion is called induction.
We can formulate the Mendler-style induction over regular datatypes as follows.
\vspace*{-2em}
\begin{singlespace}
\[\begin{array}{ll}
\textbf{mind}_{*} \, :
& \!\!\forall (F:* -> *) (A: \mu_{*}f -> *). \\
& ~~ \big(\forall(r:*).\;(cast : r -> \mu_{*}F) \\
& ~\qquad\quad -> (call : (x:r) -> A\,(cast~x)) \\
& ~\qquad\quad -> (y: F\;r) -> a\,(\In_{*}(\textit{fmap}_{F}\;call\;y)) \big) 
-> (z:\mu_{*}\,f) -> A\;z
\end{array}
\]
\[
\textbf{mind}_{*} ~ \varphi ~ (\In_{*}\;x)
  ~=~ \varphi~~\textit{id}~~(\textbf{mind}_{*}~\varphi)~~x \]
\end{singlespace}\noindent
The definition of Mendler-style induction $\textbf{mind}$ is
essentionally the same as the Mendler-style primitive recursion $\MPr$,
but the type signature involves dependent types.
Note, the final answer type $A\;z$ is dependent on
the recursive argument $z:\mu_{*}F$.
Since $A: \mu_{*}F -> *$ expects a concrete recursive value,
we use $cast$ and $call$ in the type signature of $\varphi$ function
to cast $x:r$ and $y:F\,r$ into $\mu_{*}F$ values, so that
they can be passed to $A$.
In the type signature of $\textbf{mind}$, $cast$ comes before $call$
because the type signature of $call$ depends on $cast$.
When defining $\MPr$, $cast$ and $call$ can come in any order
since there is no dependency in the type signature of $\MPr$.

One important thing to notice about $\textbf{mind}_{*}$ is that
it is well-defined only over positivity $F$, because we relied on
the existence of $\textit{fmap}_F$ to write its type signature.
It is an open question whether one can formulate a Mendler-style induction
that works for negative datatypes.

The idea for $\textbf{mind}_{*}$ comes from
the discussion with Tarmo Uustalu. He described this on a whiteboard
     when we met with him at the University of Cambridge in 2011.

\section{Type-based termination and sized types}
\emph{Type based termination} (coined by \citet{BartheFGPU04}) stands for
approaches that integrates termination into type checking, as apposed to
syntactic approaches that reason termination over untyped term structures.
The Mendler-style approach is, of course, type-based.  In fact, the idea of
type-based termination was inspired by \citet{Mendler87,Mendler91}.
In Mendler-style, we know that the recursive functions defined using
the Mendler-style recursion schemes will terminate once they are
type correct (provided that the termination behaviors of
those recursion schemes are clearly studied).

\citet{abel06phd,Abel12talkFICS} summarizes the advantages of
type-based termination as follows:
\textbf{communication} (programmers can think in types),
\textbf{certification} (types are machine checkable certificate),
\textbf{a simple theoretical justification}
	(no additional complication for termination other than type checking),
\textbf{orthogonality} (only small parts of the language is affected,
	\eg, principled recursion schemes instead of general recursion),
\textbf{robustness} (type system extensions are less likely to
			disrupt termination checking),
\textbf{compositionality}\footnote{This is not listed in Abel's thesis,
				but comes from his invited talk in FICS 2012.}
	(need only types not the code for function definitions), and
\textbf{higher-order functions and higher-kinded datatypes}
	(works well even for higher-order functions and non-regular datatypes,
	as a consequence of compositionality).
In his dissertation \cite{abel06phd} (Section 4.4) on sized types,
Abel views the Mendler style approach as enforcing size restrictions
using higher-rank polymorphism as follows:
\begin{itemize}
\item The abstract recursive type $r$ in Mendler style corresponds to
	$\mu^\alpha F$ in his sized-type system (System \Fwhat),
	where the sized type
	for the value being passed in corresponds to $\mu^{\alpha+1} F$.
\item The concrete recursive type $\mu F$ in Mendler style corresponds to
	$\mu^\infty F$ since there is no size restriction.
\item By subtyping, a type with a smaller size index can be considered as
	the same type but with a larger size index.
\end{itemize}
This view is based on the same intuition, which we discussed in
Chapter \ref{ch:mendler}, why Mendler-style recursion schemes terminate for
positive datatypes -- since $r$-values are direct subcomponents, they should
have one less depth of $\In$ constructors than the value being passed in.
Abel's System \Fwhat\ can express primitive recursion quite naturally
due to subtyping. The casting operation $(r -> \mu F)$ in Mendler-style
primitive recursion corresponds to an implicit conversion by subtyping
from $\mu^\alpha F$ to $\mu^\infty F$ because $\alpha \leq \infty$.

System \Fwhat\ \cite{abel06phd} is closely related to
System \Fixw\ \cite{AbeMat04}. Both of these systems are base on
equi-recursive fixpoint types over positive base structures.
Both of theses systems able to embed (or simulate) Mendler-style
primitive recursion (which is based on iso-recursive types) via
the encoding \cite{Geu92} of arbitrary base structures into
positive base structures. In \S\ref{sec:fixi:data}, we rely on
the same encoding, denoted by $\Phi$, when embedding \MPr\ into System \Fixi.

Abel's sized-type approach provides good intuitions for those recursion schemes,
which terminate over positive datatypes. However, it is not clear whether
the sized type approach based on positive equi-recursive fixpoint types
can provide a good intuition for our recursion scheme \MsfIt, which is
especially useful over negative datatypes. In \ref{sec:futwork:mprsi},
we will discuss another Mendler-style recursion scheme (\mprsi), which is
also useful over negative datatypes and has a termination property
(not proved yet) due the size of the index in the datatype.

\section{Logical Frameworks based on the $\lambda\Pi$-calculus}

Logical Frameworks

lambda pi calculus

term-indexing and term-dependency 
but lack polymorphism

System \Fi\
term-indexing and polymorhpism
but lack term-dependency.


termination checking is not type based

%% 
%% \section{TODO}

