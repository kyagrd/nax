\chapter{Related work}\label{ch:relwork}
In this chapter, we discuss additional related work,
not discussed in the introduction or the related work sections
of \S\ref{sec:intro} and  \S\ref{sec:related}.
We discuss five categories of related work:
Mendler-style co-recursion schemes over co-data (\S\ref{sec:relwork:co}),
Mendler-style recursion schemes over multiple values (\S\ref{sec:relwork:mult}),
dependently-typed Mendler-style induction (\S\ref{sec:relwork:dep}), 
the use of sized-types to explain the termination of Mendler-style
recursion schemes (\S\ref{sec:relwork:sized}), and the comparison of
our Mendler-style approach to logical frameworks (\S\ref{sec:relwork:LF}).


\input{relwork_mcoit} %% sec:relwork:co

\input{relwork_mmult} %% sec:relwork:mult

\section{Mendler-style induction}
\label{sec:relwork:dep}
The dependently-typed version of primitive recursion is called induction.
We formulate Mendler-style induction over regular datatypes as follows.
\vspace*{-2em}
\begin{singlespace}
\[\begin{array}{ll}
\textbf{mind}_{*} \, :
& \!\!\forall (F:* -> *) (A: \mu_{*}F -> *). \\
& ~~ \big(\forall(r:*).\;(cast : r -> \mu_{*}F) \\
& ~\qquad\quad -> (call : (x:r) -> A\,(cast~x)) \\
& ~\qquad\quad -> (y: F\;r) -> A\,(\In_{*}(\textit{fmap}_{F}\;cast\;y)) \big) 
-> (z:\mu_{*}\,f) -> A\;z
\end{array}
\]
\[
\textbf{mind}_{*} ~ \varphi ~ (\In_{*}\;x)
  ~=~ \varphi~~\textit{id}~~(\textbf{mind}_{*}~\varphi)~~x \]
\end{singlespace}\noindent
The definition of Mendler-style induction $\textbf{mind}$ shows that induction
is essentially the same as the Mendler-style primitive recursion $\MPr$,
except that the type signature involves dependent types.
Note, the final answer type $(A\;z)$ is dependent on
the recursive argument $z:\mu_{*}F$.
Since $A: \mu_{*}F -> *$ expects a concrete recursive value,
we use $cast$ in the type signature of the $\varphi$ function
to cast $(x:r)$ and $(y:F\,r)$ into $\mu_{*}F$ values, so that
they can be passed to $A$.
In the type signature of $\textbf{mind}$, $cast$ comes before $call$
because the type signature of $call$ depends on $cast$.
When defining $\MPr$, $cast$ and $call$ can come in any order
since there is no dependency in the type signature of $\MPr$.

One important thing to notice about $\textbf{mind}_{*}$ is that
it is well-defined only over positive $F$, because we relied on
the existence of $\textit{fmap}_F$ to write its type signature.
It is an open question whether one can formulate a Mendler-style induction
that works for negative datatypes.

The idea behind $\textbf{mind}_{*}$ comes from
the discussion with Tarmo Uustalu. He described this on a whiteboard
when I met with him at the University of Cambridge in Fall 2011.

In the future work section (\S\ref{sec:futwork:mprsi}), we introduce 
even another Mendler-style
recursion scheme, which is useful for mixed-variant datatypes.
The work of a Mendler stylist is never done.



\section{Type-based termination and sized types}\label{sec:relwork:sized}
\emph{Type-based termination} (coined by \citet{BartheFGPU04}) stands for
approaches that integrate termination into type checking, as opposed to
syntactic approaches that reason about termination over untyped term structures.
The Mendler-style approach is, of course, type-based.  In fact, the idea of
type-based termination was inspired by \citet{Mendler87,Mendler91}.
In the Mendler style, we know that well-typed functions defined using
Mendler-style recursion schemes always terminate.  This guarantee flows
from the design of the recursion scheme, where the use of higher-rank 
polymorphic types in the abstract operations enforce the invariants
necessary for termination.

\citet{abel06phd,Abel12talkFICS} summarizes the advantages of
type-based termination as follows:
\textbf{communication} (programmers can think using types),
\textbf{certification} (types are machine checkable certificates),
\textbf{a simple theoretical justification}
        (no additional complication for termination other than type checking),
\textbf{orthogonality} (only small parts of the language are affected,
        \eg, principled recursion schemes instead of general recursion),
\textbf{robustness} (type system extensions are less likely to
                        disrupt termination checking),
\textbf{compositionality}\footnote{This is not listed in Abel's thesis,
                                but comes from his invited talk in FICS 2012.}
        (one needs only types, not the code, for checking the termination), and
\textbf{higher-order functions and higher-kinded datatypes}
        (works well even for higher-order functions and non-regular datatypes,
        as a consequence of compositionality).
In his dissertation \cite{abel06phd} (Section 4.4) on sized types,
Abel views the Mendler-style approach as enforcing size restrictions
using higher-rank polymorphism as follows:
\begin{itemize}
\item The abstract recursive type $r$ in Mendler style corresponds to
        $\mu^\alpha F$ in his sized-type system (System \Fwhat),
        where the sized type
        for the value being passed in corresponds to $\mu^{\alpha+1} F$.
\item The concrete recursive type $\mu F$ in Mendler style corresponds to
        $\mu^\infty F$ since there is no size restriction.
\item By subtyping, a type with a smaller size index can be cast to
        the same type with a larger size index.
\end{itemize}
This view is based on the same intuition we discussed in
Chapter \ref{ch:mendler}. Mendler-style recursion schemes terminate, for
positive datatypes -- because $r$-values are direct subcomponents
of the value being eliminated. They are always smaller
than the value being passed in. Types enforce that recursive calls
are only well typed, when applied to smaller subcomponents.

Abel's System \Fwhat\ can express primitive recursion quite naturally
using subtyping. The casting operation $(r -> \mu F)$ in Mendler-style
primitive recursion corresponds to an implicit conversion by subtyping
from $\mu^\alpha F$ to $\mu^\infty F$ because $\alpha \leq \infty$.

System \Fwhat\ \cite{abel06phd} is closely related to
System \Fixw\ \cite{AbeMat04}. Both of these systems are base on
equi-recursive fixpoint types over positive base structures.
Both of these systems are able to embed (or simulate) Mendler-style
primitive recursion (which is based on iso-recursive types) via
the encoding \cite{Geu92} of arbitrary base structures into
positive base structures. In \S\ref{sec:fixi:data}, we rely on
the same encoding, denoted by $\Phi$, when embedding \MPr\ into System \Fixi.

Abel's sized-type approach provides good intuitions why 
certain recursion schemes terminate over positive datatypes.
But, it does not give a good intuition of whether or not
those recursion schemes would terminate for negative datatypes,
unless there is an encoding that can translate negative datatypes into
positive datatypes. For primitive recursion, this is possible (as we
mentioned above). However, for our recursion scheme \MsfIt, which is
especially useful over negative datatypes, we do not know of an encoding
that can map the inverse augmented fixpoints into positive fixpoints.
So, it is not clear whether Abel's the sized type approach based on
positive equi-recursive fixpoint types can provide a good intuition
for the termination behavior of \MsfIt.  In \ref{sec:futwork:mprsi},
we will discuss another Mendler-style recursion scheme (\mprsi), which
is also useful over negative datatypes and has a termination property
(not proved yet) based on the size of the index in the datatype.

\section{Logical Frameworks based on the $\lambda\Pi$-calculus}
\label{sec:relwork:LF}

based on the $\lambda\Pi$-calculus

dependently typed Logical Frameworks 

also known as Edinburgh LF \cite{TODO}

constants for types

on top of Twelf such as
But Twelf does not abstract over relations.

introduce relations involving those constants
TODO

as a functional programming language.
more generally higher-order functions, such as map or fold,
are not directly expressible in Twelf.

You can define a new type and constants involving those types in Twelf.
For example, you can define natrual numbers as follows.\footnote{
	Twelf examples are adopted from Boyland's Twelf Library on Github.\\
	$~~~~~~~$
	\url{https://github.com/boyland/twelf-library}}\vspace*{-2em}
\begin{singlespace}
\begin{verbatim}
  nat : type.       %%% define a type name
  z : nat.          %%% define a syntax for zero
  s : nat -> nat.   %%% define a syntax for sucessor
\end{verbatim}
\end{singlespace}\noindent
At this point, the constants \texttt{z} and \texttt{s} are just typed syntax.
It is not yet involved with any semantics, unlike the natively supported
inductive datatypes in Coq or Agda. So, there are no restrictions regarding
well-formnedss of these constants, such as the positivity constraint on
inductive datatypes in Coq or Agda.
You can give meanings to these natrual number syntax by defining
inductive relations over them. For example, we can define addition
as a ternery reation over natural numbers, as follows:\vspace*{-2em}
\begin{singlespace}
\begin{verbatim}
  plus : nat -> nat -> nat -> type.
  plus/z : plus z Y Y.
  plus/s : plus (s X) Y (s Z)
        <- plus X Y Z.
\end{verbatim}
\end{singlespace}\noindent
If you are famillar to Prolog, you would have noticed that
right-hand sides of the colon next to \verb|plus/z| and \verb|plus/s|
look like a Prolog program defininig addition. Twelf's meta-logic
is typed first-order relational logic.  It really is just
like pure Prolog programming at type level, but type-checked
(unlike Prolog, which is untyped).

You cannot write higer-order relations natively in Twelf
because Twelf's meta-logic is first-order, not higher-order.
To write a program using higher-order functions in Twelf, one has to model
one's own object language that supports higher-order functions, and program
within that object language, rather than programming in twelf's meta-logic.
Here are the summarized steps to program using higher-order functions in Twelf:
\begin{itemize}
\item[(1)] Define an object language syntax
(as you define the syntax \texttt{z} and \texttt{s} for natural numbers)
with bindings (this is done by HOAS), applications, and
whatsoever you would need express higher-order functions.
\item[(2)] Define the evaluation semantics of your object language using
        inductive relations (\ie, write an evaluator for
        your object language in a Prolog-like way).
\item[(3)] Write the program in the object language by putting
        together pieces of the syntax you defined in (1).
\item[(4)] Finally, you can evaluate your program by reasoning based on
        the evaluation relation defined in (2).
\end{itemize}
This is clearly an overkill if what you wanted was just to ``program''
with higher-order functions in a type-safe way, and possibly with some
termination guarantee, but you don't really need to reason about
the meta-theory of the object functional language in general.

Beluga \cite{Pie10} is similar to Twelf but it is more closer to
a functional language since the inductive definitions are functional,
rather than relational, and supports higher-order functions. 
One can to write higher-order functions (\eg, map, fold) in Beluga
almost the same way as in functional programming languages, except
a few tedious bookkeeping of context objects. Since Beluga has access
to context objects, we think it can express what \MsfIt\ can express,
and in addition, it can also express what \textbf{openit} (\S\ref{sec:openit})
can express.

Regarding higher-order functions, Beluga is in a much better position
than Twelf. In Twelf, one needs to create a whole new object-level
functional programming language by describing its semantics with
inductive relations in order express higher-order functions.
Termination is not type based in Beluga either. Like Twelf, it needs
an external termination (or totality) checker, but its prototype
implementation currently lacks a termination (or totality) checker.


Delphine \cite{pos08phd} TODO
Delphine has a termination checker based on lexicographic subterm ordering.

lambda pi calculus

term-indexing and term-dependency 
but lack polymorphism

System \Fi\
term-indexing and polymorhpism
but lack term-dependency.


termination checking is not type based

%% 
%% \section{TODO}

