\chapter{Type Inference in Nax} \label{ch:naxTyInfer}
Type inference for a language supporting indexed datatypes are
known to be difficult, and it becomes more difficult when the language
supports wider range of indexed datatypes. Here, in this chapter, we
illustrate the key idea that enables a conservative extension of
Hindley-Miler type inference. We will not be as formal and detailed
on proofs as we did for HM in \S\ref{sec:hm}. We extrapolate from
the properties of HM that the same property should hold for
a small subset of Nax, which is structurally similar to HM.
Then, we will argue that some key new features in Nax, which are
not present in HM preserves those properties.

The \emph{index transformers}, which are type annotations on
the pattern matching constructs, plays a key role in inferring types for
Nax programs involving indexed datatypes. We introduce a small subset of Nax,
SmallNax, only considering non-recursive equational datatypes but omitting
other details of Nax (\S\ref{sec:naxTyInfer:psi}). Next, we extend SmallNax
with recursive types and Mendler-style iteration, describe their kinding and
typing rules, and discuss the role of index transformers for type inference
(\S\ref{sec:naxTyInfer:rec}). Then, we discuss how we treat other Nax features
such as GADT-style definitions and term indices in our implementation
(\S\ref{sec:naxTyInfer:gadt}).

\section{SmallNax}
\label{sec:naxTyInfer:psi}
The syntax of SmallNax is illustrated in Definition\;\ref{def:SmallNax},
its kinding and typing rules are illustrated in Figure\;\ref{fig:SmallNax}.
\begin{definition}[Syntax of SmallNax]
\label{def:SmallNax}
\begin{singlespace}
\begin{align*}
&\textbf{Term}&
t,s&~::= ~ x
    ~  | ~ \l x    . t 
    ~  | ~ t ~ s       
    ~  | ~ \<let> x=s \<in> t
    ~  | ~ C
    ~  | ~ \varphi^\psi
%%    ~  | ~ \<case>_{\!\!\psi}\; s \<of> \overline{C \overline{x} -> t}
\\
&\textbf{Type constructor}&
F,G,A,B&~::= ~ X
        ~  | ~ A -> B            
        ~  | ~ T
        ~  | ~ F ~ G
\\
&\textbf{Type scheme}&
\sigma&~::= ~ \forall X^\kappa.\sigma
       ~  | ~ A
\end{align*}
\end{singlespace}
\end{definition}
\begin{definition}[Type scheme ordering (or, generic instantiation)]
\label{def:SmallNaxGInst}
\framebox{$\sigma \sqsubseteq_\Delta \sigma'$}
\[
 \inference[\sc GInst]{
    X_1',\dots,X_m'\notin\FV(\forall X_1^{\kappa_1}\dots X_n^{\kappa_n}.\sigma)
    \\
    \Delta |- \forall X_1^{\kappa_1}\dots X_n^{\kappa_n}.\sigma : *
    &
    \Delta |- \forall X_1'^{\kappa_1'}\dots X_m'^{\kappa_m'}.\,A[F_1/X_1]\cdots[F_n/X_n] : *
  }{\forall X_1^{\kappa_1}\dots X_n^{\kappa_n}.\sigma \;\sqsubseteq_\Delta\;
    \forall X_1'^{\kappa_1'}\dots X_m'^{\kappa_m'}.\,A[F_1/X_1]\cdots[F_n/X_n]} \]
~
\end{definition}

The syntax of SmallNax is similar to the syntax of 
the Hindley--Milner type system (HM) in \S\ref{sec:hm}.
SmallNax has data constructors ($C$) and case functions ($\varphi^\psi$)
in addition to the terms of HM. A case function $\varphi^\psi$ is
a list of alternatives ($\varphi ::= \overline{C \overline{x} -> t}$)
annotated with an index transformer $\psi$.\footnote{Our Nax implementation
	supports nested patterns (\eg, $(C_1\,x_1\,(C_2\,x_2)\,x_3$), but
	SmallNax only allows simple patterns (\ie, data constructor
	followed by variables) in alternatives.}
The case expression $\textbf{case}_\psi\;s\<of> \varphi$ in Nax
correspond to $\varphi^\psi\;s$, an application of the case function
($\varphi^\psi$) to the scrutinee ($s$). Considering case expressions as
applications simplifies the typing rules because we do not need
a separate typing rule for case expressions. In addition to the types of HM,
the type constructor syntax in SmallNax includes type constructor names ($T$)
and type constructor applications ($F\;G$). Type schemes in SmallNax 
($\forall X^\kappa.\sigma$) is similar to the type schemes ($\forall X.\sigma$)
in HM, but the universally quantified type variable ($X$) is annotated with
its kind ($\kappa$).

We assume that type constructor names and their associated data constructors
are introduced into the context by preprocessing non-recursive equational
datatype definitions. For example,
$\textbf{data}\;\texttt{Maybe}\;a = \texttt{Just}\;a \mid \texttt{Nil}$
introduces a type constructor name \texttt{Maybe} and its associated
data constructors \texttt{Just} and \texttt{Nil} into the context
($\Delta$ and $\Gamma$ in Figure\;\ref{fig:SmallNax}). That is,
$\texttt{Maybe}^{* -> *} \in \Delta$ and
$\texttt{Just}: \forall X_a^{*}.X_a -> \texttt{Maybe}\,X_a,~
 \texttt{Nil} : \forall X_a^{*}.\texttt{Maybe}\,X_a \in \Gamma$.
Data constructors introduced from an equational datatype definition have
uniform return types ($T\;\overline{X}$) and no existential variables
in their types. For instance, return types of both \texttt{Just} and
\texttt{Nil} have the form of $\texttt{Maybe}\,X_a$. For such non-recursive
equational datatype definitions, index transformer annotations are not needed.
So, we either omit the annotation on the case function ($\varphi$) or
write a dot ($\varphi^\cdot$). We will really need index transformers
to infer types involving recursive datatypes (\S\ref{sec:naxTyInfer:rec})
and GADTs (\S\ref{sec:naxTyInfer:gadt}).

\begin{figure}
\begin{singlespace}
\[ \textbf{Kinding rules} \quad \framebox{$ \Delta |- F:\kappa$}\]\vspace*{-2em}
\begin{align*}
& \inference[\sc TVar]{X^\kappa \in \Delta}{\Delta |- X:\kappa} &
& \inference[\sc TArr]{\Delta |- A:* & \Delta |- B:*}{\Delta |- A -> B:*} \\
& \inference[\sc TCon]{T^\kappa \in \Delta}{\Delta |- T:\kappa} &
& \inference[\sc TApp]{\Delta |- F : \kappa -> \kappa' & \Delta |- G : \kappa}
                      {\Delta |- F ~ G : \kappa'}
\end{align*}
\begin{align*}
&\textbf{Declarative typing rules}&\quad
&\textbf{Syntax-directed typing rules}
        \\
& \qquad\framebox{$\Delta;\Gamma |- t : \sigma$}
&
&~\qquad\framebox{$\Delta;\Gamma |-s t : A$}
        \\
& \inference[\sc Var]{x:\sigma \in \Gamma}{\Delta;\Gamma |- x:\sigma} &
& \inference[\sc Var$_s$]{x:\sigma \in \Gamma & \sigma \sqsubseteq_\Delta A}
                         {\Delta;\Gamma |-s x:A} \\
& \inference[\sc Abs]{\Delta |- A:* \\ \Delta;\Gamma,x:A |- t : B}
                     {\Delta;\Gamma |- \l x   .t : A -> B} &
& \inference[\sc Abs$_s$]{\Delta |- A:* \\ \Delta;\Gamma,x:A |-s t:B}
                         {\Delta;\Gamma |-s \l x   .t : A -> B} \\
& \inference[\sc App]{\Delta;\Gamma |- t : A -> B \\ \Delta;\Gamma |- s : A}
                     {\Delta;\Gamma |- t~s : B} &
& \inference[\sc App$_s$]{\Gamma |-s t : A -> B \\ \Gamma |-s s : A}
                         {\Gamma |-s t~s : B} \\
& \inference[\sc Let]{ \Delta;\Gamma |- s : \sigma \\
                       \Delta;\Gamma,x:\sigma |- t : B}
                     {\Delta;\Gamma |- \<let> x=s \<in> t : B} &
& \inference[\sc Let$_s$]
            { \Delta;\Gamma |-s s : A \\
              \Delta;\Gamma,x:\overline{\Delta;\Gamma}(A) |-s t : B}
            {\Gamma |-s \<let> x=s \<in> t : B} \\
& \inference[\sc Inst]{ \Delta;\Gamma |- t : \sigma
                      & \sigma \sqsubseteq_\Delta \sigma'}
                      {\Delta;\Gamma |- t : \sigma'} &
&\quad \begin{smallmatrix}\overline{\Delta;\Gamma}(A)=\forall\vec{X}.A
                         ~\text{where}~\vec{X}=\FV(A)\setminus\dom(\Delta)\setminus\FV(\Gamma)
                 \end{smallmatrix}
                 \\
& \inference[\sc Gen]{\Delta,X^\kappa;\Gamma |- t : \sigma}
                     {\Delta;\Gamma |- t : \forall X^\kappa.\sigma}
                     ~ \text{\small$(X \notin\FV(\Gamma))$} &
& \\
& \inference[\sc Con]{C:\sigma \in \Gamma}{\Delta;\Gamma |- C:\sigma} &
& \inference[\sc Con$_s$]{C:\sigma \in \Gamma & \sigma \sqsubseteq_\Delta A}
                         {\Delta;\Gamma |-s C:A} \\
& \inference[\sc Case]{
              \overline{\Delta;\Gamma |-^\psi C\overline{x} ->t : \sigma}
          }{\Delta;\Gamma |- (\overline{C\overline{x} -> t})^\psi : \sigma } &
& \inference[\sc Case$_s$]{
	      \overline{\Delta;\Gamma |-s^\psi C\overline{x} ->t : \sigma} &
              \sigma \sqsubseteq_\Delta A
          }{\Delta;\Gamma |- (\overline{C\overline{x} -> t})^\psi : A } \\
& \qquad\framebox{$\Delta;\Gamma |-^\psi C\overline{x} -> t : \sigma$} &
& \qquad\framebox{$\Delta;\Gamma |-s^\psi C\overline{x} -> t : \sigma$} \\
& \inference*[\sc Alt]{
              \Delta;\Gamma |- C:\overline{A} -> T\overline{B}\,\overline{A'} \\
              \Delta;\Gamma,\overline{x:A} |- t : \psi(\overline{A'})
            }{ \begin{array}{ll}\Delta;\Gamma |-^\psi C\overline{x} -> t \\
                \qquad : \forall\overline{X^\kappa}.
                          T\overline{B}\,\overline{X} -> \psi(\overline{X})
               \end{array} } &
& \inference*[\sc Alt$_s$]{
             \Delta;\Gamma |-s C:\overline{A} -> T\overline{B}\,\overline{A'} \\
             \Delta;\Gamma,\overline{x:A} |-s t : \psi(\overline{A'})
           }{ \begin{array}{ll}\Delta;\Gamma |-s^\psi C\overline{x} -> t \\
               \qquad : \forall\overline{X^\kappa}.
                         T\overline{B}\,\overline{X} -> \psi(\overline{X})
              \end{array} }
\end{align*}
\caption{Kinding and typing rules of SmallNax}
\label{fig:SmallNax}
\end{singlespace}
\end{figure}

\paragraph{Declarative typing rules and syntax-directed typing rules.}
The typing rules of SmallNax (Figure\;\ref{fig:SmallNax}),
excluding the rules for datatypes (\rulename{Con}, \rulename{Case},
\rulename{Alt} in the declarative rules and their corresponding
syntax-directed rules), are structurally similar to the typing rules of HM
(Figure\;\ref{fig:hm}). Each of those typing rules in SmallNax has
its corresponding typing rule with the same name in HM.
The difference from HM are the existence of kinding rules to ensure
well-kindedness of type constructors (which can have kind other than $*$)
and the additional context $\Delta$ in the typing rules to keep track of
whether type constructor variables are in scope with correctly assigned kinds.
The generic instantiation rule (\rulename{GInst}) also takes $\Delta$ into
consideration so that both sides of $\sqsubseteq$ are well-kinded.
We can view HM as a restriction of SmallNax (excluding datatypes)
where kinds are always $*$. So, we know that the syntax-directed typing rules
(excluding \rulename{Con$_s$}, \rulename{Case$_s$}, \rulename{Alt$_s$})
are sound (Theorem\;\ref{thm:sdSmallNaxSound}) and
complete (Theorem\;\ref{thm:sdSmallNaxComplete})
with respect to the declarative typing rules
(excluding \rulename{Con}, \rulename{Case}, \rulename{Alt}) in SmallNax.
\begin{theorem}[$|-s$ is sound with respect to $|-$]
$ \inference{\Delta;\Gamma |-s t : A}{\Delta;\Gamma |- t : A} $
\label{thm:sdSmallNaxSound}
\end{theorem}
\begin{theorem}[$|-s$ is complete with respect to $|-$] ~
\begin{center}
$ \inference{\Delta;\Gamma |- t : \sigma}{
	\exists A.\;\Delta;\Gamma |-s t : A ~\land~
	\overline{\Delta;\Gamma}(A) \sqsubseteq_\Delta \sigma} $
\end{center}
\label{thm:sdSmallNaxComplete}
\end{theorem}

We have argued that Theorem\;\ref{thm:sdSmallNaxSound} and
Theorem\;\ref{thm:sdSmallNaxComplete} holds for all the typing rules
in SmallNax excluding the rules for datatypes. So, we only need to check
whether these two theorems hold for the rules for datatypes, that is,
for the declarative rules \rulename{Con}, \rulename{Case}, and \rulename{Alt},
and, their syntax-directed counterparts \rulename{Con$_s$}, \rulename{Case$_s$},
and \rulename{Alt$_s$}. They obviously hold for the rules \rulename{Con} and
\rulename{Con$_s$} because these rules have exactly the same structure as 
\rulename{Var} and \rulename{Var$_s$}. Once we know that \rulename{Alt} is
sound and complete with respect to \rulename{Alt$_s$}, it is quite
straightforward to show that \rulename{Case} is sound and complete
with respect to \rulename{Case$_s$} because the typing one can get
from \rulename{Case$_s$} is a generic instantiation of the typing
one can get from \rulename{Case}. It is indeed the case that
\rulename{Alt} is sound and complete with respect to \rulename{Alt$_s$}
because they have exactly the same structure. Unlike other syntax-directed
typing rules of the form $\Delta;\Gamma |-s t : A$, which
assignees a type to a monomorphic type ($A$), the rule \rulename{Alt$_s$}
of the form $\Delta;\Gamma |-s^\psi C\overline{x} -> t : \sigma$
assigns a polymorphic type scheme ($\sigma$). Since \rulename{Alt} and
\rulename{Alt$_s$} has exactly the samem structure, one caling on $|-$
and the other calling on $|-s$ in their premises, they must be sound
and complete with respect to each other.

\paragraph{SmallNax is strongly normalizing and logically consistent.}
The type system of SmallNax is sound with respect to System \Fw.
That is, when $\Delta;\Gamma |- t:\sigma$ in SmallNax, then 
$\Delta;\Gamma |- t:\sigma$ in System \Fw.
Considering the let-term ($\<let> x=s \<in> t$) as a syntactic sugar of
a lambda term applied to the scrutinee ($(\l x.t)\,s$), the terms of SmallNax,
except data constructors and case expressions, are exactly the same as
the term of the Curry-style System \Fw, which we discussed in \S\ref{sec:fw}.
For SmallNax terms involving data constructors and case expressions, we use
the Church encoding to translate those SmallNax terms into System \Fw\ terms.
We show the soundness of typing with respect to System \Fw\ by reasoning about
the declarative typing rules. Recall that we discussed
the soundness of typing for HM with respect to System \F\ by reasoning about
the declarative typing rules of HM in \S\ref{sec:hm}.

The kinding and typing rules, except those rules for datatypes, are admissible
in System \Fw. The kinding rules except \rulename{TCon} are exactly the same as
the kinding rules with the same name in System \Fw\ (see Figure\;\ref{fig:fw}
on p\pageref{fig:fw}). The declarative typing rules except \rulename{Con},
\rulename{Case}, \rulename{Alt} are admissible in System~\Fw. The rules
\rulename{Var}, \rulename{Abs}, \rulename{App}, \rulename{Gen}\footnote{
	The \rulename{Gen} rule in SmallNax corresponds to
	the \rulename{TyAbs} rule in the Curry-style System \Fw
	(see Figure\;\ref{fig:fw}). The other rules, \rulename{Var},
	\rulename{Abs}, \rulename{App} corresponds to the rules with
	the same name same name in the Curry-style System \Fw. }
are exactly the same as the typing rules of the Curry-style System \Fw.
We can show that the rules \rulename{Let} and \rulename{Inst} in SmallNax are
admissible in System \Fw\ by following virtually the same argument, which
we used show that the rules \rulename{Let} and \rulename{Inst} in HM are
admissible in Sytem \F\ (see p\pageref{hm:LetAdmissibleFw} in \S\ref{sec:hm}).
The \rulename{Let} rule in SmallNax corresponds to a consecutive use of
\rulename{App} and \rulename{Abs} in System \Fw. A single derivation step of
\rulename{Inst} in SmallNax corresponds to multiple uses of \rulename{TyAbs}
and \rulename{TyApp} rules in System \Fw.

The kinding and typing rules involving datatypes (\rulename{TCon},
\rulename{Con}, \rulename{Case}, and \rulename{Alt}) can be understood as
being admissible in System \Fw\ via the Church encodings of datatypes.
In \S\ref{sec:f:data} and \S\ref{sec:fw:data}, we discussed
how non-recursive datatypes (\eg, unit, void, boolean, sums, products)
can be encodded as functions. The rules \rulename{TCon}, \rulename{Con},
\rulename{Case}, and \rulename{Alt} are compatible with those encodings.
Thus, the type system of SmallNax, described in Figure\;\ref{fig:SmallNax},
is sound with respect to System \Fw.
Therefore, SmallNax is strongly normalizing and logically consistent.

\paragraph{From System \Fw\ to SmallNax}
We will discuss informal and high-level design concepts of what restrictions
from System \Fw\ make SmallNax feasible for type inference, rather than
formally discussing concrete type inference algorithms. There are two
restrictions from System \Fw, rank-1 polymorphism and type constructor names,
which makes type inference decidable in SmallNax. In addition, we discuss
the role of index transformer in type inference. Although index transformers
are not essential for pattern matching of datatypes defined by non-recursive
equations, it does play essential roles in inferring types of recursive
datatype definitions and GADT-style datatype definitions.

Let us review what restriction from System \F\ makes HM (without recursion)
feasible for type inference. Type inference is undecidable in System \F\ 
due to its arbitrary rank polymorphism (\ie, polymorphic types can appear
arbitrary deep inside type constructor arguments, in particular, inside
the left-hand side of $->$). Type inference becomes decidable in HM
by restricting the polymorphism to be rank-1 (\ie, universal quantification
can only appear at the top level). Similarly, we restrict the polymorphism
to be rank-1 in SmallNax (see Definition\;\ref{def:SmallNax}).

In addition to arbitrary rank polymorphism, type abstractions ($\l X^\kappa.F$)
in System \Fw\ is another feature that makes type inference undecidable.
Type inference algorithms involving type abstractions would require
higher-order unification (\ie, unification involving reconstruction of
function implementation), which is known to be undecidable \cite{Gol81}.
In SmallNax, we can avoid higher-order unification because there are no
type abstractions. Datatypes in SmallNax are introduced into the context
as primitives, that is, type constructor names into $\Delta$ and
their associated data constructors into $\Gamma$. So, we only need
first-order unification for inferring types in SmallNax.

\section{Extending SmallNax with Mendler-style recursion}
\label{sec:naxTyInfer:rec}
TODO We first review and go on

\subsection{A review of monomorphic recursion and polymorphic recursion}
The Hindley--Milner type system (HM) \cite{DamMil82} supports
monomorphic (general) recursion by assigning a monomorphic type ($A$)
to the recursive variable ($x$), as described in the rule \rulename{Fix-m}
below right.\footnote{
	In \S\ref{sec:hm}, we excluded the general recursion in
	our formalization of HM, although its original presentation
	has general recursion, because our language does not support
	general recursion.}
The Milner--Mycroft type systems (MM) \cite{Myc84} supports
polymorphic recursion by assigning a polymorphic type ($\sigma$)
to the recursive variable ($x$), as described by in the rule \rulename{Fix-p}
below left.
\[
\qquad
\inference[\sc Fix-m]{\Gamma,x:A |- t : B}{
	\Gamma |- \textbf{fix}\;x.t : B}
\qquad
\inference[\sc Fix-p]{\Gamma,x:\sigma |- t : \sigma}{
	\Gamma |- \textbf{fix}\;x.t : B}
\]
Polymorphic recursion is necessary for writing recursive programs involving
nested datatypes. However, type inference for MM, which supports polymorphic
recursion, is known to be undecidable \cite{Hen93}.

What makes HM (including \rulename{Fix-m}) peculiarly suitable for
type inference while type inference for MM is undecidable?
\citet{Hen93} summarizes the peculiarity of HM is that occurrences of
a recursive definition ``\emph{inside} the body of its definition can
only be used \emph{monomorphically}'' whereas occurrences ``\emph{outside}
its body can be used \emph{polymorphically}''.

\subsection{Typing rules for recursion combinators in SmallNax}
We design the typing rules for recursion combinators in SmallNax
(Figure\;\ref{fig:SmallNaxRec}) based on a similar idea to
what makes HM suitable for type inference.
What makes SmallNax (including the \rulename{mit} rule) to be suitable
for type inference is that the \emph{type parameters} of
the recursive function argument are \emph{monomorphic} whereas
the \emph{type indices} are \emph{polymorphic} inside the body of
the recursive function definition. Outside the body, the recursive function
can be used polymorphically over both type parameters and type indices.

\begin{figure}
\inference[\sc mit]{\Delta;\Gamma,x:\sigma |- \varphi^\psi : \sigma}{
	\Delta;\Gamma |- \MIt_\kappa\;x\;\varphi^\psi: \sigma}
\caption{SmallNax extended with $\mu_\kappa$ and $\MIt_\kappa$}
\label{fig:SmallNaxRec}
\end{figure}

TODO short reminder of type indices and type parameters

\section{TODO TODO}
\label{sec:naxTyInfer:gadt}
TODO
existential type variables
weak existential type variables
TODO

