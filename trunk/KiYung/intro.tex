\chapter{Introduction}\label{ch:intro}

\section{TOOD}\label{sec:intro:TODO}

the Curry-Howard correspondence
Mendler-style recursion schemes and term-indexed types

\section{TOOD}\label{sec:intro:TODO}

\section{TOOD}\label{sec:intro:TODO}

\section{Contributions}\label{sec:intro:contrib}
This dissertation makes contributions in several areas.
\begin{itemize}
\item[1.]
It organizes and expands the realm of \emph{Mendler-style recursion schemes}
(Part~\ref{part:Mendler}, \ie, Chapter \ref{ch:mendler})

\item[2.] It establishes a meta-theories for \emph{term-indexed types}
        (Part~\ref{part:Calculi}),

\item[3.] It designs a practical language (with an implementation)
	\emph{in the sweet spot} between programming and logical reasoning
	(Part~\ref{part:Nax}), and

\item[4.] It identifies several interesting open problems related to above.
\end{itemize}

\subsection{Contributions related to the Mendler style}
We organize a hierarchy of Mendler-style recursion schemes in two dimensions.
The first dimension is the abstract operations they support. For instance,
the Mendler-style iteration (\MIt) supports a single abstract operation
the recursive call. All the other Mendler-style recursion schemes
support the recursive call and an additional set of abstract operations. 
The second dimension is over the kind of the datatypes they operate over.
For example, \texttt{Nat} has kind $*$, while \texttt{Vec}
has kind $* -> \mathtt{Nat} -> *$. Each recursion scheme is actually a
family of recursion combinators sharing the same term definition
(\ie, uniformly defined) but with different type signatures at each kind.

We expand the realm of Mendler-style recursion schemes in several ways.
First, we report on a new recursion scheme $\MsfIt$, which is useful
for negative datatypes.  Second, we study the termination behaviors
of Mendler-style recursion schemes. Some recursion schemes (\eg, \MIt, \MsfIt)
always terminate for any recursive type, while others (\eg, \McvPr) only
terminate for certain classes of recursive types. Third, we extend
all Mendler-style recursion schemes to be expressive over term-indexed types.
The Mendler style has been studied in the context of \Fw\ (and several
extensions) which can express type-indexed types. To extend Mendler-style
recursion schemes to be expressive over term-indexed types, we report on
several theories for calculi (\Fi\ and \Fixi) that support term indices.
This is another important area of our contribution.

In addition, we develop a better understanding of some existing
Mendler-style recursion schemes. For instance, the existence of
Mendler-style course-of-values recursion (\McvPr) is reported
in the literature, but the calculus that can embed \McvPr\ was unknown.
We embed Mendler-style course-of-values recursion into \Fixi
(or into \Fixw, when we do not consider term-indices).

\subsection{Contributions to the theory of Term-Indexed Types}
Mendler-style recursion schemes have been studies in the context of
polymorphic lambda calculi. For instance, \citet{AbeMatUus03} embedded 
Mendler-style iteration (\MIt) into \Fw\ and \citet{AbeMat04} embedded
Mendler-style primitive recursion (\MPr) into \Fixw. These calculi
support type-indexed types.

To extend the realm of Mendler-style recursion schemes to include
term-indexed types, we extended \Fw\ and \Fixw\ to support term indices.
In Part \ref{part:Calculi}, we present our new calculi
\Fi\ (Chapter \ref{ch:fi}), which extends \Fw\ with term indices, and
\Fixi (Chapter \ref{ch:fixi}), which extends \Fixw\ with term indices.
These calculi have an erasure property that states that well-typed terms
in each calculus are also well typed terms (when erased) in the 
underlying calculus. For instance, any well typed term in \Fi\ is also
a well-typed term in \Fw, and there are no additional well-typed terms
in \Fi\ that are not well-typed in \Fw.

Our new calculi, \Fi\ and \Fixi, are strongly normalizing and
logically consistent. We show strong normalization and logical consistency
using the erasure properties. That is, strong normalization and
logical consistency of \Fi\ and \Fixi\ are inherited from \Fw\ and \Fixw.
Since \Fi\ and \Fixi\ are strong normalizing and logically  consistent,
the Mendler-style recursion schemes that can be embedded into these calculi
are adequate for logical reasoning as well as programming.

\subsection{Contributions in the design of the Nax language}
We design and implement a prototypical language Nax that explores
the sweet spot between programming oriented systems and logic oriented systems.
The language features supported by Nax provide the advantages
of both programming oriented systems and logic oriented systems.
Nax supports both term- and type-indexed datatypes,
rich families of Mendler-style recursion combinators,
and a conservative extension of Hindley--Milner type inference.
We designed Nax so that its foundational theory and
implementation framework could be kept simple.

Term- and type-indexed datatypes can express fine grained program properties
via the Curry--Howard correspondence, as in logic oriented systems. Although
not as flexible as full-fledged dependent types, indexed datatypes can
still express program invariants, such as type preserving compilation,
and size invariants on data structures. Index types can simulate much of what
dependent types can do using singleton types. Since Nax has only erasable
indices, the foundational theory can be kept simple, and it supports
features that have the advantages of programming oriented systems 
(\eg, type inference, arbitrary recursive datatypes).

Adopting Mendler style provides merits of both programming oriented systems
and logic oriented systems. Since Mendler style is elimination based, one can
define all recursive datatypes usually supported in functional programming
languages. In addition, the programs written using Mendler-style recursion
combinators look more similar to the programs written using general recursion
than programs written in Squiggol style.
Since Nax supports only the well-behaved (\ie, strongly normalizing)
Mendler-style recursion combinators, it is safe to construct proofs using them.
In addition, Mendler-style recursion combinators are naturally well-defined
over indexed datatypes, which are essential to express fine-grained program
properties. Mendler style provides type based termination, that is, termination
is a by-product of type checking. Thus, it makes the implementation framework
simple since we do not need extra termination checking theories or algorithm.

Hindley--Milner-style type inference provides a familiar programming experience
to the programmers who are already familiar to functional programming languages.
Nax can infer types for all the programs that involve only regular datatypes,
which are already inferable in Hindley--Milner, without any type annotation.
Nax requires programs involving indexed datatypes to annotate their eliminators
by index transformers, which annotate the relation between the input type index
and the result type. Eliminators of non-recursive datatypes are case expressions
and eliminators of recursive datatypes are Mendler-style recursion combinators.

\subsection{Contributions of identifying open problems}
TODO identified open problems

syntactic conditions form \McvPr


some recursion schemes does not mix well -- sf and pr

is there a useful example for sfcvit

is there a useful example for msfit positive datatypes?


\section{Organization of the Chapters}\label{sec:intro:org}
TODO

\begin{comment}
In my dissertation, I will contribute to answering the question
``how does one build a seamless system where programmers
can both write (functional) programs
and formally reason about those programs.''
I will introduce the motivation for pursuing such a system
in \S\ref{sec:motiv},
and I will also discuss foundational work upon which
the approach developed in my thesis is based.

\section{Motivation} \label{sec:motiv}

\section{Thesis}
In my dissertation, I will contribute to answering the question
``how does one build a seamless system where programmers
can both write (functional) programs
and formally reason about those programs.'' In Chapter \ref{ch:relwork},
I will introduce the motivation for pursuing such a system.
I will discuss other approaches to building such a system,
and I will also discuss foundational work upon which
the approach developed in my thesis is based.
The following is my thesis statement, which summarizes my
approach:
\begin{quote}
A language equipped with \emph{term indexed types} and
\emph{Mendler-style recursion combinators} can be 
(1) a basis for \emph{sound and consistent logic}
suitable for reasoning about properties of (functional) programs
and also
(2) a basis for a \emph{simple and expressive programming language}
suitable for writing the (functional) programs to be reasoned about.
\end{quote}

I believe such an approach is promising because, under the design I will
promote, both the logic and the programming language share many
common features. Amongst those features are the two design concepts
of indexed types and Mendler-style recursion combinators.

\emph{Term indexed types} are types indexed by terms. The concept of
term indexed types can be informally understood by contrasting the traditional
(non-indexed) polymorphic list type (\textsf{List} $a$) and a length indexed
(and also polymorphic) list type (\textsf{Vec} $a$ $n$). The polymorphic list
type (\textsf{List} $a$) is parametrized by a type variable ($a:*$), which can
be instantiated to any type. Example instantiations include \textsf{List Nat},
\textsf{List Bool}, and \textsf{List} (\textsf{List Nat}).

A length indexed list type (\textsf{Vec} $a$ $n$) is not only parametrized by
a type variable ($a:*$) but also indexed by a term variable ($n:\textsf{Nat}$),
which can be instantiated to a natural number term. Example instantiations
include \textsf{Vec Int} 3, and \textsf{Vec Bool} $(2+3)$. Types like
\textsf{Vec} are called term indexed types since their type constructors
(\eg, \textsf{Vec}) expect term arguments (\eg, $3$, $(2+3)$). 
With term indexed types, we can express many fine-grained properties of
programs (\eg, reversing a length indexed list preserves its length).

\emph{Mendler-style recursion combinators} are principled recursion schemes,
which are used as induction principles in the logic, and recursion operators
in the programming language. There exist many families of Mendler-style
recursion combinators. Each member of a family performs the same kind of
operation, but is specialized to work over type constructors with
a particular kind. The primitive recursion combinator family was first
discovered by Mendler \cite{Mendler87}. Since that time, several other
kind-dependant families \cite{vene00phd,AbeMatUus03,AhnShe11} have been
discovered to be both expressive and useful.

Mendler-style recursion combinators do have counterparts in the conventional
(sometime called the Squiggol) style. The conventional style combinators are
more widely known and used. But, Mendler-style combinators have several
advantages when compared to conventional style combinators. Mendler-style
recursion combinators have uniform representation over both non-indexed types
and term indexed types, and some families of the Mendler-style recursion
combinators are normalizing for non-positive recursive types as well as
positive recursive types. Detailed discussion on the Mendler-style recursion
combinators can be found in Chapter \ref{ch:mendler}.

Throughout my dissertation, I will support my thesis by designing a series of
language systems of increasing complexity. The goal is that each system can be
used as a \emph{sound} and \emph{consistent} logic, and each system can be
extended to a \emph{simple} and \emph{expressive} (functional) programming
language. Usually, an increase in complexity, leads to a more complete
extension from logic to programming language. Some programming language features
will never be found in a sound logic, and the increase in complexity is designed
to cleanly separate the boundary between the logic and programming language.

The approach I will use is two layered. I will develop an underlying calculus,
and a surface language, which are closely related to each other. I call the
underlying typed lambda calculus System \Fi. It captures the essence of a sound
and consistent logic in the presence of term indexed types. At the same time,
I am designing a simple and expressive language called Nax, whose semantics
is closely related to \Fi\ (in fact, it was designed to be defined in terms of \Fi), but whose
features are restricted in order to make its use more appealing to programmers
than the underlying \Fi\ calculus.

By ``\emph{sound}'', I mean the type soundness of typed lambda calculi
in the usual sense. By ``\emph{consistent}'', I mean not all types are
inhabited by a term. Using the Curry-Howard correspondence, types are
interpreted as propositions, and terms of those types, are interpreted as
proofs of those propositions. Thus, it is in fact the usual sense of
logical consistency -- not all propositions are provable. Since consistency
requires normalization, System \Fi, the language to be developed for the sound
and consistent logic, is indeed a normalizing typed lambda calculus. I will
discuss the features of \Fi\ in detail in Chapter \ref{ch:fi}. Then, in my
dissertation, I will gradually extend \Fi\ to a more expressive calculi \Fixi\
in order to support the Mendler-style combinators of the primitive recursion
family. The features of \Fixi\ are also outlined in Chapters \ref{ch:fi}
and Chapter \ref{ch:fixi}.

By ``\emph{simple}'', I mean that writing programs in the surface language
should require no more complication than writing similar programs in one of
the widely used typed functional programming languages (\eg, Haskell, ML).
In particular, the Nax language we have designed so far, conservatively
extends Hindley-Milner type inference to term indexed types. That is,
all the functional programs involving regular (non-indexed) datatypes, 
whose types are inferable in a Hindley-Milner type system, will need
no additional type annotation to infer their types in Nax. For programs
with richer type structure, involving term indexed types, Nax will require
a small amount of type annotation, in predictable syntactic positions,
which will be required by the language syntax.

By ``\emph{expressive}'', I mean we can write a wide range of examples in Nax.
Since Nax is equipped with Mendler-style recursion combinators, we can write
many useful programs over values with both term indexed types and
negative recursive types, as well as over values with non-indexed types and
positive recursive types. I will discuss the details of Nax
in Chapter \ref{ch:nax}.

However, we cannot express all the programs in Nax. For example,
non-terminating programs using general recursion are not expressible since
Nax is a normalizing language. We know that Nax is normalizing, because
by design, it will be embeddable into \Fi, which is known to be normalizing.
In other words, Nax programs always terminate and can be interpreted logically.
To extend Nax to a Turing complete programming language, we would need to
extend the language with constructs that cannot be interpreted logically,
such as general recursion. When we add such constructs, and if we still wish
to reason logically about the program properties within the language system,
the type system of the language will need to be extended to keep track of
which parts of a program can be interpreted logically and which parts cannot.
There are other possible extensions to Nax that may not necessarily introduce
non-logical fragments but will make Nax more convenient to program in (\eg,
polymorphism at the kind level, as well as the type level, and exceptions).
I will discuss such possible further extensions to Nax
in Chapter \ref{ch:futwork}.

\end{comment}


