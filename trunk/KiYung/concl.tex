\chapter{Conclusions}\label{ch:concl} In this final chapter, we conclude the
dissertation by restating our thesis and summarizing the research in prior
chapters (\S\ref{sec:concl:summary}) which support it. We also emphasize
the significance of our contributions (\S\ref{sec:concl:sig}), and outline the
limitations of our research (\S\ref{sec:concl:fw}).

\section{Summary}\label{sec:concl:summary}
Our thesis is that a language design based on
\emph{Mendler-style recursion schemes} and \emph{term-indexed types}
leads  to a system in \emph{the sweet spot} that seamlessly unifies
functional programming and logical reasoning
(via the Curry--Howard correspondence).
In Chapter \ref{ch:intro}, we characterized \emph{the sweet spot} by
the four features that the unified language system should support.
They are: (1) a \emph{convenient programming style},
(2) an \emph{expressive logic}, (3) a \emph{small theory}, and
(4) a \emph{simple implementation framework}.

In Chapter \ref{ch:poly}, we reviewed the two well-known polymorphic calculi,
System \F\ and System \Fw, to prepare the reader for
our term-indexed calculi, System \Fi\ and \Fixi, in later chapters.
We formalized these polymorphic calculi with Curry-style terms and
typing contexts divided into two parts in order to clearly show that
our term-indexed calculi are extensions of System \Fw.
We focused on the strong normalization proofs of these systems
because the strong normalization proof of System \Fi\ in Chapter \ref{ch:fi}
relies on the strong normalization of System \Fw.
In addition, we reviewed the Hindley-Milner type system to prepare
the reader for our discussion of type inference in Nax (Chapter \ref{ch:naxTyInfer}).

\paragraph{}
Chapter \ref{ch:mendler} explores Mendler-style recursion schemes,
their hierarchical organization, and their termination behaviors.
We use Haskell to model the behavior of the recursion schemes, to write
examples that illustrate characteristics of each of the recursion schemes,
and to provide a semi-formal termination proof for some of them.
We use Haskell for two purposes.

The first is a type correct syntax and an executable platform for
fast prototyping of examples and experimenting with new ideas. We use a certain
subset of Haskell that conforms to the Mendler-style conventions.
The discovery of our new Mendler-style recursion combinator (\MsfIt)
was suggested by this method of experimentation.

The second purpose is the use of a subset of Haskell as
an implementation of System \Fw. We illustrated a semi-formal termination proof of
$\MIt_{*}$ and $\MsfIt_{*}$ by embedding them into this subset.

We organize the hierarchy of Mendler-style recursion schemes
by two aspects: (1) the abstract operations they support and
(2) the kinds of the datatypes they operate on.

The first aspect, the abstract operations, categorizes the family
of Mendler-style recursion schemes. All Mendler-style recursion schemes
support the abstract recursive call, which enables recursive
calls over direct subcomponents of the argument value.
Mendler-style iteration (\MIt) is the most basic family,
supporting only this one abstract operation. Other
families of Mendler-style recursions schemes additionally support
their own characteristic operations. Mendler-style primitive recursion (\MPr)
additionally supports an abstract cast operation, which enables the programmer
to access direct sub-components by casting from abstract recursive values to
concrete recursive values. Mendler style course-of-values iteration and
recursion (\McvIt and \McvPr) additionally support the abstract out
operation, which enables access to deeper subcomponents. 

We also discovered
a new Mendler-style recursion scheme, \MsfIt, iteration with syntactic inverses,
which additionally supports abstract inverse operation. To support
this abstract inverse operation, we needed to augment the fixpoint type operator
with a syntactic inverse. We denote this abstract inverse as $\breve{\mu}$,
to distinguish with the standard fixpoint type operator $\mu$. We discuss
the ramifications of having two differrent fixpoint types, later in
Chapter \ref{ch:futwork}.

The second aspect, the kinds of datatypes operated on, categorizes
the indexing structure
of the recursive datatype within each family. Each family of
Mendler-style recursion scheme is a collection of many recursion combinators,
one at each kind. For instance, $\MIt_{*}$ iterates over regular datatypes
with no type index (\ie, $\mu_{*}F$ where $F : * -> *$), $\MIt_{* -> *}$
iterates over datatypes with one type index (\ie, $\mu_{* -> *} F$ where
$F : (* -> *) -> (* -> *)$), and, more generally, $\MIt_{\kappa}$ iterates
over recursive datatypes of the form $\mu_{\kappa}F$ where $F : \kappa -> \kappa$.
Mendler-style recursion schemes are uniformly defined regardless of the kinds
of datatypes they operate on. That is, the definition of $\MIt_{\kappa}$ is
identical regardless of $\kappa$, only its type signatures depends on $\kappa$.
Uniform definitions, regardless of indexing structure,
is one of the advanages of Mendler style over conventional (or, Squiggol) style.
This advangage, allowed us to discover that simply-typed Higher-Order
Abstract Syntax (HOAS) evaluation can be expressed within System \Fw.
We were able to write a simply-typed HOAS evaluator using $\MsfIt_{* -> *}$.

The indexing structure discussed in Chapter \ref{ch:mendler} is restricted
to type indices (as opposed to term indicies). To formulate Mendler-style recursion
schemes over term-indexed datatypes, we need to extend kinds.
For instance, $\MIt_{A -> *}$ where $A$ is a type, which cannot
be expressed in System \Fw\ because $A -> *$ is not a valid \Fw-kind.
In later chapters, we extend Mendler-style recursion schemes over
term-indexed datatypes by formalizing two term-indexed calculi, which extends
System \Fw\ with term indices.

The termination behaviors of Mendler-style recursion schemes can depend
on the particular recursion scheme. Some recursion schemes (\MIt, \MPr, \MsfIt) terminate
for arbitrary datatypes, while others (\McvPr, \McvIt) only terminate for
positive (or, monotone) datatypes. One of our contributions to
the study of the Mendler style is finding a counterexample for
the termination of course-of-values iteration (and also recursion) over 
negative datatypes. In Chapter \ref{ch:fixi}, we discuss how to embed
\McvPr\ into a strongly normalizing calculi, which is another original
contribution to the study of the Mendler style.

\paragraph{}
Chapters \ref{ch:fi} and \ref{ch:fixi} present two term-indexed calculi,
System \Fi\ and System \Fixi. Our term-indexed calculi serve as the
theoretical basis for the understanding of Mendler-style recursion schemes
over recursive types with term indices.
By embedding Mendler-style recursion schemes in our term-indexed calculi,
we know that those recursion schemes always terminate, because our term
indexed calculi are strongly normalizing.

System \Fi\ (Chapter \ref{ch:fi}) extends System \Fw\ (which supports
type indices) with term indices.  Term indices in System \Fi\ are 
erasable\footnote{Well-typed terms in (Curry style) \Fi\ are well-typed in \Fw} unlike
term indices in the dependently-typed calculi. We establish
strong normalization and logical consistency of System \Fi\ by
term-index erasure, which projects a typing judgement in System \Fi\ into
a typing judgement in System \Fw. We have extended the understanding of
Mendler-style recursion schemes over term-indexed datatypes. All
Mendler-style recursion schemes which are embeddable in System \Fw,
(\eg, \MIt, \MsfIt), can also be embedded into System \Fi.

Similarly, System~\Fixi\ extends System~\Fixw\ with erasable term indices.
System~\Fixw\ is an extension of System~\Fw\ with polarized kinds and
equi-recursive fixpoint types. By term-index erasure, well-typed terms
in System \Fixi\ are well-typed in System~\Fixw. Since \Fixw\ is known
to be strongly normalizing and logically consistent, we know that \Fixi\ is
also strongly normalizing and logically consistent.
There exists a reduction preserving embedding of the Mendler-style
primitive recursion (\MPr) in System \Fixi. This follows
from the embedding of \MPr\ in System \Fixw. 
In addition, we discovered an embedding of \McvPr\ 
(although not a reduction preserving embedding) in System \Fixi\ for monotone
(or positive)
datatypes. Our embedding of \McvPr\ motivates more research into
the open question of
whether we can derive monotonicity witness from the polarized kinds of
type constructors.

\paragraph{}
In Chapters \ref{ch:naxFeatures}, \ref{ch:nax}, and \ref{ch:naxTyInfer},
We introduce the Nax programming language, which is based on
our term-indexed calculi, System \Fi\ and \Fixi.

Chapter \ref{ch:naxFeatures} provides a tutorial of Nax.
We introduce the syntax and features of the language
using small example Nax programs.
Nax supports language constructs,
which are not directly part of the term-indexed calculi.
For example, Nax supports non-recursive datatype declarations and
pattern matching over those non-recursive datatypes,
a fixpoint type operator ($\mu_{[\kappa]}$) and
its constructor ($\In_{[\kappa]}$), and
several Mendler-style recursion schemes (\MIt, \MPr, \McvPr, \MsfIt)
as primitive constructs. 
Adding these constructs does not invalidate
strong normalization or logical consistency, because they are known to
be embeddable into term-indexed calculi.



Chapter \ref{ch:nax} highlights the design principles of the type system of Nax.
We discussed that adding the type indexed arrow kinds ($\{A\} -> \kappa$) is
the key design element in Nax to support term indices.
We compared our approach (Nax, System \Fi) of adding term indices with
an alternative approach (GHC's datatype promotion) of adding
term indices to a polymorphic language. In the alternative approach,
types are promoted to kinds (\ie, $\{A\}$ is itself a kind) and
terms are promoted to types. Our approach has the advantage of
allowing nested term indices (\ie, term indices can have term indexed type).
The alternative approach has the advantage of allowing data structures that
contain types as elements.

We also compared these two approaches with the approach taken in Agda, which
is a dependently typed language. Our approach is closely related to
Agda's universe subtyping and the alternative approach
(GHC's datatype promotion) is closely related to
Agda's universe polymorphism. We made these comparisons by programming extended
examples of a type-preserving evaluator and a stack-safe compiler
in three different languages: Nax, Haskell (with datatype promotion), and Agda.
These examples also show that the Nax syntax does support certain levels of
programming convenience. Each of the programs written in each of the three different
languages are about the same size, despite the fact that Nax must define
recursive types in two levels, by taking a fixpoint of a non-recursive datatype.

Chapter \ref{ch:naxTyInfer} we describes the type inference in Nax.
To support Hindley--Milner-style type inference, Nax only
allow rank-1 type polymorphism. One cannot generally infer types
in System \Fi\ or \Fixi\ since they allow higher-rank polymorphism.
For programs involving only regular (\ie, non-indexed) datatypes,
type inference is exactly the same as the Hindley--Milner type inference,
requiring no type annotation. For programs involving indexed datatypes,
we require type annotations on datatype declarations, case expressions, and
Mendler-style recursion combinators, but nowhere else.
Our current implementation requires kind annotations on
the fixpoint type operator ($\mu_{[\kappa]}$) and its constructor
($\In_{[\kappa]}$), but we believe these kind annotations can be inferred.

\paragraph{}
Chapter \ref{ch:relwork} discusses five categories of related work:
Mendler-style co-recursion schemes for possibly infinite structures,
Mendler-style recursion schemes over multiple recursive values,
dependently-typed Mendler-style induction, sized-types approach,
and comparison of our approach to logical frameworks.

Chapter \ref{ch:futwork} summarizes some ongoing and future work.
We are designing a new Mendler-style recursion scheme useful
for negative datatypes, studying the relation between two different
fixpoint types ($\mu$ and $\breve\mu$). We wonder how we can derive
monotonicity from polarized kinds. We want to confirm more rigorously
that rank-1 kind polymorphism does not break logical consistency.
We plan to implement kind inference in Nax.

\section{Significance}\label{sec:concl:sig}
Our main contribution is a logically consistent language design that supports
all recursive datatypes available in factional programming languages such as
Haskell and, in addition, term-indexed types. Our design compromises between
convenient programming and strong guarantee of program invariants, taking
advantages of both. Our language, Nax, is based on a small theory and
admits a small implementation framework.

Our investigations on Mendler style uncovered two new aspects.
First, we discovered a useful recursion scheme (\MsfIt) for negative datatypes.
The discovery of \MsfIt\ lead to the novel discovery that simply-typed HOAS
evaluation is expressible within System \Fw. Second, we generalized
Mendler-style recursion schemes over term-indexed datatypes.
Generalization over term-indexed datatypes are established by
the formalization of our term-indexed calculi (System \Fi\ and \Fixi),
which extends the polymorphic calculi (System \Fw\ and \Fixw).

Our term-indexed calculi is a small theory that can embed indexed datatypes
and their (Mendler-style) recursion schemes. That is, we do not need to extend
the calculi with primitive datatypes in order to model a practical language.
Datatypes and Mendler-style recursion schemes in Nax can be embedded into
our term-indexed calculi.

The Nax language implementation does not need extra termination checker
because termination is type-based. Once the program type checks, we know
that it terminates because Nax programs can be embedded into
the term-indexed calculi, which is strongly normalizing.

%% This design identifies 
%% a new language design space between polymorphically-typed functional
%% programming languages (\eg, Haskell, ML) and dependently-typed logical
%% reasoning systems based on the Curry--Howard correspondence (\eg, Coq, Agda).
%% From the perspective of the logical reasoning systems, our design increases
%% programming convenience since one can program with natively supported
%% negative datatypes such as HOAS. From the perspective of the functional
%% programming languages, our design increases the expressiveness of propositions
%% (or, program invariants) since one can express value-based invariants
%% using term indices.
%% 
%% negative datatypes such as HOAS
%% datatypes
%% 
%% extending Mendler-style over term indexed datatypes.
%% term indexing
%% 
%% TODO
%% We have the issue of converting between two different fixpoint types,
%% $\mu$ and $\breve{\mu}$, which is analogous to the adequacy issue
%% in logical frameworks. Logical frameworks resolve the adequacy issue
%% by the two-layered approach, where the objects (or, terms) belong to
%% either the representation layer or to the logic (or, computation) layer,
%% as discussed in Chapter \ref{ch:relwork}. However, unlike logical frameworks
%% that must always consider the adequacy issue, Nax need not consider
%% the issue of two different fixpoints for programs that only involve
%% positive datatypes and do not use \MsfIt.
%% 
%% but we only need to consider this issue
%% when we use \MsfIt\ over negative datatypes.
%% 
%% aaaa

\section{Limitations and future work}\label{sec:concl:fw}
We summarise several limitations of our term-indexed calculi and
the Nax language design.

kind polymorphism

datatypes containing types
