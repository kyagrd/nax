\section{Metatheory} \label{sec:fixi:theory}

\subsection{TODO Strong normalization} \label{ssec:fixi:theory:sn}
We can prove strong normalization of \Fixi\ by erasing term-indices in \Fixi\ 
types into \Fixw\ types. Since \Fixw\ is strongly normalizing \cite{AbeMat04},
the existence of a index erasure that maps a valid typing judgment on a term
in \Fixi\ to a valid typing judgment on the same term in \Fixw\ implies
strong normalization of \Fixi.

The definition of the index erasure operation and the proofs for
the related theorems are almost exactly the same as their counterparts
in System \Fi\ (see \S\ref{sec:fi:theory}). So, we simply illustrate
the definition and just give a very brief sketch of the proofs for the
theorems.

We define a meta-operation of index erasure that projects $\Fixi$ types
to $\Fixw$ types.
\begin{definition}[index erasure]\label{def:Fixierase}
\[ \fbox{$\kappa^\circ$}
 ~~~~ ~~
 *^\circ =
 *
 ~~~~ ~~
 (p\kappa_1 -> \kappa_2)^\circ =
 p{\kappa_1}^\circ -> {\kappa_2}^\circ
 ~~~~ ~~
 (A -> \kappa)^\circ =
 \kappa^\circ
\]
\[ \fbox{$F^\circ$}
 ~~~~
 X^\circ =
 X
 ~~~~ ~~~~
 (A -> B)^\circ =
 A^\circ -> B^\circ
 ~~~~ ~~~~
 (\mu F)^\circ =
 \mu F^\circ
\]
\[ \qquad
 (\lambda X^{p\kappa}.F)^\circ =
 \lambda X^{p\kappa^\circ}.F^\circ
 ~~~~ ~~~~
 (\lambda i^A.F)^\circ =
 F^\circ
\]
\[ \qquad
 (F\;G)^\circ =
 F^\circ\;G^\circ
 ~~~~ ~~~~ ~~~~ ~~~~ ~~
 (F\,\{s\})^\circ =
 F^\circ
\]
\[ \qquad
 (\forall X^\kappa . B)^\circ =
 \forall X^{\kappa^\circ} . B^\circ
 ~~~~ ~~~~
 (\forall i^A . B)^\circ =
 B^\circ
\]
\[ \fbox{$\Delta^\circ$}
 ~~~~
 \cdot^\circ = \cdot
 ~~~~ ~~
 (\Delta,X^{p\kappa})^\circ = \Delta^\circ,X^{p\kappa^\circ}
 ~~~~ ~~
 (\Delta,i^A)^\circ = \Delta^\circ
\]
\[ \fbox{$\Gamma^\circ$}
 ~~~~
 \cdot^\circ = \cdot
 ~~~~ ~~~~
 (\Gamma,x:A)^\circ = \Gamma^\circ,x:A^\circ
\]
\end{definition}

\begin{theorem}[index erasure on well-sorted kinds]
\label{thm:Fixierasesorting}
	$\inference{|- \kappa : \square}{|- \kappa^\circ : \square}$
\end{theorem}

\begin{theorem}[index erasure on well-formed type level contexts]
\label{thm:Fixierasetyctx}
\[ \inference{|- \Delta}{|- \Delta^\circ} \]
\end{theorem}

\begin{theorem}[index erasure on kind equality]\label{thm:Fixierasekindeq}
$ \inference{|- \kappa=\kappa':\square}
	{|- \kappa^\circ=\kappa'^\circ:\square}
$
\end{theorem}

\begin{theorem}[index erasure on well-kinded type constructors]
\label{thm:Fixierasekinding}
\[ \inference{|- \Delta & \Delta |- F : \kappa}
		{\Delta^\circ |- F^\circ : \kappa^\circ}
\]
\end{theorem}
\begin{theorem}[index erasure on type constructor equality]
\[ \inference{\Delta |- F=F':\kappa}
		{\Delta^\circ |- F^\circ=F'^\circ:\kappa^\circ}
\]
\label{thm:Fixierasetyconeq}
\end{theorem}

\begin{theorem}[index erasure on well-formed term level contexts]
\label{thm:Fixierasetmctx}
\[ \inference{\Delta |- \Gamma}{\Delta^\circ |- \Gamma^\circ} \]
\end{theorem}

\begin{theorem}[index erasure on index-free well-typed terms]
\label{thm:Fixierasetypingifree}
\[ \inference{ \Delta |- \Gamma & \Delta;\Gamma |- t : A}
		{\Delta^\circ;\Gamma^\circ |- t : A^\circ}
		{\enspace(\dom(\Delta)\cap\FV(t) = \emptyset)}
\]
\end{theorem}


We introduce an index variable selection meta-operation that selects all
the index variable bindings from the type level context.
\begin{definition}[index variable selection]
\[ \cdot^\bullet = \cdot \qquad
	(\Delta,X^{p\kappa})^\bullet = \Delta^\bullet \qquad
	(\Delta,i^A)^\bullet = \Delta^\bullet,i:A
\]
\end{definition}

\begin{theorem}[index erasure on well-formed term level contexts
		prepended by index variable selection]
\label{thm:Fixierasetmctxivs}
\[ \inference{\Delta |- \Gamma}{\Delta^\circ |- (\Delta^\bullet,\Gamma)^\circ}
\]
\end{theorem}

\begin{theorem}[index erasure on well-typed terms]
\label{thm:Fixierasetypingall}
\[ \inference{\Delta |- \Gamma & \Delta;\Gamma |- t : A}
		{\Delta^\circ;(\Delta^\bullet,\Gamma)^\circ |- t : A^\circ}
\]
\end{theorem}


\KYA{TODO has there been any studies on the logical consistencies of
	implicit calculus + equi-recursive type?}



\subsection{Conditions for well-behaved course-of-values recursion}
\label{ssec:fixi:theory:cv}
\begin{proposition}\label{prop:fixi:fmap}
For any $F : +* -> *$, assuming that $F$ is in in normal form and that
all free variables of $F$ are introduced by universal quantification,
there exists \quad
$\textit{fmap}_F : \forall X^{*}.\forall Y^{*}.(X -> Y) -> F\;X -> F\;Y$
\end{proposition}
\begin{proof}
	We can derive $\textit{fmap}_F$ from the structure of $F$.
\begin{itemize}
\item[case]($F \triangleq \l Z^{+*}. Z$)
	Since $F\;X = X$ and $F\;X = Y$,
	we can return the function $z:X -> Y$ itself.
	That is, $ \textit{fmap}_{(\l Z^{+*}. Z)} = \l z . z $.

\item[case]($F \triangleq \l Z^{+*}. X_1$)
	We assume that $X_1$ is different from $Z$. Since $F\;X = F\;Y = X_1$,
	we can just return the identity function on $X_1$,
	ignoring the function passed to $z$.
	That is, $ \textit{fmap}_{(\l Z^{+*}. X_1)} = \l z . \l x. x $.

\item[case]($F \triangleq \l Z^{+*}.X_1\,G$).
	Same as the case ($F \triangleq \l Z^{+*}. X_1$),
	considering $X_1\,G$ as yet another fresh free variable $X_1'$.
	That is,
	$\textit{fmap}_{(\l Z^{+*}.X_1\;G)}=\textit{fmap}_{(\l Z^{+*}.X_1')}$.

\item[case]($F \triangleq \l Z^{+*}.X_1\{s\}$).
	Same as the case ($F \triangleq \l Z^{+*}. X_1$),
	considering $X_1\{s\}$ as yet another fresh free variable $X_1'$.
	That is,
	$\textit{fmap}_{(\l Z^{+*}.X_1\{s\})}=\textit{fmap}_{(\l Z^{+*}.X_1')}$.

\item[case]($F \triangleq \l Z^{+*}. A -> B$)
	TODO $\textit{fmap}_{(\l Z^{+*}.B)}$

	TODO three subcases on A: variable like (easy), forall (fresh), arrow (inductive)

	We have a problem here with the forall. When $A$ is forall, then it is
	a universal quantification at negative position, which is existential.
	I don't know what to do about this.
	Maybe this is why there isn't such a system yet.
	As long as there arn't universal quantification at negative positions
	there is a good way to derive fmap. So, in Haskell without
	RankNTypes, deriving Fucntor should work, but what if there are
	RankNTypes?
	Wondering whether people have aready studied about this.

\item[case]($F \triangleq \l Z^{+*}. \forall X_2^\kappa .B_1$)
	Same as the case ($F \triangleq \l Z^{+*}. B$),
	considering $X_2$ as a fresh free variable.
\end{itemize}
\end{proof}

\begin{proposition}\label{prop:fixi:fmapFree}
If $\textit{fmap}_F:\forall X^{*}.\forall Y^{*}.(X -> Y) -> F\;X -> F\;Y$
exists, then
\begin{align*}
\textit{fmap}_F~\textit{id} &~=~ \textit{id} \\
\textit{fmap}_F~\textit{f} \;\circ\; \textit{fmap}_F~\textit{g}
&~=~ \textit{fmap}_F~(f\circ g)
\end{align*}
\end{proposition}\noindent
This is a well-known parametricity theorem on maps any instance of the type
$\forall X^{*}.\forall Y^{*}.(X -> Y) -> F\;X -> F\;Y$ satisfies
the two equations above. However, for the purpose of defining $\McvPr_{*}$,
we only need to know that there exists one such $\textit{fmap}_F$. That is,
\begin{proposition}\label{prop:fixi:fmapHom}
For any $F : +* -> *$, there exists

$\textit{fmap}_F:\forall X^{*}.\forall Y^{*}.(X -> Y) -> F\;X -> F\;Y$
such that
\begin{align*}
\textit{fmap}_F~\textit{id} &~=~ \textit{id} \\
\textit{fmap}_F~\textit{f} \;\circ\; \textit{fmap}_F~\textit{g}
&~=~ \textit{fmap}_F~(f\circ g)
\end{align*}
\end{proposition}
\begin{proof}
	You can check that each case
	in the proof of Proposition \ref{prop:fixi:fmap}
	satisfies the two equations above.
\end{proof}

\begin{proposition} For any $F : +* -> *$, there exists
$\unIn_F : \mu^{+}{*} F -> F(\mu^{+}{*} F)$ such that
$\unIn_F (\In_F\;t) -->+ t$.
\end{proposition}
\begin{proof}
Since we know that $\textit{fmap}_F$ exists by Proposition~\ref{prop:fixi:fmap},
we can define
\[ \unIn_F = \McvPr_{*}\;
            (\l\_.\l\textit{cast}.\l\_.\l x.\textit{fmap}_F\;\textit{cast}\;x)
\]

From Proposition~\ref{prop:fixi:fmapFree}, we know that
$\textit{fmap}_F\;\textit{id}\;x -->+ x$.
Thus,
\[ \unIn_F (\In_F\;t) -->+ \textit{fmap}_F\;\textit{id}\;t -->+ t \]
\end{proof}

\begin{align*}
A \rrarrow_{*} B &~\triangleq~ A -> B \\
F \rrarrow^{p\kappa -> \kappa'} G &~\triangleq~
	\forall X^\kappa.\forall Y^\kappa.
		(X \rrarrow_\kappa Y) -> F X \rrarrow_\kappa F Y \\
F \rrarrow^{A -> \kappa} G &~\triangleq~
	\forall i^A.\forall f^{A->A}. F\{i\} \rrarrow_\kappa F\{f\;i\}
\end{align*}

\[
\textsf{mon}_\kappa
  = \l X^{0\kappa}.X \rrarrow^\kappa X
\]

$\textsf{mon}_{+* -> *} F$ is the type of $\textit{fmap}_F$
where $F : +* -> *$.

$\textsf{mon}_{+(p* -> *)->(p* -> *)} F$ is the type of $\textit{fmap1}_F$
where $F : +(p* -> *)->(p* -> *)$.

if $\textsf{mon}_{+(p* -> *)->(p* -> *)}$ is inhabited
then $\unIn_F$ for any $F : +(p* -> *)->(p* -> *)$?

what about general case? if $\textsf{mon}_\kappa$ is inhabited
then $\unIn_F$ for any $F : \kappa$?

