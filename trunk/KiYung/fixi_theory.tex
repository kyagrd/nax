\section{Metatheory} \label{sec:fixi:theory}

\subsection{TODO Strong normalization} \label{ssec:fixi:theory:sn}
We can prove strong normalization of \Fixi\ by erasing term-indices in \Fixi\ 
types into \Fixw\ types. Since \Fixw\ is strongly normalizing \cite{AbeMat04},
the existence of a index erasure that maps a valid typing judgment on a term
in \Fixi\ to a valid typing judgment on the same term in \Fixw\ implies
strong normalization of \Fixi.

The definition of the index erasure operation and the proofs for
the related theorems are almost exactly the same as their counterparts
in System \Fi\ (see \S\ref{sec:fi:theory}). So, we simply illustrate
the definition and just give a very brief sketch of the proofs for the
theorems.

We define a meta-operation of index erasure that projects $\Fixi$ types
to $\Fixw$ types.
\begin{definition}[index erasure]\label{def:Fixierase}
\[ \fbox{$\kappa^\circ$}
 ~~~~ ~~
 *^\circ =
 *
 ~~~~ ~~
 (p\kappa_1 -> \kappa_2)^\circ =
 p{\kappa_1}^\circ -> {\kappa_2}^\circ
 ~~~~ ~~
 (A -> \kappa)^\circ =
 \kappa^\circ
\]
\[ \fbox{$F^\circ$}
 ~~~~
 X^\circ =
 X
 ~~~~ ~~~~
 (A -> B)^\circ =
 A^\circ -> B^\circ
 ~~~~ ~~~~
 (\mu F)^\circ =
 \mu F^\circ
\]
\[ \qquad
 (\lambda X^{p\kappa}.F)^\circ =
 \lambda X^{p\kappa^\circ}.F^\circ
 ~~~~ ~~~~
 (\lambda i^A.F)^\circ =
 F^\circ
\]
\[ \qquad
 (F\;G)^\circ =
 F^\circ\;G^\circ
 ~~~~ ~~~~ ~~~~ ~~~~ ~~
 (F\,\{s\})^\circ =
 F^\circ
\]
\[ \qquad
 (\forall X^\kappa . B)^\circ =
 \forall X^{\kappa^\circ} . B^\circ
 ~~~~ ~~~~
 (\forall i^A . B)^\circ =
 B^\circ
\]
\[ \fbox{$\Delta^\circ$}
 ~~~~
 \cdot^\circ = \cdot
 ~~~~ ~~
 (\Delta,X^{p\kappa})^\circ = \Delta^\circ,X^{p\kappa^\circ}
 ~~~~ ~~
 (\Delta,i^A)^\circ = \Delta^\circ
\]
\[ \fbox{$\Gamma^\circ$}
 ~~~~
 \cdot^\circ = \cdot
 ~~~~ ~~~~
 (\Gamma,x:A)^\circ = \Gamma^\circ,x:A^\circ
\]
\end{definition}

\begin{theorem}[index erasure on well-sorted kinds]
\label{thm:Fixierasesorting}
	$\inference{|- \kappa : \square}{|- \kappa^\circ : \square}$
\end{theorem}

\begin{theorem}[index erasure on well-formed type level contexts]
\label{thm:Fixierasetyctx}
\[ \inference{|- \Delta}{|- \Delta^\circ} \]
\end{theorem}

\begin{theorem}[index erasure on kind equality]\label{thm:Fixierasekindeq}
$ \inference{|- \kappa=\kappa':\square}
	{|- \kappa^\circ=\kappa'^\circ:\square}
$
\end{theorem}

\begin{theorem}[index erasure on well-kinded type constructors]
\label{thm:Fixierasekinding}
\[ \inference{|- \Delta & \Delta |- F : \kappa}
		{\Delta^\circ |- F^\circ : \kappa^\circ}
\]
\end{theorem}
\begin{theorem}[index erasure on type constructor equality]
\[ \inference{\Delta |- F=F':\kappa}
		{\Delta^\circ |- F^\circ=F'^\circ:\kappa^\circ}
\]
\label{thm:Fixierasetyconeq}
\end{theorem}

\begin{theorem}[index erasure on well-formed term level contexts]
\label{thm:Fixierasetmctx}
\[ \inference{\Delta |- \Gamma}{\Delta^\circ |- \Gamma^\circ} \]
\end{theorem}

\begin{theorem}[index erasure on index-free well-typed terms]
\label{thm:Fixierasetypingifree}
\[ \inference{ \Delta |- \Gamma & \Delta;\Gamma |- t : A}
		{\Delta^\circ;\Gamma^\circ |- t : A^\circ}
		{\enspace(\dom(\Delta)\cap\FV(t) = \emptyset)}
\]
\end{theorem}


We introduce an index variable selection meta-operation that selects all
the index variable bindings from the type level context.
\begin{definition}[index variable selection]
\[ \cdot^\bullet = \cdot \qquad
	(\Delta,X^{p\kappa})^\bullet = \Delta^\bullet \qquad
	(\Delta,i^A)^\bullet = \Delta^\bullet,i:A
\]
\end{definition}

\begin{theorem}[index erasure on well-formed term level contexts
		prepended by index variable selection]
\label{thm:Fixierasetmctxivs}
\[ \inference{\Delta |- \Gamma}{\Delta^\circ |- (\Delta^\bullet,\Gamma)^\circ}
\]
\end{theorem}

\begin{theorem}[index erasure on well-typed terms]
\label{thm:Fixierasetypingall}
\[ \inference{\Delta |- \Gamma & \Delta;\Gamma |- t : A}
		{\Delta^\circ;(\Delta^\bullet,\Gamma)^\circ |- t : A^\circ}
\]
\end{theorem}


\KYA{TODO has there been any studies on the logical consistencies of
	implicit calculus + equi-recursive type?}



\subsection{Conditions for well-behaved course-of-values recursion}
\label{ssec:fixi:theory:cv}

\begin{theorem}\label{prop:fixi:fmap}
For any $F : +* -> *$, there exists
\[ \textit{fmap}_F : \forall X^{*}.\forall Y^{*}.(X -> Y) -> F\;X -> F\;Y \]
\end{theorem}

start with a more easy one
\begin{proposition}\label{prop:fixi:fmapBaseCase}
There exists
$\textit{fmap}_F : \forall X^{*}.\forall Y^{*}.(X -> Y) -> F\;X -> F\;Y$
for any $F : +* -> *$ such that
\begin{itemize}
	\item $F$ is a value, that is, $F$ is
		in normal form (\ie, has no redex) and
		closed (\ie, $F$ has no free variables),
	\item all the bound variabels within $F$ are
		introduced by universal quantification
		and those variables are of kind $*$.
\end{itemize}
\end{proposition}
\begin{proof}
	We can derive $\textit{fmap}_F$ from the structure of $F$.
	Since $F$ is a value, it must be in the form of $\l Z^{+*}.B$.
	Since $F$ is in normal form, $F$ can neither be
	an application ($F'\,G$) nor an index application ($F'\{s\}$),
	unless $F'$ is a variable. However, $F$ cannot have a free varaible
	since $F$ is a value.
\begin{itemize}
\item[case]($Z\notin \FV(B)$)
	$ \textit{fmap}_{(\l Z^{+*}. B)} = \l \_ . \l x. x $

	Since $F\;X = F\;Y = B$, we just return the identity function on $B$.

\item[case]($F \triangleq \l Z^{+*}. Z$)
	$ \textit{fmap}_{(\l Z^{+*}. Z)} = \l z . z $

	Since $F\;X = X$ and $F\;X = Y$,
	we return the function $z:X -> Y$ itself.

\item[case]($F \triangleq \l Z^{+*}. \forall X_1^{*} .B_1$)
	$\textit{fmap}_{(\l Z^{+*}. \forall X_1^{*} .B_1)}
	= \textit{fmap}_{(\l Z^{+*}.B_1)}$

	Here, what we are really doing is finding an \textit{fmap}
	that works for for arbitrary valuation of $X_1$.
	That is, an \textit{fmap} that works for $\l Z^{+*}. B_1[v/X]$
	for arbitrary selection of value $v$. Since values are closed
	it cannot contain any free variable including $Z$. Since $v$
	is completely independent of $Z$, selection of value $v$ makes
	no difference deriving the \textit{fmap}.

\item[case]($F \triangleq \l Z^{+*}. A -> B_1$)

	When $Z\notin\FV(A)$,
	$\textit{fmap}_{(\l Z^{+*}.A -> B_1)}
	= \l z.\l y. \l x. \textit{fmap}_{(\l Z^{+*}.B_1)} \; z \; (y \; x)$

	When $A \triangleq \forall X_1^{*}.A_1$,
	$\textit{fmap}_{(\l Z^{+*}.(\forall X_1^{*}.A_1) -> B_1)}
	= \textit{fmap}_{(\l Z^{+*}.A_1 -> B_1)}$

	\begin{singlespace}
	When $A \triangleq A_1 -> \cdots -> A_n -> \forall X_2^{*}.B_2'$,
	\vspace{-1.5ex}
	\[\textit{fmap}_{(\l Z^{+*}.(A_1 -> \cdots -> A_n -> \forall X_2^{*}.B_2') -> B_1)}
	= \textit{fmap}_{(\l Z^{+*}.(A_1 -> \cdots -> A_n -> B_2') -> B_1)} \]

	When $A \triangleq A_1 -> \cdots -> A_n -> B_2$,
	where $B_2$ is not an arrow type
	\vspace{-1.5ex}
	\begin{align*}
	  & \textit{fmap}_{(\l Z^{+*}.(A_1 -> \cdots -> A_n -> B_2) -> B_1)} \\
	=~& \l z.\l y. \l x.\;
	\textit{fmap}_{(\l Z^{+*}.B_1)} \; z \;
		(y \; (\l x_1.\ldots\l x_n. ~
		   x  &\!\!\!\!(\textit{fmap}_{(\l Z^{+*}.A_1)} ~ z ~ x_1)& \\
		     &&\!\!\!\!\vdots \qquad\qquad& \\
		     &&\!\!\!\!(\textit{fmap}_{(\l Z^{+*}.A_n)} ~ z ~ x_n)&
		\,) \,)
	\end{align*}
	\end{singlespace}

\end{itemize}
\end{proof}

To illustrate that the \textit{fmap}s derived in the proof above are indeed
type correct, we provide some examples in Haskell accepted by GHC in
Figure~\ref{fig:deriveFunctor}.
\begin{figure}
\begin{singlespace}
\begin{lstlisting}[basicstyle={\ttfamily\small},language=Haskell,mathescape]
{-# LANGUAGE RankNTypes #-}

data F1 x = C1 (Int -> Bool)

instance Functor F1 where
  fmap f (C1 z) = C1 z

data F2 x = C2 x

instance Functor F2 where
  fmap f (C2 z) = C2 (f z)

data F3 x = C3 (([x] -> Bool) -> Maybe x)

instance Functor F3 where
  fmap z (C3 y) = C3 (\x -> fmap z (y (\x1-> x (fmap z x1))))

data F4 x = C4 ((forall y . [x] -> y) -> Maybe x)

instance Functor F4 where
  fmap z (C4 y) = C4 (\x -> fmap z (y (\x1-> x (fmap z x1))))

data F5 x = C5 (forall y . ([x] -> y) -> Maybe x)

instance Functor F5 where
  fmap z (C5 y) = C5 (\x -> fmap z (y (\x1-> x (fmap z x1))))

data F6 x = C6 (([x] -> ([x] -> Bool)) -> Maybe x)

instance Functor F6 where
  fmap z (C6 y) =
    C6 (\x -> fmap z (y (\x1 x2 -> x (fmap z x1) (fmap z x2))))
\end{lstlisting}
\end{singlespace}
\caption{Haskell code example to illustrate well-typedness of \textit{fmap}s
	derived in the proof of Proposition \ref{prop:fixi:fmapBaseCase}}
\label{fig:deriveFunctor}
\end{figure}

Let us extend the proof by allowing type constructor vaiables of
kind $p* -> *$ as well as type variables of kind $*$. There are three
possiblilities for $X:p* -> *$. Note that the variable
$X$ would be used as an application $X\,G$ within the type $B$.
\begin{itemize}
\item[case]($X : +* -> *$)
	By induciton\footnote{
		we need to make sure that this is a well-founded induction},
	there exist a map for any valuation of $X$.
	So, we denote that map as $\textit{fmap}_{X}$.
	Then the map for $\l Z^{+*}.X\,G$ is
	\[ \textit{fmap}_{(\l Z^{+*}.X\,G)} =
		\textit{fmap}_{X} \circ\, \textit{fmap}_{(\l Z^{+*}.G)} \]
	Note that $\textit{fmap}_{X}$ is not fixed untill it gets
	instantiated, but we know for sure that it exists for any
	valuation.

\item[case]($X : -* -> *$)
	According to the ($@$) rule, $G$ should be well-kinded under $-\Delta$.
	Note that $Z^{-*}\in\Delta$ since $Z^{+*}\in \Delta$.
	So, $Z$ cannot appear in positive positions in $G$ but only in
	negative positions (\eg, $G \triangleq Z -> G'$).
	Any valuation of $X$ will have the form of $\l X_1^{-*}.B_1$
	where $X_1$ appears in negative positions.
	Then, $(\l X_1^{-*}.B_1)G = B_1[G/X_1]$. Note that $B_1[G/X_1]$
	is in normal form since $G:*$ -- substition of $X_1$ with $G$
	does not introduce any new redex. Since $G$ is substituted into
	negative posistinos, $Z$ occuring in negative position in $G$
	becomes a positive position, since it is negative of negative
	position. Thus, $\l Z^{+*}.B_1[G/X_1] : +* ->*$.
	So, by induction\footnote{
		we need to make sure that this is a well-founded induction},
	there exists a map for any valuation of $X$,
	since we can derive $\textit{fmap}_{(\l Z^{+*}.B_1[G/X_1])}$.

\item[case]($X : 0* -> *$)
	Note that $G$ cannot have $Z$ in it because $Z$ has $+$ polarity
	in the context. Recall that, $0\Delta$ ignores the variables
	with ether $+$ or $-$ polarity. According to the ($@$) rule
	in Figure \ref{fig:Fixi2}, $G$ should be well-kinded under $0\Delta$.
	Since $Z\notin\FV(X\,G)$, we simply return the identity function
	as the map for $\l Z^{+*}.X\,G$.
\end{itemize}
In addition, having $X : A -> *$ won't make a difference since $X\{s\}$
cannot have $Z$ either. Once we know that we can derive maps in the presence
of type constructor variables with single argument, it is easy to generalize
this to arbitrary rank-1 kinded type constructor variables
(\eg, $+* -> A_1 -> -* -> A_2 -> 0* -> *$).



would generalzied to arbitrary rank-1 kinded tycon variables


What about even higher kinded tycon variables?


\begin{proposition}\label{prop:fixi:fmapFree}
If $\textit{fmap}_F:\forall X^{*}.\forall Y^{*}.(X -> Y) -> F\;X -> F\;Y$
exists, then
\begin{align*}
\textit{fmap}_F~\textit{id} &~=~ \textit{id} \\
\textit{fmap}_F~\textit{f} \;\circ\; \textit{fmap}_F~\textit{g}
&~=~ \textit{fmap}_F~(f\circ g)
\end{align*}
\end{proposition}\noindent
This is a well-known parametricity theorem on maps any instance of the type
$\forall X^{*}.\forall Y^{*}.(X -> Y) -> F\;X -> F\;Y$ satisfies
the two equations above. However, for the purpose of defining $\McvPr_{*}$,
we only need to know that there exists one such $\textit{fmap}_F$. That is,
\begin{proposition}\label{prop:fixi:fmapHom}
For any $F : +* -> *$, there exists

$\textit{fmap}_F:\forall X^{*}.\forall Y^{*}.(X -> Y) -> F\;X -> F\;Y$
such that
\begin{align*}
\textit{fmap}_F~\textit{id} &~=~ \textit{id} \\
\textit{fmap}_F~\textit{f} \;\circ\; \textit{fmap}_F~\textit{g}
&~=~ \textit{fmap}_F~(f\circ g)
\end{align*}
\end{proposition}
\begin{proof}
	You can check that each case
	in the proof of Theorem \ref{thm:fixi:fmap} (TODO maybe refer to lemmas)
	satisfies the two equations above.
\end{proof}

\begin{proposition} For any $F : +* -> *$, there exists
$\unIn_F : \mu^{+}{*} F -> F(\mu^{+}{*} F)$ such that
$\unIn_F (\In_F\;t) -->+ t$.
\end{proposition}
\begin{proof}
Since we know that $\textit{fmap}_F$ exists by Theorem~\ref{thm:fixi:fmap},
we can define
\[ \unIn_F = \McvPr_{*}\;
            (\l\_.\l\textit{cast}.\l\_.\l x.\textit{fmap}_F\;\textit{cast}\;x)
\]

From Proposition~\ref{prop:fixi:fmapFree}, we know that
$\textit{fmap}_F\;\textit{id}\;x -->+ x$.
Thus,
\[ \unIn_F (\In_F\;t) -->+ \textit{fmap}_F\;\textit{id}\;t -->+ t \]
\end{proof}

\begin{align*}
A \rrarrow_{*} B &~\triangleq~ A -> B \\
F \rrarrow^{p\kappa -> \kappa'} G &~\triangleq~
	\forall X^\kappa.\forall Y^\kappa.
		(X \rrarrow_\kappa Y) -> F X \rrarrow_\kappa F Y \\
F \rrarrow^{A -> \kappa} G &~\triangleq~
	\forall i^A.\forall f^{A->A}. F\{i\} \rrarrow_\kappa F\{f\;i\}
\end{align*}

\[
\textsf{mon}_\kappa
  = \l X^{0\kappa}.X \rrarrow^\kappa X
\]

$\textsf{mon}_{+* -> *} F$ is the type of $\textit{fmap}_F$
where $F : +* -> *$.

$\textsf{mon}_{+(p* -> *)->(p* -> *)} F$ is the type of $\textit{fmap1}_F$
where $F : +(p* -> *)->(p* -> *)$.

if $\textsf{mon}_{+(p* -> *)->(p* -> *)}$ is inhabited
then $\unIn_F$ for any $F : +(p* -> *)->(p* -> *)$?

what about general case? if $\textsf{mon}_\kappa$ is inhabited
then $\unIn_F$ for any $F : \kappa$?

