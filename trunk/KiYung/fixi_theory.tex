\section{Metatheory} \label{sec:fixi:theory}

\subsection{TODO Strong normalization} \label{ssec:fixi:theory:sn}
We can prove strong normalization of \Fixi\ by erasing term-indices in \Fixi\ 
types into \Fixw\ types. Since \Fixw\ is strongly normalizing \cite{AbeMat04},
the existence of a index erasure that maps a valid typing judgment on a term
in \Fixi\ to a valid typing judgment on the same term in \Fixw\ implies
strong normalization of \Fixi.

The definition of the index erasure operation and the proofs for
the related theorems are almost exactly the same as their counterparts
in System \Fi\ (see \S\ref{sec:fi:theory}). So, we simply illustrate
the definition and just give a very brief sketch of the proofs for the
theorems.

We define a meta-operation of index erasure that projects $\Fixi$ types
to $\Fixw$ types.
\begin{definition}[index erasure]\label{def:Fixierase}
\[ \fbox{$\kappa^\circ$}
 ~~~~ ~~
 *^\circ =
 *
 ~~~~ ~~
 (p\kappa_1 -> \kappa_2)^\circ =
 p{\kappa_1}^\circ -> {\kappa_2}^\circ
 ~~~~ ~~
 (A -> \kappa)^\circ =
 \kappa^\circ
\]
\[ \fbox{$F^\circ$}
 ~~~~
 X^\circ =
 X
 ~~~~ ~~~~
 (A -> B)^\circ =
 A^\circ -> B^\circ
 ~~~~ ~~~~
 (\mu F)^\circ =
 \mu F^\circ
\]
\[ \qquad
 (\lambda X^{p\kappa}.F)^\circ =
 \lambda X^{p\kappa^\circ}.F^\circ
 ~~~~ ~~~~
 (\lambda i^A.F)^\circ =
 F^\circ
\]
\[ \qquad
 (F\;G)^\circ =
 F^\circ\;G^\circ
 ~~~~ ~~~~ ~~~~ ~~~~ ~~
 (F\,\{s\})^\circ =
 F^\circ
\]
\[ \qquad
 (\forall X^\kappa . B)^\circ =
 \forall X^{\kappa^\circ} . B^\circ
 ~~~~ ~~~~
 (\forall i^A . B)^\circ =
 B^\circ
\]
\[ \fbox{$\Delta^\circ$}
 ~~~~
 \cdot^\circ = \cdot
 ~~~~ ~~
 (\Delta,X^{p\kappa})^\circ = \Delta^\circ,X^{p\kappa^\circ}
 ~~~~ ~~
 (\Delta,i^A)^\circ = \Delta^\circ
\]
\[ \fbox{$\Gamma^\circ$}
 ~~~~
 \cdot^\circ = \cdot
 ~~~~ ~~~~
 (\Gamma,x:A)^\circ = \Gamma^\circ,x:A^\circ
\]
\end{definition}

\begin{theorem}[index erasure on well-sorted kinds]
\label{thm:Fixierasesorting}
	$\inference{|- \kappa : \square}{|- \kappa^\circ : \square}$
\end{theorem}

\begin{theorem}[index erasure on well-formed type level contexts]
\label{thm:Fixierasetyctx}
\[ \inference{|- \Delta}{|- \Delta^\circ} \]
\end{theorem}

\begin{theorem}[index erasure on kind equality]\label{thm:Fixierasekindeq}
$ \inference{|- \kappa=\kappa':\square}
	{|- \kappa^\circ=\kappa'^\circ:\square}
$
\end{theorem}

\begin{theorem}[index erasure on well-kinded type constructors]
\label{thm:Fixierasekinding}
\[ \inference{|- \Delta & \Delta |- F : \kappa}
		{\Delta^\circ |- F^\circ : \kappa^\circ}
\]
\end{theorem}
\begin{theorem}[index erasure on type constructor equality]
\[ \inference{\Delta |- F=F':\kappa}
		{\Delta^\circ |- F^\circ=F'^\circ:\kappa^\circ}
\]
\label{thm:Fixierasetyconeq}
\end{theorem}

\begin{theorem}[index erasure on well-formed term level contexts]
\label{thm:Fixierasetmctx}
\[ \inference{\Delta |- \Gamma}{\Delta^\circ |- \Gamma^\circ} \]
\end{theorem}

\begin{theorem}[index erasure on index-free well-typed terms]
\label{thm:Fixierasetypingifree}
\[ \inference{ \Delta |- \Gamma & \Delta;\Gamma |- t : A}
		{\Delta^\circ;\Gamma^\circ |- t : A^\circ}
		{\enspace(\dom(\Delta)\cap\FV(t) = \emptyset)}
\]
\end{theorem}


We introduce an index variable selection meta-operation that selects all
the index variable bindings from the type level context.
\begin{definition}[index variable selection]
\[ \cdot^\bullet = \cdot \qquad
	(\Delta,X^{p\kappa})^\bullet = \Delta^\bullet \qquad
	(\Delta,i^A)^\bullet = \Delta^\bullet,i:A
\]
\end{definition}

\begin{theorem}[index erasure on well-formed term level contexts
		prepended by index variable selection]
\label{thm:Fixierasetmctxivs}
\[ \inference{\Delta |- \Gamma}{\Delta^\circ |- (\Delta^\bullet,\Gamma)^\circ}
\]
\end{theorem}

\begin{theorem}[index erasure on well-typed terms]
\label{thm:Fixierasetypingall}
\[ \inference{\Delta |- \Gamma & \Delta;\Gamma |- t : A}
		{\Delta^\circ;(\Delta^\bullet,\Gamma)^\circ |- t : A^\circ}
\]
\end{theorem}


\KYA{TODO has there been any studies on the logical consistencies of
	implicit calculus + equi-recursive type?}



\subsection{Conditions for well-behaved course-of-values recursion}
\label{ssec:fixi:theory:cv}

\begin{proposition}\label{prop:fixi:fmap}
For any $F : +* -> *$, there exists
\[ \textit{fmap}_F : \forall X^{*}.\forall Y^{*}.(X -> Y) -> F\;X -> F\;Y \]
\end{proposition}

start with a more easy one
\begin{proposition}
There exists
$\textit{fmap}_F : \forall X^{*}.\forall Y^{*}.(X -> Y) -> F\;X -> F\;Y$
for any $F : +* -> *$ such that
\begin{itemize}
	\item all free variables of $F$, including $X$ and $Y$,
		are introduced by universal quantification
		and those variabels are of kind $*$,
	\item all the bound variabels within $F$ are
		introduced by universal quantification
		and those variables are of kind $*$, and
	\item $F : +* -> *$ is in normal form, that is, $F$ can neither be
		an application ($F'\,G$) nor index application ($F'\{s\}$).
\end{itemize}
\end{proposition}
\begin{proof}
	We can derive $\textit{fmap}_F$ from the structure of $F$.
	Due to the kind of $F$ and the fact that $F$ is in normal form
	it must be a in the form of $\l Z^{+*}.B$.
\begin{itemize}
\item[case]($Z\notin \FV(B)$)
	$ \textit{fmap}_{(\l Z^{+*}. B)} = \l \_ . \l x. x $

	Since $F\;X = F\;Y = B$, we just return the identity function on $B$.

\item[case]($F \triangleq \l Z^{+*}. Z$)
	$ \textit{fmap}_{(\l Z^{+*}. Z)} = \l z . z $

	Since $F\;X = X$ and $F\;X = Y$,
	we return the function $z:X -> Y$ itself.

\item[case]($F \triangleq \l Z^{+*}. \forall X_1^{*} .B_1$)
	$\textit{fmap}_{(\l Z^{+*}. \forall X_1^{*} .B_1)}
	= \textit{fmap}_{(\l Z^{+*}.B_1)}$

\item[case]($F \triangleq \l Z^{+*}. A -> B_1$)

	When $Z\notin\FV(A)$,
	$\textit{fmap}_{(\l Z^{+*}.A -> B_1)}
	= \l z.\l y. \l x. \textit{fmap}_{(\l Z^{+*}.B_1)} \; z \; (y \; x)$

	When $A \triangleq \forall X_1^{*}.A_1$,
	$\textit{fmap}_{(\l Z^{+*}.(\forall X_1^{*}.A_1) -> B_1)}
	= \textit{fmap}_{(\l Z^{+*}.A_1 -> B_1)}$

	\begin{singlespace}
	When $A \triangleq A_1 -> \cdots -> A_n -> \forall X_2^{*}.B_2'$,
	\vspace{-1.5ex}
	\[\textit{fmap}_{(\l Z^{+*}.(A_1 -> \cdots -> A_n -> \forall X_2^{*}.B_2') -> B_1)}
	= \textit{fmap}_{(\l Z^{+*}.(A_1 -> \cdots -> A_n -> B_2') -> B_1)} \]

	When $A \triangleq A_1 -> \cdots -> A_n -> B_2$,
	where $B_2$ is not an arrow type
	\vspace{-1.5ex}
	\begin{align*}
	  & \textit{fmap}_{(\l Z^{+*}.(A_1 -> \cdots -> A_n -> B_2) -> B_1)} \\
	=~& \l z.\l y. \l x.\;
	\textit{fmap}_{(\l Z^{+*}.B_1)} \; z \;
		(y \; (\l x_1.\ldots\l x_n. ~
		   x  &\!\!\!\!(\textit{fmap}_{(\l Z^{+*}.A_1)} ~ z ~ x_1)& \\
		     &&\!\!\!\!\vdots \qquad\qquad& \\
		     &&\!\!\!\!(\textit{fmap}_{(\l Z^{+*}.A_n)} ~ z ~ x_n)&
		\,) \,)
	\end{align*}
	\end{singlespace}

\end{itemize}
\end{proof}

TODO to give an idea that the derived fmaps are type correct in the above
proof give a example in Haskell accepted by GHC for each case
(already have it almost done put it in the repository)

What if there are type constructor variables?
Should still work, let's write down the rules


Assume that either $*$ or $p* -> *$.
think about valuations of such variables

Having $A -> *$ won't make difference

would generalzied to arbitrary rank-1 kinded tycon variables


What about even higher kinded tycon variables?


\begin{proposition}\label{prop:fixi:fmapFree}
If $\textit{fmap}_F:\forall X^{*}.\forall Y^{*}.(X -> Y) -> F\;X -> F\;Y$
exists, then
\begin{align*}
\textit{fmap}_F~\textit{id} &~=~ \textit{id} \\
\textit{fmap}_F~\textit{f} \;\circ\; \textit{fmap}_F~\textit{g}
&~=~ \textit{fmap}_F~(f\circ g)
\end{align*}
\end{proposition}\noindent
This is a well-known parametricity theorem on maps any instance of the type
$\forall X^{*}.\forall Y^{*}.(X -> Y) -> F\;X -> F\;Y$ satisfies
the two equations above. However, for the purpose of defining $\McvPr_{*}$,
we only need to know that there exists one such $\textit{fmap}_F$. That is,
\begin{proposition}\label{prop:fixi:fmapHom}
For any $F : +* -> *$, there exists

$\textit{fmap}_F:\forall X^{*}.\forall Y^{*}.(X -> Y) -> F\;X -> F\;Y$
such that
\begin{align*}
\textit{fmap}_F~\textit{id} &~=~ \textit{id} \\
\textit{fmap}_F~\textit{f} \;\circ\; \textit{fmap}_F~\textit{g}
&~=~ \textit{fmap}_F~(f\circ g)
\end{align*}
\end{proposition}
\begin{proof}
	You can check that each case
	in the proof of Proposition \ref{prop:fixi:fmap}
	satisfies the two equations above.
\end{proof}

\begin{proposition} For any $F : +* -> *$, there exists
$\unIn_F : \mu^{+}{*} F -> F(\mu^{+}{*} F)$ such that
$\unIn_F (\In_F\;t) -->+ t$.
\end{proposition}
\begin{proof}
Since we know that $\textit{fmap}_F$ exists by Proposition~\ref{prop:fixi:fmap},
we can define
\[ \unIn_F = \McvPr_{*}\;
            (\l\_.\l\textit{cast}.\l\_.\l x.\textit{fmap}_F\;\textit{cast}\;x)
\]

From Proposition~\ref{prop:fixi:fmapFree}, we know that
$\textit{fmap}_F\;\textit{id}\;x -->+ x$.
Thus,
\[ \unIn_F (\In_F\;t) -->+ \textit{fmap}_F\;\textit{id}\;t -->+ t \]
\end{proof}

\begin{align*}
A \rrarrow_{*} B &~\triangleq~ A -> B \\
F \rrarrow^{p\kappa -> \kappa'} G &~\triangleq~
	\forall X^\kappa.\forall Y^\kappa.
		(X \rrarrow_\kappa Y) -> F X \rrarrow_\kappa F Y \\
F \rrarrow^{A -> \kappa} G &~\triangleq~
	\forall i^A.\forall f^{A->A}. F\{i\} \rrarrow_\kappa F\{f\;i\}
\end{align*}

\[
\textsf{mon}_\kappa
  = \l X^{0\kappa}.X \rrarrow^\kappa X
\]

$\textsf{mon}_{+* -> *} F$ is the type of $\textit{fmap}_F$
where $F : +* -> *$.

$\textsf{mon}_{+(p* -> *)->(p* -> *)} F$ is the type of $\textit{fmap1}_F$
where $F : +(p* -> *)->(p* -> *)$.

if $\textsf{mon}_{+(p* -> *)->(p* -> *)}$ is inhabited
then $\unIn_F$ for any $F : +(p* -> *)->(p* -> *)$?

what about general case? if $\textsf{mon}_\kappa$ is inhabited
then $\unIn_F$ for any $F : \kappa$?

