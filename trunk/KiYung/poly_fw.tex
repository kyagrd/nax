\section{System \Fw} \label{sec:fw}
%%%% TODO citation for Fw ... was it Girard??
System \Fw\ extends the type syntax of System \F\ with lambda types and
application types (see Figure \ref{fig:fw}). Lambda types ($\l X^\kappa.F$)
and application types ($F\;G$) at type level are analogous to lambda terms
and applications at term level. Type constructors are like functions, but
at type level. Type constructors are categorized by kinds, just as termes
are categorized by types. A type constructor of kind $\kappa -> \kappa'$
expects another type constructor of kind $\kappa$ as an argument to produce
yet another type constructor of kind $\kappa'$, just as a function of type
$A -> B$ expects another term of type $A$ as an argument to produce yet another
term of type $B$. Type constructors of the star kind ($*$), or just
\emph{types}, do not expect any arguments. Type constructors that expect
an argument are of arrow kinds ($\kappa -> \kappa'$). By convention,
$A$ and $B$ stands for types (\ie, type concstructors of kind $*$),
and $F$ and $G$ stands for type constructors or arbitrary kinds.

We can think of System \F\ as a restriction of System \Fw\ where we only
allow types of the star kind ($*$). So, all the type variables appearing in
well-kinded types in System \F\ are of the star kind. Since there exist only
one kind ($*$) in System \F, the kinding rules of System \F\ only need to make
sure that type variables are bounded (\ie, member of $\Delta$). 
Since the kind structure of System \Fw\ is richer than System \F, we need to
keep track of the kind of the type variables in the kinding context ($\Delta$).
So, the kinding context is extended by a type variable annotated by its kind
($X^\kappa$). The kinding rules of System \Fw\ keep track of the kinds of
type constructors as well as making sure that the type variables are bounded.
The kinding rules \rulename{TVar}, \rulename{TArr}, \rulename{TAll}
are similar to the kinding rules of System \F. The kinding rules
\rulename{TLam} and \rulename{TApp} states when lambda types and
application types are well-kinded.

Typing rules of System \Fw\ are almost identical to the typing rules of
System \F, except for one new rule \rulename{Conv}. The \rulename{Conv} rule
supports conversion between equivalent types beyond $\alpha$-equivalence
(\ie, up to change of bound type variable names).
In STLC, types are equal when they are syntactically identical.
In System \F, types are equal when they are $\alpha$-equivalent. For example,
$\forall X.X$ and $\forall X'.X'$ are considered to be same types in System \F.
In System \Fw, we expect richer notion of equality, such as $\beta$-equivalence,
since the type syntax of System \Fw\ is analogous to a STLC at type level.
For instance, we want $(\lambda X^{*}.X) A = A$. The equality rules over
type constructors are illustrated in Figure \ref{fig:eqtyfw}.
The \rulename{EqTBeta} rule describes the essence of $\beta$-equivalence.
Other rules describe structural nature of equality (\rulename{EqTVar},
\rulename{EqTArr}, \rulename{EqTAll}, \rulename{EqTLam}, \rulename{EqTApp}.)
and transitivity of equality (\rulename{EqTTrans}).

%% syntax directed formalism???
%% http://pauillac.inria.fr/~herbelin/talks/cic.ps
%% there is a slide the refers to other paper and say that CIC is okay
%% since CIC is full. Is Fw also?

The complete syntax, kinding rules, and typing rules of System \Fw
are illustrated in Figure \ref{fig:fw}. The left column describes
the Church-Church-style System \F\ and the right column describes
the Curry-Church-style System \F. Since lambda types exist at type level
in System \Fw, we also have a choice of either Church style (kind annotations
on lambda types) or Curry style (no kind annotations on lambda types) for
the type syntax. The Church-Church-style System \Fw\ is a version System \Fw\ 
with the Church-style term syntax and the Church-style type syntax.
The Curry-Church-style System \Fw\ is a version of System \Fw\ 
with the Curry-style term syntax and the Church-style type syntax.
Another version of System \Fw, the Curry-Curry-style System \Fw,
with Curry-style term syntax and Curry style type syntax is described
in the left column of Figure \ref{fig:fw2}.

The reduction rules of System \Fw\ (Figure \ref{fig:redfw}) are
almost identical to the reduction rules of System \F\ since the term syntax of
System \Fw\ is almost identical to the term syntax of System \F.
The Church-style term syntax only differs from the term syntax of System \F\ 
that there is a kind annotation on the type variable appearing in
the type abstraction ($\L X^\kappa.t$). The Church-style term syntax is
exactly the same as the term syntax of System \F.

\begin{figure}
\begin{singlespace}
\begin{minipage}{.46\textwidth}
	\begin{center}Church-Church-style\end{center}\vspace*{-1em}
\def\baselinestretch{0}
\small
\begin{align*}
\textbf{term syntax} \\
t,s ::= &~ x               & \text{variable}    \\
      | &~ \l(x:A) . t     & \text{abstraction} \\
      | &~ t ~ s           & \text{application} \\
      | &~ \L X^\kappa . t & \text{type abstraction} \\
      | &~ t [G]           & \text{type application} \\
\textbf{type syntax} \\
F,G,A,B ::= &~ X                  & \text{variable type} \\
          | &~ A -> B             & \text{arrow type} \\
          | &~ \forall X^\kappa.B & \text{forall type}   \\
          | &~ \l X^\kappa.F      & \text{lambda type}   \\
          | &~ F ~ G              & \text{application type}   \\
\textbf{kind syntax} \\
\kappa ::= &~ \kappa -> \kappa' & \text{arrow kind} \\
         | &~ *                 & \text{star kind}   \\
\end{align*}
\[ \textbf{kinding rules} \quad \framebox{$ \Delta |- F:\kappa $} \]\vspace*{-1em}
\begin{align*}
& \inference[\sc TVar]{X^\kappa \in \Delta}{\Delta |- X:\kappa} \\
& \inference[\sc TArr]{\Delta |- A:* & \Delta |- B:*}{\Delta |- A -> B:*} \\
& \inference[\sc TAll]{\Delta,X^\kappa |- B:*}
		      {\Delta |- \forall X^\kappa.B:*} \\
& \inference[\sc TLam]{\Delta,X^\kappa |- F:\kappa'}
		      {\Delta |- \l X^\kappa.F:\kappa -> \kappa'} \\
& \inference[\sc TApp]{\Delta |- F : \kappa -> \kappa' & \Delta |- G : \kappa}
		      {\Delta |- F ~ G : \kappa'} \\
\end{align*}
\[ \textbf{typing rules} \quad \framebox{$ \Delta;\Gamma |- t : A $ } \]
\vspace*{-1em}
\begin{align*}
& \inference[\sc Var]{x:A \in \Gamma}{\Delta;\Gamma |- x:A} \\
& \inference[\sc Abs]{\Delta |- A:* & \Delta;\Gamma,x:A |- t : B}
		     {\Delta;\Gamma |- \l(x:A).t : A -> B} \\
& \inference[\sc App]{\Delta;\Gamma |- t : A -> B & \Delta;\Gamma |- s : A}
		     {\Delta;\Gamma |- t~s : B} \\
& \inference[\sc TyAbs]{\Delta,X^\kappa;\Gamma |- t : B}
		       {\Delta;\Gamma |- \L X^\kappa.t : \forall X^\kappa.B} \\
& \inference[\sc TyApp]{\Delta;\Gamma |- t : \forall X^\kappa.B & \Delta |- G:\kappa}
		       {\Delta;\Gamma |- t[G] : B[G/X]} \\
& \inference[\sc Conv]{\Delta;\Gamma |- t : A & \Delta |- A = A' : *}
		      {\Delta;\Gamma |- t : A'}
\end{align*}
\end{minipage}
\begin{minipage}{.46\textwidth}
	\begin{center}Curry-Church-style\end{center}\vspace*{-1em}
\def\baselinestretch{0}
\small
\begin{align*}
\textbf{term syntax} \\
t,s ::= &~ x           \\
      | &~ \l x    . t \\
      | &~ t ~ s       \\
      \phantom{|} &~ \\
      \phantom{|} &~ \\
\textbf{type syntax} \\
F,G,A,B ::= &~ X                  \\
          | &~ A -> B             \\
          | &~ \forall X^\kappa.B \\
          | &~ \l X^\kappa.F      \\
          | &~ F ~ G              \\
\textbf{kind syntax} \\
\kappa ::= &~ \kappa -> \kappa' \\
         | &~ *                 \\
\end{align*}
\[ \textbf{kinding rules} \quad \framebox{$ \Delta |- F:\kappa$}\]\vspace*{-1em}
\begin{align*}
& \inference[\sc TVar]{X^\kappa \in \Delta}{\Delta |- X:\kappa} \\
& \inference[\sc TArr]{\Delta |- A:* & \Delta |- B:*}{\Delta |- A -> B:*} \\
& \inference[\sc TAll]{\Delta,X^\kappa |- B:*}{\Delta |- \forall X^\kappa.B:*} \\
& \inference[\sc TLam]{\Delta,X^\kappa |- F:\kappa'}
		      {\Delta |- \l X^\kappa.F:\kappa -> \kappa'} \\
& \inference[\sc TApp]{\Delta |- F : \kappa -> \kappa' & \Delta |- G : \kappa}
		      {\Delta |- F ~ G : \kappa'} \\
\end{align*}
\[ \textbf{typing rules} \quad \framebox{$ \Delta;\Gamma |- t : A $ } \]
\vspace*{-1em}
\begin{align*}
& \inference[\sc Var]{x:A \in \Gamma}{\Delta;\Gamma |- x:A} \\
& \inference[\sc Abs]{\Delta |- A:* & \Delta;\Gamma,x:A |- t : B}
		     {\Delta;\Gamma |- \l x   .t : A -> B} \\
& \inference[\sc App]{\Delta;\Gamma |- t : A -> B & \Delta;\Gamma |- s : A}
		     {\Delta;\Gamma |- t~s : B} \\
& \inference[\sc TyAbs]{\Delta,X^\kappa;\Gamma |- t : B}
		       {\Delta;\Gamma |- t : \forall X^\kappa.B} \\
& \inference[\sc TyApp]{\Delta;\Gamma |- t : \forall X^\kappa.B & \Delta |- G:\kappa}
		       {\Delta;\Gamma |- t : B[G/X]} \\
& \inference[\sc Conv]{\Delta;\Gamma |- t : A & \Delta |- A = A' : *}
		      {\Delta;\Gamma |- t : A'}
\end{align*}
\end{minipage}
~\\
\caption{System \Fw\ in Church-Church-style and Curry-Church-style}
\label{fig:fw}
\end{singlespace}
\end{figure}

\begin{figure}
\begin{singlespace}
\begin{minipage}{.46\textwidth}
	\begin{center}Curry-Church-style\end{center}
\def\baselinestretch{0}
\small
\begin{align*}
\textbf{term syntax} \\
t,s ::= &~ x           & \text{variable}    \\
      | &~ \l x    . t & \text{abstraction} \\
      | &~ t ~ s       & \text{application} \\
\textbf{type syntax} \\
F,G,A,B ::= &~ X                  & \text{variable type}    \\
          | &~ A -> B             & \text{arrow type}       \\   
          | &~ \forall X^\kappa.B & \text{forall type}      \\
          | &~ \l X^\kappa.F      & \text{lambda type}      \\
          | &~ F ~ G              & \text{application type} \\
\textbf{kind syntax} \\
\kappa ::= &~ \kappa -> \kappa' & \text{arrow kind} \\
         | &~ *                 & \text{star kind}   \\
\end{align*}
\[ \textbf{kinding rules} \quad \framebox{$ \Delta |- F:\kappa $} \]\vspace*{-1em}
\begin{align*}
& \inference[\sc TVar]{X^\kappa \in \Delta}{\Delta |- X:\kappa} \\
& \inference[\sc TArr]{\Delta |- A:* & \Delta |- B:*}{\Delta |- A -> B:*} \\
& \inference[\sc TAll]{\Delta,X^\kappa |- B:*}{\Delta |- \forall X^\kappa.B:*} \\
& \inference[\sc TLam]{\Delta,X^\kappa |- F:\kappa'}
		      {\Delta |- \l X^\kappa.F:\kappa -> \kappa'} \\
& \inference[\sc TApp]{\Delta |- F : \kappa -> \kappa' & |- G : \kappa}
		      {\Delta |- F ~ G : \kappa'} \\
\end{align*}
\[ \textbf{typing rules} \quad \framebox{$ \Delta;\Gamma |- t : A $ } \]
\vspace*{-1em}
\begin{align*}
& \inference[\sc Var]{x:A \in \Gamma}{\Delta;\Gamma |- x:A} \\
& \inference[\sc Abs]{\Delta |- A:* & \Delta;\Gamma,x:A |- t : B}
		     {\Delta;\Gamma |- \l x   .t : A -> B} \\
& \inference[\sc App]{\Delta;\Gamma |- t : A -> B & \Delta;\Gamma |- s : A}
		     {\Delta;\Gamma |- t~s : B} \\
& \inference[\sc TyAbs]{\Delta,X^\kappa;\Gamma |- t : B}
		       {\Delta;\Gamma |- t : \forall X^\kappa.B} \\
& \inference[\sc TyApp]{\Delta;\Gamma |- t : \forall X^\kappa.B & \Delta |- G:\kappa}
		       {\Delta;\Gamma |- t : B[G/X]} \\
& \inference[\sc Conv]{\Delta;\Gamma |- t : A & \Delta |- A = A' : *}
		      {\Delta;\Gamma |- t : A'}
\end{align*}
\end{minipage}
\begin{minipage}{.46\textwidth}
	\begin{center}Curry-Curry-style\end{center}
\def\baselinestretch{0}
\small
\begin{align*}
\textbf{term syntax} \\
t,s ::= &~ x           \\
      | &~ \l x    . t \\
      | &~ t ~ s       \\
\textbf{type syntax} \\
F,G,A,B ::= &~ X                  \\
          | &~ A -> B             \\   
          | &~ \forall X.B \\
          | &~ \l X.F      \\
          | &~ F ~ G              \\
\textbf{kind syntax} \\
\kappa ::= &~ \kappa -> \kappa'  \\
         | &~ *                  \\
\end{align*}
\[ \textbf{kinding rules} \quad \framebox{$ \Delta |- F:\kappa $} \]\vspace*{-1em}
\begin{align*}
& \inference[\sc TVar]{X^\kappa \in \Delta}{\Delta |- X:\kappa} \\
& \inference[\sc TArr]{\Delta |- A:* & \Delta |- B:*}{\Delta |- A -> B:*} \\
& \inference[\sc TAll]{\Delta,X^\kappa |- B:*}{\Delta |- \forall X.B:*} \\
& \inference[\sc TLam]{\Delta,X^\kappa |- F:\kappa'}
		      {\Delta |- \l X.F:\kappa -> \kappa'} \\
& \inference[\sc TApp]{\Delta |- F : \kappa -> \kappa' & |- G : \kappa}
		      {\Delta |- F ~ G : \kappa'} \\
\end{align*}
\[ \textbf{typing rules} \quad \framebox{$ \Delta;\Gamma |- t : A $ } \]
\vspace*{-1em}
\begin{align*}
& \inference[\sc Var]{x:A \in \Gamma}{\Delta;\Gamma |- x:A} \\
& \inference[\sc Abs]{\Delta |- A:* & \Delta;\Gamma,x:A |- t : B}
		     {\Delta;\Gamma |- \l x   .t : A -> B} \\
& \inference[\sc App]{\Delta;\Gamma |- t : A -> B & \Delta;\Gamma |- s : A}
		     {\Delta;\Gamma |- t~s : B} \\
& \inference[\sc TyAbs]{\Delta,X^\kappa;\Gamma |- t : B}
		       {\Delta;\Gamma |- t : \forall X.B} \\
& \inference[\sc TyApp]{\Delta,X^\kappa;\Gamma |- t : B & \Delta |- G:\kappa}
		       {\Delta;\Gamma |- t : B[G/X]} \\
& \inference[\sc Conv]{\Delta;\Gamma |- t : A & \Delta |- A = A' : *}
		      {\Delta;\Gamma |- t : A'}
\end{align*}
\end{minipage}
~\\
\caption{System \Fw\ in Curry-Church-style and Curry-Curry-style}
\label{fig:fw2}
\end{singlespace}
\end{figure}

\begin{figure}
\paragraph{Reduction rules for the Church-$*$-style System \Fw}
\begin{align*}
& \inference[\sc RedBeta]{}{(\l(x:A).t)~s --> t[s/x]}
&&\inference[\sc RedTy]{}{(\L X   .t)[A] --> t[A/X]} \\
& \inference[\sc RedAbs]{t --> t'}{\l x   .t --> \l x   .t'}
&&\inference[\sc RedTyAbs]{t --> t'}{\L X^\kappa   .t --> \L X^\kappa   .t'} \\
& \inference[\sc RedApp1]{t --> t'}{t~s --> t'~s}
&&\inference[\sc RedTyApp]{t --> t'}{t[A] --> t'[A]} \\
& \inference[\sc RedApp2]{s --> s'}{t~s --> t~s'}
\end{align*}
\paragraph{Reduction rules for the Curry-$*$-style System \Fw}
\begin{align*}
& \inference[\sc RedBeta]{}{(\l x   .t)~s --> t[s/x]} \\
& \inference[\sc RedAbs]{t --> t'}{\l x   .t --> \l x   .t'} \\
& \inference[\sc RedApp1]{t --> t'}{t~s --> t'~s} \\
& \inference[\sc RedApp2]{s --> s'}{t~s --> t~s'}
\end{align*}
\caption{Reduction rules for System \Fw}
\label{fig:redfw}
\end{figure}

\begin{figure}
\begin{align*}
& \inference[\sc EqTBeta]
	{\Delta,X^\kappa |- F : \kappa -> \kappa' & \Delta |- G : \kappa}
	{\Delta |- (\l X^\kappa.F)\;G = F[G/X] : \kappa'} \\
& \inference[\sc EqTVar]{X^\kappa \in \Delta}{\Delta |- X = X : \kappa} \\
& \inference[\sc EqTArr]{\Delta |- A=A':* & \Delta |- B=B':*}
			{\Delta |- A -> B=A' -> B':*} \\
& \inference[\sc EqTAll]{\Delta,X^\kappa |- B=B':*}
			{\Delta |- \forall X^\kappa.B=B':*} \\
& \inference[\sc EqTLam]
	{\Delta,X^\kappa |- F=F':\kappa'}
        {\Delta |- \l X^\kappa.F=\l X^\kappa.F':\kappa -> \kappa'} \\
& \inference[\sc EqTApp]
	{\Delta |- F=F' : \kappa -> \kappa' & \Delta |- G=G' : \kappa}
        {\Delta |- F ~ G = F' ~ G' : \kappa'} \\
& \inference[\sc EqTTrans]
	{\Delta |- F=F' : \kappa & \Delta |- F'=F'' : \kappa}
        {\Delta |- F=F'' : \kappa'}
\end{align*}
\caption{Type constructor equality rules for $*$-Church-style System \Fw}
\label{fig:eqtyfw}
\end{figure}

\paragraph{From Curry-Church-style to Curry-Curry-style}
We can also have a version of \Fw\ where type syntax is also in Curry style.
That is, the forall type ($\forall X.B$) and the lambda type ($\l X.B$)
do not have kind annotations. We call this version of \Fw, where both terms
and types are unannotated, the Curry-Curry-style \Fw.
In Figure \ref{fig:fw2}, the Curry-Curry-style \Fw\ (right) is laid out
side-by-side to the Curry-Church-style \Fw\ (left).

Since we changed the type syntax of forall types and lambda types in
the Curry-Curry-style \Fw, we need to adjust the we need to adjust the rules
involving forall types and lambda types. The rules we need to adjust are
the kinding rules \rulename{TAll} and \rulename{TLam}, and
the typing rules \rulename{TyAbs} and \rulename{TyApp}.

For the kinding rules \rulename{TAll} and \rulename{TLam}, all we need to do
is simply dropping the kind annotations appearing in the forall type and
the lambda type in each rule. In Figure \ref{fig:fw2}, you can see that
\rulename{TAll} and \rulename{TLam} in left (Curry-Church-style) and
right (Curry-Curry-style) are identical except for the kind annotations on
the forall type and the lambda type.

How should we adjust the typing rules \rulename{TyAbs} and \rulename{TyApp}
in the Curry-Curry-style \Fw? Our first attempt may be just dropping
the kind annotations (just as we did for the kinding rules) to adjust to
the changes to the type syntax as below:
\begin{align*}
& \inference[\sc TyAbs]{\Delta,X^\kappa;\Gamma |- t : B}
		       {\Delta;\Gamma |- t : \forall X.B}
& \inference[\sc TyApp]{\Delta;\Gamma |- t : \forall X.B & \Delta |- G:\kappa}
		       {\Delta;\Gamma |- t : B[G/X]}
\end{align*}
The \rulename{TyAbs} rule above is fine. However, the \rulename{TyApp} rule
above is problematic because it fails to require that $X$ must be of kind
$\kappa$ as well as $G$. To ensure that $X$ is of kind $\kappa$, we need to
adjust the \rulename{TyApp} rule as follows:
\begin{align*}
& \phantom{ \inference[\sc TyAbs]{\Delta,X^\kappa;\Gamma |- t : B}
                                 {\Delta;\Gamma |- t : \forall X.B} }
& \inference[\sc TyApp]{\Delta,X^\kappa;\Gamma |- t : B & \Delta |- G:\kappa}
			{\Delta;\Gamma |- t : B[G/X]}
\end{align*}
Note, the first premise ($\Delta,X^\kappa;\Gamma |- t : B$) of
the \rulename{TyApp} rule is exactly the same as the premise of
the \rulename{TyAbs} rule.

\paragraph{Church-Curry-style \Fw}
Although not illustrated in Figures \ref{fig:fw} and \ref{fig:fw2},
we can imagine yet another version of \Fw\ with annotated terms
and unannotated types -- namely, the Church-Curry-style \Fw.
I am not sure when one would need this style, though.

\subsection{Encodings of datatypes in System \Fw}
\label{sec:fw:data}
In System \Fw, we can encode all the datatypes encodable in System \F\ (see
\S\ref{sec:f:data}) and more. \emph{Type constructors} for polymorphic datatypes
can be encoded using lambda types that abstract over types.
\emph{Non-regular datatypes}, or \emph{nested datatypes}, can be encoded
using forall types that are polymorphic over type constructors.
The ability to universally quantify over not only types but also
type constructors is called \emph{higher-kinded polymorphsim}.
\emph{Type constructors of higher kinds}, or \emph{higher-kinded
type constructors} are type constructors that expect type constructors
as their arguments. With higher-kinded type constructors, we can even encode
the recursive type operator $\mu$ in System \Fw. More generally, we can encode
a family of kind-indexed recursive type operators $\mu_\kappa$ using both
higher-kinded type constructors and higher-kinded polymorphism.

\paragraph{Type constructors for polymorphic datatypes} expect
other types as arguments to produce a datatype. We can encode these 
type constructors in System \Fw. For example, the shorthand notations
(or, type synonyms) in \S\ref{sec:f:data}), such as $(\times)$ for pair types
and $(+)$ for sum types, can be encoded as as follows:\footnote{Here,
	I used a Haskell-ish notation of turning a infix binary operator
	into a prefix binary operator by surrounding the operator in parenthesis
	(\eg, $(+)\;X_1\,X_2 = X_1 + X_2$). I also annotated the kinds of
	the type constructors after the colon (:).}
\begin{align*}
(\times) &= \l X_1^{*}.\l X_2^{*}.(X_1 -> X_2 -> X) -> X &:~ * -> * -> * \\
     (+) &= \l X_1^{*}.\l X_2^{*}.(X_1 -> X) -> (X_2 -> X) -> X &:~ * -> * -> *
\end{align*}
Type constructors for polymorphic recursive datatypes are encodable as well.
For instance, we can encode the constructor \textit{List}
for the polymorphic list datatype:
\begin{align*}
	\textit{List} &= \l X_a^{*}.\forall X^{*}.(X_a -> X -> X) -> X -> X
	&:~ * -> *
\end{align*}
In System \F, type constructors, such as $(\times)$, $(+)$, and
\textit{List} are meta-level concepts (or, shorthand notations, macros)
that cannot be encoded within the type system of System \F.
In System \Fw, these datatype constructors are encodable as type constructors,
which are ordinary constructs of System \Fw.

\paragraph{Higher-kinded datatype constructors} that expect
not only types but also type constructors of arbitrary kinds as arguments
are encodable in System \Fw\ as well. For example, we can encode
\textit{Flip}, which flips the order of the first and second arguments of
a binary type constructor (\ie, $(\textit{Flip}\;F)\,A_1\,A_2 = F\,A_2\,A_1$),
and \textit{Comp}, which composes two unary type constructors
(\ie, $(\textit{Comp}\;F_1\,F_2)\,A = F_1\,(F_2\,A)$), as follows:
\begin{align*}
\textit{Flip} &= \l X_{\!f}^{*-> *-> *}.\l X_1^{*}.\l X_2^{*}.X_{\!f}\,X_2\;X_1
		     &:\;& (* -> * -> *) -> * -> * -> * \\
\textit{Compose} &= \l X_{\!f}^{*-> *}.\l X_g^{*-> *}.\l X^{*}.X_{\!f}\,(X_g\,X)
		     &:\;& (* -> *) -> (* -> *) -> * -> *
\end{align*}

\paragraph{Higher-kinded polymorphism} is the ability universally quantify
over type constructors as well as types. That is, we can have
$\forall X^\kappa.B$ where $\kappa$ is not the star kind.
We can encode \emph{non-regular (recursive) datatypes} in System \Fw\ using
higher-kinded polymorphism.

We mentioned that we can \emph{regular (recursive) datatypes}
in Systerm \F\ (\S\ref{sec:f:data}), but have not discussed
what regular datatypes are. A representative example of a regular datatype
is the polymorphic list type ($\forall X_a.\textit{List}\,X_a$).
We say that the polymorphic list type is regular since its recursive
component, the tail, has exactly the same type. That is, for any
non-empty list of $\textit{List}\,A$, its tail must be of type $\text{List}\,A$.
Many other well-known recursive datatypes are regular (\eg, binary trees).

We can imagine a non-regular twist to the regualr polymorphic list type
by insisting the recursive components (\ie, tails) to have different
type arguments from the list they are part of. For instance, we may inisist
that a list-like datatype of type ($\textit{Powl}\;A$) must have its tail be
of type $(\textit{Powl}\,(A\times A))$. That is, if the first element is
an integer (\eg, $1$), then the second element must be a pair of integers
(\eg, $(2,3)$), and the third elment must be a pair of pair of integers
(\eg, $((4,5),(6,7))$), and so on. We can depict an example of this list-like
datatype with a three element as: $[1,\,(2,3),\,((4,5),(6,7))]$.
This is a representative example of a non-regular datatype called powerlists.
Such datatypes are also called \emph{nested datatypes} %% TODO cite
since the type arguments appllied to the type constructor become
more complicated, or nested, as we step further inside the recursive components.

We can encode the type constroctor \textit{Powl} for powerlists using
higher-kinded polymorphism of System \Fw, as follows
(\cf\ encoding of \textit{List}):
\begin{align*}
\textit{Powl} &= \l X_a^{*}.\forall X^{* -> *}&.&
	(X_a -> X(X_a\times X_a) & -> & X\,X_a) & -> & X\,X_a & -> & X\,X_a \\
\textit{List} &= \l X_a^{*}.\forall X^{*}&.&
	(X_a -> X & -> & X) & -> & X & -> & X
\end{align*}
Unlike the encoding of \textit{List}, where $X$ is polymorphic over types
of kind $*$, the universally quantified variable $X$ in the encoding of
\textit{Powl} is polymorphic over constructors of kind $* -> *$.
Intuitively, $X$ in the list encoding corresponds to $\textit{List}\;X_a$
(\ie, the type constructor \textit{List} applied to its uniform argument $X_a$),
and, $X$ in the powerlist encoding corresponds to \textit{Powl} without
being applied to its argument so that it may be applied to a non-regular
argument (\eg, $X(X_a\times X_a)$). See Chapter \ref{ch:mendler} for more
examples and discussions on non-regular datatypes.
%% TODO update the fwd ref to a section later

\paragraph{The recursive type operator $\mu$} builds a recursive type
($\mu F$) from a non-recursive base structure ($F:* -> *$).
Theories on recursive datatypes are often formulated in terms of
the recursive type operator $\mu$, which satisfies the property
that $\mu F = F (\mu F)$ for any $F: * -> *$. A recursive datatype ($\mu F$)
is built from its base structure ($F$) by applying the recursive operator.
For example, the natural number datatype can be built from the base structure
$F = \l X_r^{*}.X_r + \textit{Unit}$. Intuitively, we can understand this
base structure as a specification for natural numbers: a natural number is
either a successor of a recursive object ($X_r$)
or zero encoded as the unit object (\textit{Unit}).
From this base structure, we can define
$\textit{Nat} = \mu(\l X_r^{*}.X_r + \textit{Unit})$.
Let us write down the desired property of $\mu$ for $\textit{Nat}$.
\begin{align*}
\mu(\l X_r^{*}.X_r + \textit{Unit}) &=
(\l X_r^{*}.X_r + \textit{Unit})(\mu(\l X_r^{*}.X_r + \textit{Unit})) \\
\textit{Nat} &= (\l X_r^{*}.X_r + \textit{Unit})\,\textit{Nat} \\
\textit{Nat} &= \textit{Nat}\, + \textit{Unit}
\end{align*}
Note, the simplified last equation looks very similar to
the recursive datatype definitions for unary natural numbers
in functional languages, such as Haskell: \[ \qquad\qquad
\textbf{data}~\textit{Nat} = \texttt{Succ}~\textit{Nat}\,\mid\,\texttt{Zero} \]
See Chapter \ref{ch:mendler} %% TODO update the fwd ref to a section later
for more of the Haskell examples on recursive datatypes and $\mu$.

Although recursive datatypes are encodable in System \F (\S\ref{sec:f:data}),
extensions of System \F\ with $\mu$ have been studied %% TODO cite
since we can reason about recursive datatypes more uniformly based on
the properties of $\mu$. In System \Fw, we can encode $\mu$ using
higher-kinded type constructors and higher-kinded polymorphism as follows:
\[
\mu =
 \l X_{\!f}^{* -> *}.
 \forall X'^{*}.(\forall X_r^{*}.(X_r -> X') -> X_{\!f}\,X_r -> X') -> X'
 ~:\; (* -> *) -> *
\]
Let us intuitively derive above the encoding of $\mu$ starting from
the impredicative encoding of natural numbers:
\begin{align*}
\textit{Nat}
	&= \forall X^{*} . (X -> X) -> X -> X \\
	&\cong \forall X^{*} . (X -> X) -> (\textit{Unit} -> X) -> X 
		&(\because \textit{Unit} -> X \cong X) \\
	&\cong \mu(\l X_r^{*}.\,X_r + \textit{Unit})
		& (\text{to show})
\end{align*}
We want to show that the impredicative encoding of natural numbers is
equivalent to the natural number type defined using $\mu$. We need turn
the impredicative encoding of natural numbers into a non-recursive
base structure by abstract away the recursive component, which is
the underlined part below. That is, we replace the underlined $X$
with a new variable $X_r$:
\begin{align*}
\forall X^{*} . (\underline{X}\; -> X) -> (\textit{Unit} -> X) -> X \\
\forall X^{*} . (X_r -> X) -> (\textit{Unit} -> X) -> X
\end{align*}
Recall that
$X_r +\textit{Unit} = \forall X^{*} . (X_r -> X) -> (\textit{Unit} -> X) -> X$.
Recall that the idea behind the impredicative encoding is that we can eliminate
an object of the datatype into an arbitrary result type $X$. If we are to
encode datatypes constructed by $\mu$, we apply this idea of
impredicative encoding in two layers: for the base structure and for $\mu$.
We already know how to encode the base structure: with the encoding above,
we can eliminate to an arbitrary result type $X$. For $\mu$, we introduce
yet another variable $X'$ so that we can eliminate to an arbitrary result
type $X'$. Thus, the encoding for natrual number type constructed using $\mu$
would be of the following form:
\[ \forall X'^{*}.(\;\dots\;\dots\;\dots\;\dots\;\dots (X_r + \textit{Unit}) -> X') -> X' \]
Since the recursive type contains the base structure, we would be able to
eliminate the recursive type, given that we know how to eliminate
the base structure $((X_r + \textit{Unit}) -> X')$.
However, this is not yet complete because we do not know how to eliminate $X_r$.
So, we require that we should also know how to eliminate $X_r$, as follows:
\[ \forall X'^{*}.
	(\forall X_r^{*}.(X_r -> X') -> (X_r + \textit{Unit}) -> X') -> X' \]
We can derive the encoding for $\mu$ (repeated below)
so that $\mu(\l X_r^{*}.X_r + \textit{Unit})$ is equivalent to above.
\[
\mu =
 \l X_{\!f}^{* -> *}.
 \forall X'^{*}.(\forall X_r^{*}.(X_r -> X') -> X_{\!f}\,X_r -> X') -> X'
 ~:\; (* -> *) -> *
\]
Note that $X_r$ is also universally quantified
in $(\forall X_r^{*}.(X_r -> X') -> X_{\!f}\,X_r -> X')$
locally.
See Chapter \ref{ch:mendler} %% TODO update the fwd ref to a section later
for an intuitive explanation for why $X_r$ should be universally quantified.

The (data) constructor for the reucrisve type operator $\mu$ is called $\In$
and the eliminator is called $\MIt$. The encodings of $\In$ and $\MIt$ as
Curry-style terms are as follows:
\[ \In = \l x_r. \l x_\varphi.x_\varphi\,(\MIt~x_\varphi)\,x_r
\qquad\qquad \MIt = \l x_\varphi.\l x_r.x_r\,x_\varphi \]
These ($\mu$, $\In$, and $\MIt$) are, in fact, encodings for
Mendler-style iteration, which will be discussed in Chapter \ref{ch:mendler}.
%% TODO update the fwd ref to a section later

%%% TODO fwd ref

\paragraph{A kind-indexed family of recursive type operators $\mu_\kappa$:}
The recursive type operator $\mu : (* -> *) -> *$ discussed so far can only
construct (non-mutually recursive) regular datatypes. For example,
\begin{align*}
\textit{Nat} &= \mu(\l X^{*}.X + \textit{Unit}) \\
\textit{List} &= \l X_a^{*}.\mu(\l X^{*}.(X_a\times X) + \textit{Unit})
\end{align*}
More generally, there is a family of recursive type operators
$\mu_\kappa : (\kappa -> \kappa) -> \kappa$ for each kind $\kappa$.
The $\mu$, which we discussed abive, is $\mu_{*} : (* -> *) -> *$.
We can construct \textit{Powl}, which is a non-regular datatype, using another
recursive typer operator $\mu_{* -> *} : ((*-> *) -> (*-> *)) -> (*-> *) $
as follows (\cf\ \textit{List}).
\begin{align*}
\textit{Powl} &= \mu_{* -> *}(\l X^{* -> *}.\l X_a^{*}.
			(X_a\times X(X_a\times X_a)) + \textit{Unit}) \\
\textit{List} &= \l X_a^{*}.\mu_{*}(\l X^{*}.(X_a\times X) + \textit{Unit})
\end{align*}
Note the difference where $X_a$ is bound in the defintions of \textit{Powl}
and \textit{List}. The encodings of $\mu_{*}$ and $\mu_{*-> *}$ in System \Fw\ 
are shown below:
\begin{align*}
\mu_{*} &=
 \l X_{\!f}^{* -> *}.\forall X'^{*}.
 (\forall X_r^{*}.(X_r -> X') -> (X_{\!f}\,X_r -> X')) -> X' \\
\mu_{* -> *} &=
 \l X_{\!f}^{(*-> *) -> (*-> *)}.\l X_a^{*}.\\&\qquad\quad \forall X'^{*-> *}.
 \big(\forall X_r^{*-> *}.
 	(\forall X_a^{*}.X_r\,X_a -> X'\,X_a) -> \\&\qquad\qquad\qquad\qquad\qquad~
	(\forall X_a^{*}.X_{\!f}\,X_r\,X_a -> X'\,X_a)\big) -> X'\,X_a
\end{align*}
The genreal form for the encoding of $\mu_\kappa$
is as follows:
\begin{align*}
\mu_{\kappa} &=
 \l X_{\!f}^{\kappa -> \kappa}.\l \vec{X}^{\vec{\kappa}}.
 \forall X'^{*-> *}.
 \big(\forall X_r^{\kappa -> \kappa}.
 (\forall \vec{X}^{\vec{\kappa}}.X_r\,\vec{X} -> X'\,\vec{X}) -> \\
 &\qquad\qquad\qquad\qquad\qquad\qquad\qquad\quad
 (\forall \vec{X}^{\vec{\kappa}}.X_{\!f}\,X_r\,\vec{X} -> X'\,\vec{X})
 \big) -> X'\,\vec{X}
\end{align*}
where $\vec{X}$ denotes a sequence of $n$ variables
such that $n=0$ when $\kappa = *$, otherwise, $n = |\vec{\kappa}|$ when
$\kappa = \vec{\kappa} -> * = \kappa_1 -> \cdots -> \kappa_n -> *$.\footnote{
	$\kappa$ always end up with $*$ when it is an arrow kind
	since $->$ is right associative by convention.}
That is, we can simply erase all the $\l \vec{X}^{\vec{\kappa}}$,
$\forall \vec{X}^{\vec{\kappa}}$, and $\vec{X}$ from above when
$\kappa = *$, otherwise, $\l \vec{X}^{\vec{\kappa}}$ stands for
$\l X_1^{\kappa_1}.\cdots.\l X_n^{\kappa_n}$,
$\forall \vec{X}^{\vec{\kappa}}$ stands for
$\forall X_1^{\kappa_1}.\cdots.\forall X_n^{\kappa_n}$,
and $F\,\vec{X}$ stands for $F\,X_1\cdots X_n$
when $\kappa = \vec{\kappa} -> * = \kappa_1 -> \cdots -> \kappa_n -> *$.

The (data) constructor for the reucrisve type operator $\mu_\kappa$ is
called $\In_\kappa$ and the eliminator is called $\MIt_\kappa$.
The encodings of $\In_\kappa$ and $\MIt_\kappa$ as Curry-style terms are
exactly the same as for $\In$ and $\MIt$ for the star kind:
\[ \In_\kappa = \l x_r. \l x_\varphi.x_\varphi\,(\MIt~x_\varphi)\,x_r
\qquad\qquad \MIt_\kappa = \l x_\varphi.\l x_r.x_r\,x_\varphi \]
These ($\mu_\kappa$, $\In_\kappa$, and $\MIt_\kappa$) are, in fact,
encodings for Mendler-style iteration in \Fw, which will discussed in
Chapter \ref{ch:mendler}. %% TODO update the fwd ref to a section later



\subsection{Subject reduction and strong normalization}\label{sec:fw:srsn}
We discuss two important properties of System \Fw\ --
\emph{subject reduction} (\aka\ \emph{type preservation})
and \emph{strong normalization}.

\subsection*{Subject reduction}
\begin{theorem}[subject reduction]
$\inference{\Delta;\Gamma |- t : A  & t --> t'}{\Delta;\Gamma |- t' : A}$
\end{theorem}


\subsection*{Strong normalization}
\begin{figure}
\begin{singlespace}
\begin{description}
\item[Interpretation of kinds] as pointwise generalization of $\SAT$
	\[ [| \kappa |] = \SAT_\kappa \]
\item[Interpretation of type constructors]
	as function spaces over saturated sets of normalizing terms
	whose free type variables are substituted according to
	the given type constructor valuation ($\xi$):
\begin{align*}
[| X |]_\xi      &= \xi(X) \\ 
[| A -> B |]_\xi &= [|A|]_\xi -> [|B|]_\xi \\
[| \forall X^\kappa . B |]_\xi
	&= \bigcap_{\mathcal{F}\in[|\kappa|]} [|B|]_{\xi[X\mapsto\mathcal{F}]}
		\qquad\qquad\qquad (X\notin\dom(\xi)) \\
[| \l X^\kappa . F |]_\xi
	&= \bbl(\mathcal{G} \in [|\kappa|]) . [|F|]_{\xi[X\mapsto\mathcal{G}]}
		\qquad\quad~ (X\notin\dom(\xi)) \\
[| F \; G |]_\xi &= [|F|]_\xi ( [|G|]_\xi )
\end{align*}
\item[Interpretation of kinding and typing contexts]
	as sets of type constructor valuations and term valuations
	($\xi$ and $\rho$):
\begin{align*}
[| \Delta        |] &= \{ \xi \in \dom(\Delta) -> \bigcup_{\kappa} [|\kappa|] \mid \xi(x)\in[|\Delta(x)|] ~\text{for all}~x\in\dom(\Delta) \} \\
[| \Delta;\Gamma |] &= \{ \xi;\rho \mid \xi\in[|\Delta|], \rho\in[|\Gamma|]_\xi \} \\
[| \Gamma        |]_\xi\ &= \{ \rho \in \dom(\Gamma) -> \SN \mid \rho(x)=[|\Gamma(x)|]_\xi ~\text{for all}~x\in\dom(\Gamma) \}
\end{align*}
\item[Interpretation of terms]
	as terms themselves whose free variables are substituted according to
	the given pair of type constructor and term valuations
	($\xi$;$\rho$):
\begin{align*}
[| x      |]_{\xi;\rho} &= \rho(x) \\
[| \l x.t |]_{\xi;\rho} &= \l x . [|t|]_{\xi;\rho} \qquad (x\notin\dom(\rho)) \\
[| t ~ s  |]_{\xi;\rho} &= [| t |]_{\xi;\rho} ~ [| s |]_{\xi;\rho}
\end{align*}
\end{description}
\caption[Interpretation of System \Fw\ for proving strong normalization]
	{Interpretation of type constructors, kinding and typing contexts,
		and terms of System \Fw\ for the proof of strong normalization}
\label{fig:interpFw}
\end{singlespace}
\end{figure}
For the proof of strong normalization of System \Fw, we use the same strategy
of interpreting types as saturated sets of normalizing terms as we did for
System \F. However, we need to generalize the interpretation of types to
the interpretation of type constructors. In the strong normalization proof
of System \F, we had a complete lattice $(\SAT,\subseteq)$.
We generalize this to an arbitrary kind $\kappa$ such that
$(\SAT_\kappa,\sqsubseteq_\kappa)$ from a complete lattice for any $\kappa$.
The set $\SAT_\kappa$ are generalization of $\SAT$ such that $\SAT_{*}=\SAT$
and $\SAT_{\kappa -> \kappa'} = \SAT_\kappa -> \SAT_{\kappa'}$
(\ie, functions from $\SAT_\kappa$ to $\SAT_\kappa'$).
The relation $\sqsubseteq_\kappa$ is a pointwise generalization of $\subseteq$
such that
\begin{align*}
\mathcal{A} \sqsubseteq_{*} \mathcal{A'} &= \mathcal{A} \subseteq \mathcal{A'}\\
\mathcal{F} \sqsubseteq_{\kappa -> \kappa'} \mathcal{F'} &=
	\mathcal{F}(\mathcal{G}) \sqsubseteq_{\kappa'} \mathcal{F'}(\mathcal{G})
	~\text{for all}~\mathcal{G}\in\SAT_\kappa
\end{align*}
Then, we can give interpretation of kind $\kappa$ as $\SAT_\kappa$.
That is, $[| \kappa |] = \SAT_\kappa$.
The interpretation of kinds, type constructors, contexts, and
terms of System \Fw\ are illustrated in Figure \ref{fig:interpFw}. 

We use the Curry-Church-style System \Fw\ to present the strong normalization
proof. It is more convenient to interpret terms in Curry style since
the Curry-style terms syntax is simpler than the Church-style term syntax.
It is more convenient to interpret type constructors in Curry style since
the kind annotation makes it clear how to interpret the bound type variable $X$
in forall types and lambda types (\ie, for $X^\kappa$ choose from $[|\kappa|]$).

The proof of strong normalization amounts to proving the following theorem:
\begin{theorem}[soundness of typing]
$ \inference{\Delta;\Gamma|- t:A & \xi;\rho \in [|\Delta;\Gamma|]}
	    {[|t|]_{\xi;\rho} \in [|A|]_\xi} $
\end{theorem}
\begin{proof}
We prove by induction on the typing derivation ($\Delta;\Gamma |- t:A$).

The cases for \rulename{Var}, \rulename{Abs}, and \rulename{App} are pretty
much the same as the strong normalization proof for System \F.
The cases for \rulename{TyAbs} and \rulename{TyApp} is almost the same
as the strong normalization proof for System \F, except that the type variable
can be of some kind $\kappa$ other than just the star kind.
We need to consider one more rule \rulename{Conv}, which is new in System \Fw.
Let us elaboreate on the three cases of
\rulename{TyAbs} and \rulename{TyApp}, and \rulename{Conv}.

\paragraph{Case (\rulename{TyAbs})}
We need to show that
$ \inference{\Delta;\Gamma |- t : \forall X.B & \xi;\rho\in[|\Delta;\Gamma|]}
	{[|t|]_{\xi;\rho} \in [|\forall X^\kappa.B|]_\xi} $

By induction, we know that
\[ \inference{\Delta,X^\kappa;\Gamma |- t:B & \xi';\rho'\in[|\Delta,X;\Gamma|]}
	{[|t|]_{\xi';\rho'} \in [|B|]_{\xi'}} ~
	(X\notin\FV(\Gamma))
\]
Since this holds for all $\xi';\rho' \in [|\Delta,X^\kappa;\Gamma|]$ where
$X\notin\FV(\Gamma)$, it also holds for particular subset such that
$\xi' = \xi[X\mapsto\mathcal{F}]$ and $\rho'=\rho$ for all $\mathcal{F}\in[|\kappa|]$.
That is,
\[ [|t|]_{\xi[X\mapsto\mathcal{F}];\rho} \in [|B|]_{\xi[X\mapsto\mathcal{F}]}
	\quad \text{for all}~\mathcal{F}\in[|\kappa|] \]
From $X\notin\FV(\Gamma)$, we know that
$[|t|]_{\xi[X\mapsto\mathcal{F}];\rho} = [|t|]_{\xi;\rho}$
because $\rho$ is independent of what $X$ maps to.
So, we know that
\[ [|t|]_{\xi;\rho} \in [|B|]_{\xi[X\mapsto\mathcal{F}]}
	\quad \text{for all}~\mathcal{F}\in[|\kappa|] \]
By set theoretic definition, this is exactly what we wanted to show:
\[ [|t|]_{\xi;\rho} \in
	\bigcap_{\mathcal{F}\in[|\kappa|]} [|B|]_{\xi[X\mapsto\mathcal{F}]}
	= [|\forall X^\kappa.B|]_\xi
\]

\paragraph{Case (\rulename{TyApp})}
We need to show that
$ \inference{\Delta;\Gamma |- t : B[G/X] & \xi;\rho\in[|\Delta;\Gamma|]}
	{[|t|]_{\xi;\rho} \in [|B[G/X]|]_\xi} $.

By induction, we know that
$ \inference
	{ \Delta;\Gamma |- t : \forall X^\kappa.B
	& \xi';\rho'\in[|\Delta;\Gamma|] }
	{[|t|]_{\xi';\rho'} \in [|\forall X^\kappa.B|]_{\xi'}} $.

Since this holds for all $\xi';\rho' \in [|\Delta,\Gamma|]$,
it also holds for $\xi'=\xi$ and $\rho'=\rho$. Then, we are done:
$ [|t|]_{\xi;\rho} \in [|\forall X^\kappa.B|]_{\xi}
	= \bigcap_{\mathcal{G}\in[|\kappa|]} [|B|]_{\xi[X\mapsto\mathcal{G}]}
	\subseteq [|B|]_{\xi[X\mapsto[|G|]_\xi]} = [|B[G/X]|]_\xi $.

\paragraph{Case (\rulename{Conv})}
We need to show that
$ \inference{\Delta;\Gamma |- t : A' & \xi;\rho\in[|\Delta;\Gamma|]}
	{[|t|]_{\xi;\rho} \in [|A'|]_\xi} $

By induction we know that 
$ \inference{\Delta;\Gamma |- t : A & \xi;\rho\in[|\Delta;\Gamma|]}
	{[|t|]_{\xi;\rho} \in [|A|]_\xi} $

If we can show that $[|A|]_\xi = [|A'|]_\xi$, we are done.

To show that $[|A|]_\xi = [|A'|]_\xi$,
we use the soundness of type constructor equality lemma
(Lemma \ref{lem:fw:soundtyeq}).
\end{proof}

\begin{corollary}[strong normalization]
	$\inference{\Delta;\Gamma |- t : A}{t \in \SN}$
\end{corollary}

\begin{lemma}[soundness of type equality] \label{lem:fw:soundtyeq}
$ \inference{\Delta |- F = F' : \kappa & \xi\in[|\Delta|]}
	{[|F|]_\xi = [|F'|]_\xi} $
\end{lemma}
\begin{proof}
The only interesting case is the \rulename{EqTBeta} rule.
The \rulename{EqTVar} is trivial and all other rules are handled by induction.
Let us elaborate on the \rulename{EqTBeta} case.

\paragraph{Case (\rulename{EqTBeta})} We need to show that
\[ \inference
	{ \Delta |- (\l X^\kappa.F)\;G = F[G/X] : \kappa' & \xi\in[|\Delta|] }
	{ [| (\l X^\kappa.F)\;G |]_\xi = [| F[G/X] |]_\xi }
\]

By applying the soundness of kinding lemma (Lemma \ref{lem:fw:soundki})
to the premises, we know that
\[ \inference
	{\Delta,X^\kappa |- F : \kappa -> \kappa' & \xi'\in[|\Delta,X^\kappa|]}
	{[|F|]_{\xi'} \in [|\kappa'|]}
\quad\text{and}\quad
   \inference{\Delta |- G : \kappa & \xi\in[|\Delta|]}{[|G|]_\xi \in [|\kappa|]}
\]

Since it should hold for arbitrary $\xi'$, it should also hold for
a particular $\xi'$ such that $\xi'=\xi[X\mapsto\mathcal{G}]$
for any $\mathcal{G} \in [|\kappa|]$. Therefore, we can rewrite
the left-hand side of the conclusion, which what we wanted to show,
into the right-hand side as follows:
\begin{align*}
[| (\l X^\kappa.F)\;G |]_\xi
&=[|(\l X^\kappa.F)|]_\xi ([|G|]_\xi) \\
&=(\bbl(\mathcal{G}\in[|\kappa|]).[|F|]_{\xi[X\mapsto\mathcal{G}]})([|G|]_\xi)\\
&=[|F|]_{\xi[X\mapsto[|G|]_\xi]} \\
&=[|F[G/X]|]_\xi
\end{align*}
\end{proof}

System \Fw\ has a richer kind structure than System \F, which only has one and
the only the star kind. So, the interpretation of type constructors would only
be well-defined when the type constructors are well-kinded. For example,
the interpretation of a type constructor application $[|F~G|]_\xi$
would only make sense when $[|F|]_\xi\in[|\kappa -> \kappa'|]$
and $[|G|]_\xi\in[|\kappa|]$ for some $\kappa$ and $\kappa'$.
The soundness of kinding lemma below states the property that
well-kinded type constructors indeed have well-defined interpretation.
\begin{lemma}[soundness of kinding]  \label{lem:fw:soundki}
$ \inference{\Delta |- F : \kappa & \xi\in[|\Delta|]}{[|F|]_\xi\in[|\kappa|]} $
\end{lemma}
\begin{proof}
We prove by induction on the kinding judgment.
\paragraph{Case (\rulename{TVar})}
Straightforward by definition of $[|\Delta|]$.

$[|X|]_\xi=\xi(X) \in [|\kappa|]$
since $\xi(X)\in[|\kappa|]$ for any $\xi\in[|\Delta|]$
when $X^\kappa \in [|\Delta|]$.

\paragraph{Case (\rulename{TArr})} By induction, straightforward.

\paragraph{Case (\rulename{TAll})}
We need to show that
$ \inference{\Delta |- \forall X^\kappa.B:* & \xi\in[|\Delta|]}
	{[|\forall X^\kappa.B|]_\xi\in[|*|]} $.

By induction, we know that
$ \inference{\Delta,X^\kappa |- B:* & \xi'\in[|\Delta,X^\kappa|]}
	{[|B|]_{\xi'} \in [|*|]} $.

Since it should hold for any $\xi'$, it also holds for
$\xi'=\xi[X\mapsto\mathcal{G}]$ for any $\mathcal{G}\in[|\kappa|]$.

Therefore,
$  [|\forall X^\kappa.B|]_\xi
 = \bigcap_{\mathcal{G}\in[|\kappa|]}[|B|]_{\xi[X\mapsto\mathcal{G}]}\in[|*|] $.

\paragraph{Case (\rulename{TLam})}
We need to show that
$ \inference{\Delta |- \l X^\kappa.B:* & \xi\in[|\Delta|]}
	{[|\forall X.B|]_\xi\in[|*|]} $.

By induction, we know that 
$ \inference{\Delta,X^\kappa |- F:\kappa' & \xi'\in[|\Delta,X^\kappa|]}
	{[|F|]_{\xi'} \in [|\kappa'|]} $.

Since it should hold for any $\xi$, it also holds for
$\xi'=\xi[X\mapsto\mathcal{G}]$ for any $\mathcal{G}\in[|\kappa|]$.

Therefore,
$  [|\l X^\kappa.F|]_\xi
 = \bbl(\mathcal{G}\in[|\kappa|]).[|F|]_{\xi[X\mapsto\mathcal{G}]}
 	\in [|\kappa -> \kappa'|]$.

\paragraph{Case (\rulename{TApp})} By induction, straightforward.
\end{proof}

