%This is a template for producing LIPIcs articles.
%See lipics-manual.pdf for further information.

\documentclass[a4paper,UKenglish]{lipics}
  %for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
  %for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
 % for section-numbered lemmas etc., use "numberwithinsect"
 
\usepackage{microtype}%if unwanted, comment out or use option "draft"

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plain}% the recommended bibstyle

% Author macros %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{Mendler-style Recursion Schemes for Mixed-Variant Datatypes\footnote{
	This work was partially supported by someone.} }
%% \titlerunning{A Sample LIPIcs Article} %optional, in case that the title is too long; the running title should fit into the top page column

\author[1]{Ki Yung Ahn}
\author[1]{Tim Sheard}
\author[2]{Marcelo Fiore}
\affil[1]{Department of Computer Science, Portland State University\\
  Oregon, USA\\
  \texttt{\{kya,sheard\}@cs.pdx.edu}}
\affil[2]{Computer Laboratory, University of Cambridge\\
  Cambridge, UK\\
  \texttt{Marcelo.Fiore@cl.cam.ac.uk}}
\authorrunning{KY. Ahn, T. Sheard and M. Fiore} %mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et. al.'

\Copyright{Ki Yung Ahn, Tim Sheard and Marcelo Fiore}%mandatory. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\subjclass{
D.3.3 [Programming Languages]: Language Constructs and Features
--- Data types and structures, Polymorphism, and Recursion;
F.3.3 [Logics and Meanings of Programs]: Studies of Program Constructs
-- Functional constructs, Program and recursion schemes, and Type structure;
F.4.1 [Mahtematical Logic and Formal Systems]: Mathematical Logic
--- Lambda calculus and related systems
}
\keywords{
Mendler-style recursion, Higher-Order Abstract Syntax (HOAS),
mixed-variant datatypes, negative datatypes, termination}
% mandatory: Please provide 1-5 keywords
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Editor-only macros (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\serieslogo{}%please provide filename (without suffix)
\volumeinfo%(easychair interface)
  {Billy Editor, Bill Editors}% editors
  {2}% number of editors: 1, 2, ....
  {Conference title on which this volume is based on}% event
  {1}% volume
  {1}% issue
  {1}% starting page number
\EventShortName{}
\DOI{10.4230/LIPIcs.xxx.yyy.p}% to be completed by the volume editor
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\cf}[0]{{cf.}}
\newcommand{\eg}[0]{{e.g.}}
\newcommand{\ie}[0]{{i.e.}}
\newcommand{\aka}[0]{{a.k.a.}}

\newcommand{\F}[0]{{\ensuremath{\mathsf{\uppercase{F}}}}}
\newcommand{\Fw}[0]{{\ensuremath{\mathsf{\uppercase{F}}_{\!\omega}}}}
\newcommand{\Fixw}[0]{{\ensuremath{\mathsf{\uppercase{F}\lowercase{ix}}_{\omega}}}}
\newcommand{\Fwhat}[0]{{\ensuremath{\mathsf{\uppercase{F}}_{\!\omega}\!\!\char`\^}}}

\newcommand{\MIt}[1]{\ensuremath{\textbf{\textit{mit}}_{#1}}}
\newcommand{\MPr}[1]{\ensuremath{\textbf{\textit{mpr}}_{#1}}}
\newcommand{\mpr}[1]{\ensuremath{\textbf{\textit{mpr}}_{#1}}}
\newcommand{\MsfIt}[1]{\ensuremath{\textbf{\textit{msfit}}_{#1}}}
\newcommand{\msfit}[1]{\ensuremath{\textbf{\textit{msfit}}_{#1}}}
\newcommand{\mprsi}[1]{\ensuremath{\textbf{\textit{mprsi}}_{#1}}}
\newcommand{\lift}[0]{\textit{lift}}
\newcommand{\In}[1]{\textit{In}_{#1}}
\newcommand{\inL}[0]{\textit{in}_{L}}
\newcommand{\inR}[0]{\textit{in}_{R}}

%% \setlength{\thickmuskip}{0mu}
%% \setlength{\medmuskip}{0mu}
%% \setlength{\thinmuskip}{0mu}
\lstset{captionpos=t,
	float,
	keepspaces=false,
	abovecaptionskip=-\medskipamount,
	language=Haskell,
 	basicstyle=\rmfamily\it,
 	keywordstyle=\rm\bfseries,
	commentstyle=\color{blue},
	stringstyle=\rm\ttfamily,
	deletekeywords={Bool,Int,Integer,String,show,const,id},
 	literate=
 		{forall}{{$\forall$}}1
 		{:}{{$:$}}1
 		{::}{{$::$}}1
 		{->}{{$\to$}}2
 		{=}{{$=$}}1
 		{=>}{{$\Rightarrow$}}2
 		{*}{{$*$}}1
 		{\\}{{$\lambda$}}1
		{Phi0}{{Phi$_{*}$}}3
		{Phi1}{{Phi$_{*\to*}$}}5
		{Phi0'}{{Phi$_{*}^{\phantom{.}\prime}$}}3
		{Phi1'}{{Phi$_{*\to*}^{\phantom{.}\prime}$}}5
		{Mu0}{{$\mu_{*}$}}1
		{In0}{{In$_{*}$}}2
		{out0}{{out$_{*}$}}3
		{Mu1}{{$\mu_{*\to*}$}}3
		{In1}{{In$_{*\to*}$}}4
		{out1}{{out$_{*\to*}$}}5
		{Rec0}{{$\mu_{*}^\prime$}}1
		{Roll0}{{In$_{*}^\prime$}}2
		{Inverse0}{{Inverse$_{*}$}}6
		{Rec1}{{$\mu_{*\to*}^\prime$}}3
		{Roll1}{{In$_{*\to*}^\prime$}}4
		{Inverse1}{{Inverse$_{*\to*}$}}8
 		{phi}{{$\varphi$}}1
 		{t1}{{$t_1$}}1
 		{t1}{{$t_1$}}1
 		{t2}{{$t_2$}}1
 		{e1}{{$e_1$}}1
 		{e2}{{$e_2$}}1
		{mpr}{{mpr}}3
		{mpr1}{{mpr$_{* \to *}$}}6
		{mprim}{{\mpr{}}}3
		{mprim1}{{\mpr{* \to *}}}6
		{mprsi}{{\mprsi{}}}5
		{mprsi1}{{\mprsi{* \to *}}}7
		{uncast}{{uncast}}6
		{cast}{{cast}}4
		{call}{{call}}4
		{unVal}{{un\!Val}}4
		{mcata}{{mit}}3
		{mcata0}{{\MIt{*}}}3
		{mcata1}{{\MIt{* \to *}}}5
		{msfcata}{{\msfit{}}}5
		{msfcata0}{{\msfit{*}}}5
		{msfcata1}{{\msfit{* \to *}}}7
		{++}{{$+\!\!\!\!+$}}2
 		{+}{{$+$}}1
 		{(}{{$($}}1
 		{)}{{$)$}}1
 		{[}{{$[$}}1
 		{]}{{$]$}}1
 		{\{}{{$\{$}}1
 		{\}}{{$\}$}}1
 		{|}{{$\mid$}}1
		{Exp}{{Exp}}3
		{Exp_u}{{Exp$_u$}}3
		{ExpF}{{ExpF}}4
		{ExpF_u}{{ExpF$_u$}}4
		{App_u}{{App$_u$}}4
		{Lam_u}{{Lam$_u$}}4
		{V_u}{{V\!$_u$}}1
		{VFun_u}{{VFun$_u$}}4
		{Exp'}{{Exp$\,^\prime$}}3
		{show'}{{show$\,^\prime$}}4
		{showExp}{{showExp}}7
		{const}{const}4
		{String}{String}5
		{Bool}{{Bool}}4
		{Int}{{Int}}3
		{inv}{{inv}}3
		{ev}{{ev}}2
		{eval}{{eval}}4
		{veval}{{eval}}4
		{vs}{{vs}}2
		{vars}{{vars}}3
		{lam}{{lam}}3
		{app}{{app}}3
		{unId}{{unId}}4
		{exp2expr}{{exp2expr}}7
		{p2r}{{p2r}}2
}


\begin{document}

\maketitle

\begin{abstract}
Some concepts, such as like Higher-Order Abstract Syntax (HOAS),
are most naturally expressed by \emph{mixed-variant datatypes}
(\aka\ negative (recursive) datatypes). Unfortunately,
mixed-variant datatypes are often outlawed in formal reasoning systems
based on the Curry--Howard correspondence (\eg, Coq, Agda), because
the conventional recursion schemes (or, induction principles) supported in
such systems cannot guarantee termination for mixed-variant datatypes.

There is an alternative style of formulating recursion schemes,
known as the Mendler style, that can guarantee termination for
arbitrary datatypes. Ahn and Sheard \cite{AhnShe11} formulated
a Mendler-style recursion scheme (\msfit{}), and demonstrated
examples involving regular (\ie, non-indexed) mixed-variant datatypes
(\eg, untyped $\lambda$-calculus in HOAS). Their examples demonstrate
the advantage of the Mender style -- termination guarantee for
arbitrary datatypes, including mixed-variant ones. They proved
termination of the examples via embedding into System~\Fw.

Another advantage of the Mendler style is that recursion schemes
naturally extends to non-regular (\ie, indexed) datatypes.
Our type-preserving evaluator example for the simply-typed HOAS, defined as
a type-indexed mixed-variant datatype, demonstrates both advantages of
the Mendler style. This example has its own theoretical value, which is
a novel discovery that the simply-typed HOAS evaluation is expressible
within System \Fw. To our knowledge, this is the first report of
a simply-typed HOAS evaluator (without translation through first-order syntax)
that is equipped with correct-by-construction proofs
(in the Curry--Howard sense) of both type-preservation and normalization.
We also develop further theoretical discussions on the \Fw-embedding of \msfit{}
and propose yet another recursion scheme (\mprsi{}), which is also useful for
mixed-variant datatypes.

Our study promotes the usefulness of the recursion schemes,
which are useful over mixed-variant datatypes. We hope our
work motivates designing logical reasoning systems that support
wider range of datatypes including mixed-variant ones.
\end{abstract}

\section{TODO intro}
\begin{enumerate}
	\item discuss the advantages of the Mendler style,
	\item report that we can define an evaluator for the simply-typed HOAS
		using Mendler-style iteration with syntactic inverses
		(\lstinline{msfcata}), and
	\item propose a new recursion scheme (work in progress) whose
		termination relies on the invariants specified by
		size measures on indices.
\end{enumerate}



Advantages of the Mendler style include allowing arbitrary definitions of
recursive datatypes, while still ensuring well-behaved use by providing
a rich set of principled eliminators (\ie, recursion schemes).
Certain concepts, such as HOAS, are most succinctly defined as
mixed-variant datatypes, which are unfortunately, outlawed in many existing
reasoning systems (\eg, Coq, Agda). One is forced to devise clever encodings
(\eg, \cite{PHOAS}) to use concepts like HOAS within such systems.

We believe it is worthwhile to allow the definition all recursive datatypes
available in functional \emph{programming} languages, including those outlawed
in many reasoning systems. For example, the untyped $\lambda$-calculus can be
defined in HOAS as an Haskell dataype (\lstinline{Exp}):
\begin{lstlisting}
data Exp = Lam (Exp -> Exp) | App Exp Exp
\end{lstlisting}
Even if we assume all functions embedded in \lstinline{Lam} are non-recursive,
evaluating HOAS may still cause problems for logical reasoning, since
the untyped $\lambda$-calculus has diverging terms. However, there are many
well-behaved (\ie, terminating) computations over \lstinline{Exp}, such as
converting an HOAS expression to first-order syntax.
Ahn and Sheard \cite{AhnShe11} formalized a Mendler-style recursion scheme,
\lstinline{msfcata}  (\aka\ \textit{msfcata}), which captures these
well-behaved computations.

If the datatype \lstinline{Exp} had indices to assert invariants of
well-typed expressions (\eg, \lstinline{Exp Bool}\, for boolean expressions
and \lstinline{Exp Int}\, for integer expressions), we could rely on these
invariants to write even more expressive termiating programs, such as
a type-preserving evaluator. In Section\;\ref{sec:HOASeval}, we report
our novel discovery that we can define a type-preserving evaluator for
a simply-typed HOAS using \lstinline{msfcata}.

TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO

TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO

TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO


\section{Mendler-style recursion schemes}

In this section, we introduce basic concepts of two Mendler-style recursion
schemes: iteration (\lstinline{mcata}\,) and iteration with syntactic inverses
(\lstinline{msfcata}\,). Further details on Mendler-style recursion schemes,
including these two and more, can be found in \cite{AhnShe11} TODO TODO
more citations TODO.

\begin{lstlisting}[caption={TODO}]
data Mu0   (f::(* -> *))               = In0   {out0  ::f (Mu0   f)  }
data Mu1 (f::(* -> *) -> (* -> *)) i = In1 {out1::f (Mu1 f) i}
                                                              
data Rec0   f a   = Roll0   {unRoll0   :: f (Rec0 f a)    } | Inverse0   a
data Rec1 f a i = Roll1 {unRoll1 :: f (Rec1 f a) i} | Inverse1 (a i)
\end{lstlisting}

\begin{figure}
\begin{lstlisting}[caption={TODO \label{lst:reccomb}}]
type Phi0   f a = forall r . (    r   -> a  ) -> (f r   -> a  )
type Phi1 f a = forall r i.(forall i.r i -> a i) -> (f r i -> a i)

mcata0   :: Phi0   f a ->  Mu0  f    -> a
mcata1 :: Phi1 f a ->  Mu1 f i -> a i

type Phi0'   f a = forall r . (     a  -> r a  ) ->
                       (     r a  -> a  ) -> (f (r a)   -> a  )
type Phi1' f a = forall r i.(forall i.a i -> r a i) ->
                       (forall i.r a i -> a i) -> (f (r a) i -> a i)

msfcata0   :: Phi0'   f a -> (forall a. Rec0   f a  ) -> a
msfcata1 :: Phi1' f a -> (forall a. Rec1 f a i) -> a i
\end{lstlisting}
\vspace*{-3ex}
\end{figure}

\begin{figure}
\lstinputlisting[
	caption={Formatting an untyped HOAS expression into a \lstinline{String}
		\label{lst:HOASshow}},
	firstline=5]{HOASshow.hs}
\vspace*{-3ex}
\end{figure}

\section{TODO HOAS TODO}\label{sec:HOASeval}
We can write an evaluator for a simply-typed HOAS
in a simple manner. Listing\;\ref{lst:HOASeval}
is a Haskell program illustrating the technique.

We first define the simply-typed HOAS as a recursive indexed datatype
\lstinline{Exp :: * -> *}. We take the fixpoint using \lstinline{Rec1}
(the fixpoint with a syntactic inverse). This fixpoint is taken over
a non recursive base structure \lstinline{ExpF ::  (* -> *) -> (* -> *)}.
Note that \lstinline{ExpF} is an indexed type. So expressions will be indexed
by their type. Using \lstinline{Rec1} the fixpoint of any structure is also
parameterized by the type of the answer. The use of the \lstinline{msfcata1}
requires that \lstinline{Exp} should be parametric in this answer type
(by defining \lstinline{type Exp t = forall a. Exp' a}). just as we did
in the untyped HOAS formatting example in Listing\;\ref{lst:HOASshow}.

\begin{figure}
\lstinputlisting[
	caption={Simply-typed HOAS evaluation using \lstinline{msfcata1}
		\label{lst:HOASeval}},
        firstline=4]{HOASeval.hs}
\vspace*{-3ex}
\end{figure}
%% Using general recursion, one would have defined
%% the datatype |Exp_g :: * -> *| that corresponds to |Exp|
%% as follows, using Haskell's native recursive datatype definition.
%% \begin{code}
%% data Exp_g t where
%%   Lam_g :: (Exp_g a -> Exp_g b) -> Exp_g (a -> b)
%%   App_g :: Exp_g (a -> b) -> Exp_g a -> Exp_g b
%% \end{code}

The definition of \lstinline{eval} specifies how to evaluate
an HOAS expression to a host-language value (\ie, Haskell) wrapped by
the identity type (\lstinline{Id}\,). In the description below, we ignore
the wrapping (\lstinline{MkId}\,) and unwrapping (\lstinline{unId}\,) of
\lstinline{Id} by completely dropping them from the description.
See the Listing\;\ref{lst:HOASeval} (where they are not omitted)
if you care about these details. We discuss the evaluation for each of
the constructors of \lstinline{Exp}:
\begin{itemize}
	\item Evaluating an HOAS abstraction (\lstinline{Lam f}\,) lifts
		an object-language function \lstinline{(f)} over \lstinline{Exp}
		into a host-language function over values:
		\lstinline{(\v -> ev (f(inv v)))}.
		In the body of this host-language lambda abstraction,
		the inverse of the (host-language) argument value \lstinline{v}
		is passed to the object-language function \lstinline{f}.
		The resulting HOAS expression \lstinline{(f(inv v))} is
		evaluated by the recursive caller (\lstinline{ev}) to
		obtain a host-language value.

	\item Evaluating an HOAS application \lstinline{(App f x)} lifts
		the function \lstinline{f} and argument \lstinline{x} to
		host-language values \lstinline{(ev f}) and \lstinline{(ev x)},
		and uses host-language application to compute
		the resulting value. Note that the host-language application
		\lstinline{((ev f) (ev x))} is type correct since
		\lstinline{ev f :: a -> b}\, and \lstinline{ev x :: a},
		thus the resulting value has type \lstinline{b}.
\end{itemize}
We know that \lstinline{eval} indeed terminates since \lstinline{Rec1} and
\lstinline{msfcata1} can be embedded into System \Fw\ in manner similar to
the embedding of \lstinline{Rec0} and \lstinline{msfcata0} into System \Fw.

Listing\;\ref{lst:HOASeval} highlights two advantages of the Mendler style over
conventional style in one example. This example shows that the Mendler-style
iteration with syntactic inverses is useful for both \textit{negative} and
\textit{indexed} datatypes. \lstinline{Exp} in Listing\;\ref{lst:HOASeval} has
both negative recursive occurrences and type indices.

The \lstinline{showExp} example in Listing\;\ref{lst:HOASshow},
which we discussed in the previous section, has appeared in the work
of Fegaras and Sheard \cite{FegShe96}, written in conventional style.
So, the \lstinline{showExp} example, only shows that the Mendler style is
as expressive as the conventional style (although it is
perhaps syntactically more pleasant than the conventional style).
However, it is not obvious how one could extend the conventional-style
counterpart over indexed datatypes.

In contrast, \lstinline{msfcata} is uniformly defined over indexed datatypes of
arbitrary kinds. Both \lstinline{msfcata1}, used in the \lstinline{eval},
and \lstinline{msfcata0}, used in the \lstinline{showExp}, have exactly
the same syntatctic definition, differing only in their type signatures,
as lillustrated in Listing\;\ref{lst:reccomb}.

\section{Relation between $\mu$ and $\mu'$}
Listing\;\ref{lst:rec2mu} illustrates a mapping from
\lstinline{(forall a. Rec0 E a)}  to \lstinline{(Mu0 E)} implemented
using \lstinline{msfcata0}, where \lstinline{E} is a base structure
for the untyped HOAS. Since we have two fixpoint type operators,
\lstinline{Rec0} and \lstinline{Mu0}, we can define two recursive datatypes
from the base structure \lstinline{E}\,:
\lstinline{Exp} defined as \lstinline{(forall a. Rec0 E a)} and
\lstinline{Expr} defined as \lstinline{Mu0 E}.
The function \lstinline{exp2expr :: Exp -> Expr}\, implements the mapping from
\lstinline{Rec0}-based HOAS expressions to \lstinline{Mu0}-based
HOAS expressions. Note, \lstinline{exp2expr}\, is defined
using \lstinline{msfcata0}.  Since there exists an embedding of
\lstinline{Mu0} and \lstinline{msfcata0} into System~\Fw\ \cite{AhnShe11},
\lstinline{exp2expr}\, is admissible in System \Fw.


This indicates that the mapping
from \lstinline{(forall a. Rec0 f a)} to (\lstinline{Mu0 f}\,) is admissible
within System~\Fw.


TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO


\begin{figure}
\lstinputlisting[
	caption={Conversion from $\mu'$-values to $\mu$-values
		using \textit{msfcata} \label{lst:rec2mu} },
	firstline=4]{Exp2Expr.hs}
\vspace*{-3ex}
\end{figure}

TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO



\section{TODO Theory ??? codensity monad}
\begin{align*}
\mu_{*} &~=~ \lambda F^{* \to *}.\forall X^{*}.
		(\forall R^{*}.(R \to X) \to F R X \to X) \to X
	\\
\mu_{*}'&~=~ \lambda F^{* \to *}.\lambda A^{*}.
		K A + ((K A \to A) \to F(K A) \to A) \to A
\end{align*}

\[K = \lambda A^{*}.\forall X^{*}.(A \to X) \to X \]

\[ \eta = \lambda a.\lambda f.f~a : A \to KA \]
\[\eta^{-1} = \lambda \varphi.\varphi~\textit{id} : KA \to A\]


\[K_T = \lambda A^{*}.\forall X^{*}.(A \to T X) \to T X \] codensity monad


\[ A \xrightarrow{\eta} KA \xrightarrow{\inL} \mu_{*}' = KA+((KA \to A) \to F(KA) \to A) \to A \]


\begin{align*}
&\MIt{*} ~:~ \forall A^{*}.
	(\forall R^{*}.(R \to A) \to F R \to A) \to \mu_{*} F \to A \\
&\MIt{*}~\varphi~x ~=~ x~\varphi \\
&\In{*} ~:~\forall F^{* \to *}.F(\mu_{*} F) \to \mu_{*} F \\
&\In{*}~x~\varphi ~=~ \varphi~(\MIt{*}~\varphi)~x
\end{align*}


\begin{align*}
&\msfit{*} ~:~ \forall A^{*}.
	(\forall R^{*}.(A \to R A) \to (R A \to A) \to F(R A) \to A) \to
	(\forall A^{*}.\mu_{*}' F A) \to A \\
&\msfit{*}~\varphi~x ~=~ x~\eta^{-1}~(\underbrace{\lambda f.f(\varphi~\eta)}_g)
\end{align*}

\begin{align*}
&\msfit{*} ~:~ \forall A^{*}.
	(\forall R^{*}.(A \to R A) \to (R A \to A) \to F(R A) \to A) \to
	(\forall A^{*}.\mu_{*}' F A) \to A \\
&\msfit{*}~\varphi~x ~=~ x~\eta^{-1}~(\underbrace{\lambda f.f(\varphi~\eta)}_g)
\end{align*}

\begin{align*}
& \lift~:~(\forall A^{*}.(K A\to A)\to F(K A)\to A)\to \mu_{*}' F A\to K A\\
& \lift~\varphi'~x ~=~ x~\textit{id}~(\lambda z.\eta(z~\varphi'))
\end{align*}


%% \[ \textit{ExpF} = \lambda R^{*}.R \times R + R \]


\begin{align*}
\textit{lam}&~:~(\forall A^{*}.\textit{Exp}'~A \to \textit{Exp}'~A) \to
		\textit{Exp} \\
\textit{lam}&~f~=~\In{*}'(\textit{Lam}~f)
= \inR~(\underbrace{
	\lambda \varphi'.\varphi'~\eta^{-1}~
	(\overbrace{\textit{Lam}(\lambda y.\textit{lift}~\varphi'~(f(\inL~y))) }^v)\;
	}_w)
\end{align*}

\[
\msfit{*}~\varphi~(\textit{lam}~f)
=?= \varphi~\eta~\eta^{-1}~(Lam(\lambda y.\eta(\msfit~\varphi~(f(\inL~y)))))
\]

$\psi = (f(\inL~y))~\textit{id}~(\lambda z.\eta(z(\varphi\eta)))$

\begin{align*}
\msfit{*}~\varphi~(\textit{lam}~f)
&~=~ (\textit{lam}~f)~\eta^{-1}~g \\
&~=~ \inR~w~\eta^{-1}~g ~=~ g~w ~=~ w(\varphi\eta) \\
&~=~ \varphi~\eta~\eta^{-1}~
	(\textit{Lam}(\lambda y.\lift~(\varphi\eta)~(f(\inL~y)))) \\
&~=~ \varphi~\eta~\eta^{-1}~(\textit{Lam}(\lambda y.\psi))
\end{align*}

\[ \eta(\msfit~\varphi~(f(\inL~y)))) = \eta(\inL~\psi~\eta^{-1}~g)
	= \eta(\eta^{-1}~\psi)
\]
section retraction since not same as $\psi$


\begin{align*}
\textit{app} &~:~ \textit{Exp} \to \textit{Exp} \to \textit{Exp} \\
\textit{app} &~ x~y = \In{*}'(\textit{App}~x~y)
= \inR~(\underbrace{\lambda \varphi'.\varphi'~\eta^{-1}~
			(\textit{App}~(\lift~\varphi'~x)~(\lift~\varphi'~y))}_h)
\end{align*}


\[ \msfit{*}~\varphi~(\textit{app}~x~y)
=?= \varphi~\eta~\eta^{-1}
	~(\textit{App}~(\eta(\msfit{*}~\varphi~x))~(\eta(\msfit{*}~\varphi~y)))
\]
\begin{align*}
\msfit{*}~\varphi~(\textit{app}~x~y)
&~=~ (\textit{app}~x~y)~\eta^{-1}~g \\
&~=~ \inR~h~\eta^{-1}~g ~=~ g~h ~=~ h(\varphi~\eta) \\
&~=~ \varphi~\eta~\eta^{-1}
     ~(\textit{App}~(\lift(\varphi\eta)x)~(\lift(\varphi\eta)y))
\end{align*}
\[ \eta(\msfit{*}~\varphi~x) =?= \lift(\varphi\eta)x \]



\[ \eta(x~\eta^{-1}~g) =?= x~\textit{id}~(\lambda z.\eta(z(\phi\eta))) \]

when $x = \inR~z$

\[
	\eta(x~\eta^{-1}~g) = \eta~g~z = \eta(z(\varphi\eta))
	= x~\textit{id}~(\lambda z.\eta(z.(\varphi\eta)))
\]


\[ \eta(\msfit{*}~\varphi~(\inR~z)) ~=~ \lift~(\varphi\eta)~(\inR~z) \]



when $x = \inL~z$

\[ \eta(\eta^{-1}z) =?= z \]
is this a section / retraction thing here???

\[\eta^{-1} = \lambda \varphi.\varphi~\textit{id} : KA \to A\]
\[ \eta = \lambda a f.f a : A \to KA \]

\[ \varphi \mapsto \varphi \mapsto \lambda f . f(\varphi~\textit{id}) \]

Section retraction since not same as $\varphi$

\section{TODO}


\section{Related Work}
TODO

\subsection{Type-based termination and sized types}\label{sec:relwork:sized}
\emph{Type-based termination} (coined by Barthe and others \cite{BartheFGPU04})
stands for approaches that integrate termination into type checking,
as opposed to syntactic approaches (\ie, conventional approach) that
reason about termination over untyped term structures.
The Mendler-style approach is, of course, type-based. In fact, the idea of
type-based termination was inspired by Mendler \cite{Mendler87,Mendler91}.
In the Mendler style, we know that well-typed functions defined using
Mendler-style recursion schemes always terminate.  This guarantee flows
from the design of the recursion scheme, where the use of higher-rank 
polymorphic types in the abstract operations enforce the invariants
necessary for termination.

Abel \cite{abel06phd,Abel12talkFICS} summarizes the advantages of
type-based termination as follows:
\textbf{communication} (programmers can think using types),
\textbf{certification} (types are machine checkable certificates),
\textbf{a simple theoretical justification}
        (no additional complication for termination other than type checking),
\textbf{orthogonality} (only small parts of the language are affected,
        \eg, principled recursion schemes instead of general recursion),
\textbf{robustness} (type system extensions are less likely to
                        disrupt termination checking),
\textbf{compositionality}\footnote{This is not listed in Abel's thesis,
                                but comes from his invited talk in FICS 2012.}
        (one needs only types, not the code, for checking the termination), and
\textbf{higher-order functions and higher-kinded datatypes}
        (works well even for higher-order functions and non-regular datatypes,
        as a consequence of compositionality).
In his dissertation \cite{abel06phd} (Section 4.4) on sized types,
Abel views the Mendler-style approach as enforcing size restrictions
using higher-rank polymorphism as follows:
\begin{itemize}
\item The abstract recursive type $r$ in Mendler style corresponds to
        $\mu^\alpha F$ in his sized-type system (System \Fwhat),
        where the sized type
        for the value being passed in corresponds to $\mu^{\alpha+1} F$.
\item The concrete recursive type $\mu F$ in Mendler style corresponds to
        $\mu^\infty F$ since there is no size restriction.
\item By subtyping, a type with a smaller size index can be cast to
        the same type with a larger size index.
\end{itemize}
This view is based on the same intuition we discussed in
Chapter \ref{ch:mendler}. Mendler-style recursion schemes terminate, for
positive datatypes -- because $r$-values are direct subcomponents
of the value being eliminated. They are always smaller
than the value being passed in. Types enforce that recursive calls
are only well typed, when applied to smaller subcomponents.

Abel's System \Fwhat\ can express primitive recursion quite naturally
using subtyping. The casting operation $(r -> \mu F)$ in Mendler-style
primitive recursion corresponds to an implicit conversion by subtyping
from $\mu^\alpha F$ to $\mu^\infty F$ because $\alpha \leq \infty$.

System \Fwhat\ \cite{abel06phd} is closely related to
System \Fixw\ \cite{AbeMat04}. Both of these systems are base on
equi-recursive fixpoint types over positive base structures.
Both of these systems are able to embed (or simulate) Mendler-style
primitive recursion (which is based on iso-recursive types) via
the encoding \cite{Geu92} of arbitrary base structures into
positive base structures. In \S\ref{sec:fixi:data}, we rely on
the same encoding, denoted by $\Phi$, when embedding \MPr\ into System \Fixw.

Abel's sized-type approach provides good intuitions why 
certain recursion schemes terminate over positive datatypes.
But, it does not give a good intuition of whether or not
those recursion schemes would terminate for negative datatypes,
unless there is an encoding that can translate negative datatypes into
positive datatypes. For primitive recursion, this is possible (as we
mentioned above). However, for our recursion scheme \MsfIt, which is
especially useful over negative datatypes, we do not know of an encoding
that can map the inverse augmented fixpoints into positive fixpoints.
So, it is not clear whether Abel's the sized type approach based on
positive equi-recursive fixpoint types can provide a good intuition
for the termination behavior of \MsfIt.  In \ref{sec:futwork:mprsi},
we will discuss another Mendler-style recursion scheme (\mprsi{}), which
is also useful over negative datatypes and has a termination property
(not proved yet) based on the size of the index in the datatype.




\section{Another Mendler-style recursion scheme for mixed-variant datatypes}
\label{sec:mprsi}
%% This section is an extended and revised version of our extended abstract
%% (without the introduction section) in the TYPES 2013 workshop.

In \S\ref{sec:msf}, we discussed Mendler-style iteration with
a syntactic inverse, \lstinline{msfcata}, which is particularly useful for
defining functions over mixed-variant datatypes.
We demonstrated the usefulness of \lstinline{msfcata} by defining
functions over HOAS:
\begin{itemize}
\item the string formatting function \lstinline{showExp} for
	the untyped HOAS using \lstinline{msfcata0}
	(Figure\;\ref{lst:HOASshow}) and
\item the type-preserving evaluator \lstinline{eval} for
	the simply-typed HOAS using \lstinline{msfcata1}
	(Figure\;\ref{list:HOASeval}).
\end{itemize}
In this section, we speculate about another Mendler-style recursion scheme,
\lstinline{mprsi}, motivated by an example similar to the \lstinline{eval}
function. The name \lstinline{mprsi} stands for
Mendler-style primitive recursion with a sized index.

\begin{figure}
\lstinputlisting[
	caption={
		Two evaluators for the simply-typed $\lambda$-calculus in HOAS.
		One uses a native (Haskell) value domain (\lstinline{eval}),
		the other uses a user-defined value domain (\lstinline{veval}).
		\label{lst:HOASevalV}
		},
	firstline=4]{HOASevalV.hs}
\vspace*{-3ex}
\end{figure}

We review the \lstinline{eval} example and then compare
it to our motivating example \lstinline{veval} for \lstinline{mprsi}.
Both \lstinline{eval} and \lstinline{veval} are illustrated
in Figure\;\ref{lst:HOASevalV}. Recall that this code is written in Haskell,
following the Mendler-style conventions.
The function \lstinline{eval :: Exp t -> Id t} is
a type preserving evaluator that evaluates an HOAS expression of type
\lstinline{t} to a (Haskell) value of type \lstinline{t}.
The \lstinline{eval} function always terminates because
\lstinline{msfcata1} always terminates. Recall that \lstinline{msfcata1}
and \lstinline{Rec1} can be embedded into System~\Fw.

The motivating example \lstinline{veval :: Exp t -> Val t} is also 
a type preserving evaluator. Unlike \lstinline{eval} it evaluates to 
a user-defined value domain \lstinline{Val} of type \lstinline{t} (rather
than a Haskell value). The definition of \lstinline{veval} is similar to
\lstinline{eval} -- both of them are defined using \lstinline{msfcata1}.
The first equation of \lstinline{phi} for evaluating
the \lstinline{Lam}-expression is essentially the same as
the corresponding equation in the definition of \lstinline{eval}.
The second equation of \lstinline{phi} for evaluating
the \lstinline{App}-expression is also similar in structure to
the corresponding equation in the definition of \lstinline{eval},
but the use of \lstinline{unVal} is problematic. Note, the definition of
\lstinline{unVal} relies on pattern matching against \lstinline{In1}.
Recall that one cannot freely pattern match against a recursive value
in Mendler style. Recursive values must be analyzed (or, eliminated) by
using Mendler-style recursion schemes. It is not a problem to use
\lstinline{unId} in the definition of \lstinline{eval} because
\lstinline{Id} is non-recursive.

It is not likely that \lstinline{unVal} can be defined using any of
the existing Mendler-style recursion schemes. So, we designed
a new Mendler-style recursion scheme that can express \lstinline{unVal}.
The new recursion scheme \lstinline{mprsi} extends \lstinline{mprim} with
an additional uncast operation. Recall that \lstinline{mprim} has
two abstract operations, call and cast. So, \lstinline{mprsi} has
three abstract operations, call, cast, and uncast. In the following paragraphs,
we explain the design of \lstinline{mprsi} step-by-step.

Let us try to define \lstinline{unVal} using \lstinline{mprim1}, and see
where it falls short. \lstinline{mprim1} provides two abstract operations,
\lstinline{cast} and {call}, as you can see from its type sigaure:
\begin{lstlisting}
mprim1 :: (forall r i. (forall i. r i -> Mu1 f i)  -- cast
              -> (forall i. r i -> a i)      -- call
              -> (f r i -> a i)        ) -> Mu1 f i -> a i
\end{lstlisting}
We attempt to define \lstinline{unVal} using \lstinline{mprim1} as follows:
\begin{lstlisting}
unVal :: Mu1 V (t1 -> t2) -> (Mu1 V t1 -> Mu1 V t2)
unVal = mprim1 phi where
  phi cast call (VFun f) = ...
\end{lstlisting}
Inside the \lstinline{phi} function, we have a function
\lstinline{f :: (r t1 -> r t2)} over abstract recursive values.
We need to cast \lstinline{f} into a function over concrete recursive values
\lstinline{(Mu1 V t1 -> Mu1 V t2)}.
We should not need to use |call|, since we do not expect
to use any recursion to define |unVal|.
So the only available operation to
work with is \lstinline{cast :: (forall i. r i -> Mu1 f i)}.
Composing \lstinline{cast} with \lstinline{f}, we can get
\lstinline{(cast . f) :: (r t1 -> Mu1 V t2)}, whose codomain
\lstinline{(Mu1 V t2)} is exactly what we want. But, the domain
is still abstract \lstinline{(r t1)} rather than being concrete
\lstinline{(Mu V t1)}. We are stuck.

What additional abstract operation would help us complete
the definition of \lstinline{unVal}? We need an abstract operation
to cast from \lstinline{(r t1)} to \lstinline{(Mu V t1)}
in a contravariant position. If we had an inverse of cast,
\lstinline{uncast :: (forall i. Mu f i -> r i)}, we can
complete the definition of \lstinline{unVal} by composing
\lstinline{uncast}, \lstinline{f}, and \lstinline{cast}.
Observe that \lstinline{uncast . f . cast :: (Mu1 V t1 -> Mu1 V t2)}.
Thus, we can formulate \lstinline{mprsi1} with a naive type signature
as follows:
\begin{lstlisting}
mprsi1 :: (forall r i. (forall i. r i -> Mu1 f i)  -- cast
               -> (forall i. Mu1 f i -> r i)  -- uncast
               -> (forall i. r i -> a i)      -- call
               -> (f r i -> a i)        ) -> Mu1 f i -> a i

mprsi1 phi (In1 x) = phi id id (mprsi1 phi) x
\end{lstlisting}
Although the type signature above is type correct, it is too powerful.
The Mendler-style uses types to forbid, as ill-typed, non terminating
computations. Having both \lstinline{cast} and \lstinline{uncast} supports
the same ability as freely pattern matching over recursive values,
which as we showed in introduction can lead to non-termination.
To recover the guarantee of termination, we need to restrict the use of
either \lstinline{cast} and \lstinline{uncast}, or both.

Let us see how this non-termination might occur. If we allowed
\lstinline{mprsi1} with the naive type signature above, we could write
an evaluator (similar to \lstinline{veval} but for an untyped HOAS),
which does not always terminate. This evaluator would diverge for terms
with self application. Typed terms use the type index to prevent
such diverging terms.

We walk through the process of defining an untyped HOAS.
The base structures of the untyped HOAS and its value domain
can be defined as follows:
\begin{lstlisting}
data ExpF_u r t = Lam_u (r t -> r t) | App_u (r t) (r t)
data V_u r t = VFun_u (r t -> r t)
\end{lstlisting}
Fixpoints of the structures above represent the untyped HOAS and
its value domain. Here, the index \lstinline{t} does not track
the types of terms but remains constant everywhere.
Why did we believe that \lstinline{veval} always terminates?
Because it evaluates a well-typed HOAS, whose type is encoded as
an index \lstinline{t} of the recursive datatype \lstinline{(Exp t)}. That is,
the use of indices as types is the key to the termination property.
Therefore, our idea is to restrict the use of the abstract operations
by enforcing constraints over their indices. We allow the use
of the abstract operations only over abstract values whose indices are
smaller in size compared to the size of the argument index.
For the \lstinline{veval} example, we define being smaller as
the structural ordering over types, that is, \lstinline{t1 < (t1 -> t2)}
and \lstinline{t2 < (t2 -> t1)}.
We have two candidates for the type signature of \lstinline{mprsi1}:
\begin{itemize}
\item Candidate 1: restrict uses of both \lstinline{cast} and \lstinline{uncast}
\begin{lstlisting}
mprsi1 :: (forall r j. (forall i. (i<j) => r i -> Mu1 f i)  --  cast
               -> (forall i. (i<j) => Mu1 f i -> r i)  --  uncast
               -> (forall i.          r i -> a i)      --  call
               -> (f r j -> a j)          ) -> Mu1 f i -> a i
\end{lstlisting}
\item Candidate 2: restrict the use of \lstinline{uncast} only
\begin{lstlisting}
mprsi1 :: (forall r j. (forall i.           r i -> Mu1 f i)  --  cast
               -> (forall i. (i<j) =>  Mu1 f i -> r i)  --  uncast
               -> (forall i.           r i -> a i)      --  call
               -> (f r j -> a j)          ) -> Mu1 f i -> a i
\end{lstlisting}
\end{itemize}
We strongly believe that the first candidate always terminate,
but it might be overly restrictive. Maybe the second candidate is
enough to guarantee termination? Both candidates allow defining
\lstinline{veval}, since one can define \lstinline{unVal}
using \lstinline{mprsi1} with either one of the candidates.
Both candiates forbid the definition of an evaluator over the untyped HOAS,
because neither support extracting functions from the untyped value domain.

We need further studies to prove termination properties of \lstinline{mprsi}.
The sized-type approach, discussed in the related work section,
seems to be relevant to showing termination of \lstinline{mprsi}.
However, existing theories on sized-types are not directly applicable to
\lstinline{mprsi} because they are focused on positive datatypes, but
not negative datatypes.


\section{Summary and Future Work}
TODO



\section*{Acknowledgements}
%% \subparagraph*{Acknowledgements}
I want to thank \dots

\appendix
\section{TODO Appendix Section}
TODO

\bibliography{main}

\end{document}
