\section{Future Work}

%% \subsection{Ongoing and future work}

Nax is one thread of research in the Trellys project,
a collaborative initiative to design a
dependently-typed programming language with simple support for general recursion
and other convenient but logically unsound features, yet still maintain a
logically sound core. Here is a partial list of ongoing and future work in the Nax thread.

\begin{itemize}

\item \emph{Embedding all of Nax into a strongly normalizing calculus}\\
We can embed datatypes of Nax and the \textsf{MIt} and \textsf{MsfIt}
combinator families into System \Fi. But, other combinator families,
such as \textsf{MPr}, are only known to be embeddable into a different
calculus, System \Fixw\ \cite{AbeMat04}, which does not support term indices.
We believe we can similarly extend \Fixw\ with erasable term indices -- we call this
calculus \Fixi, which can then embed \textsf{MPr} over datatypes with term indices.
Properties of \Fixi\ needs to be checked but we strongly believe
that the desired properties, \ie, strong normalization
and logical consistency, will hold in \Fixi\ as well as in \Fi.

\item \emph{Including both a programatic and a logical fragment}

In the future we want Nax programs to include both a logical fragment
and a non-logical (or programatic) fragment, and we want the type system
to separate the two. We believe we can extend the proof principles
outlined in the paper
{\em Step-Indexed Normalization for a Language with General Recursion}\cite{ccasin:msfp12}


% \item \emph{Correctness of the type inference algorithm}\\  TODO
	
\item \emph{Large eliminations}\\
	The current prototype of Nax only supports a limited
	form of large elimination (i.e. mapping indices from
	argument types to result types) due to the limited syntax
	of the index transformer. We hope to enrich the index
	transformer syntax to support more expressive large eliminations
	(\eg, if-then-else, or more generally, case expressions
	in index transformers) and still maintain our design goals of
	having both type inference and a logically consistent type system.
	Again, we will make sure that such new features are safe by embedding
	the new feature into the calculus Nax is based on, such as System \Fi.

% \item \emph{Generalized arrow types in Mendler-style combinators}\\ For kinds other than

\end{itemize}

