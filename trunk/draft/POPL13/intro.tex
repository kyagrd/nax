\section{Introduction}
\label{sec:intro}

%% theoretical core language for languages supporting
%% non-regular datatypes (\eg, nested datatypes) and
%% indexed datatypes (\eg, GADTs), but not fully dependent types.
%% 
%% embed recursive datatypes by Church encoding and show strong normalization
%% for the logical fragment of such a language

The introduction of Generalized Algebraic Datatypes (GADTs) to
functional languages such as Haskell and O'Caml has popularized
the use of indexed datatypes as a light-weight, type-based mechanism
to raise users' confidence that software systems maintain important properties.
A classic example is Louis-Julien Guillemette's thesis \cite{guillemetteThesis}
which encodes the classic paper by \citet{tal-toplas} completely
in Haskell. The system embeds a multi-stage compiler, compiling from System F,
all the way to typed assembly language, using indexed types to show that
every stage preserves type information.

This impressive system provides confidence, but no guarantees, since it uses
types to enforce type preservation between the stages of the compiler.
In Haskell, the non-terminating computation can be assigned any type,
so in practice, it is possible that this property is a consequence of
such a non-terminating computation in the program code.

On the other hand, the higher-order polymorphic lambda calculus, System \Fw,
is known to be strongly normalizing, and through the use of Church encodings
or Scott encodings of data structures is rich enough to express
systems with a rich collection of data structures.
Unfortunately, it is not known how to express the kind of
\emph{term-indexed datatypes} in \Fw\ that are necessary to support
Guillemette's system.

Xavier Leroy, in his CompCert system\cite{Leroy-Compcert-CACM}, showed that
a much richer language, the Calculus of Inductive Constructions (CIC), which
is the basis of the Coq theorem prover, is expressive enough to guarantee
type preservation between compiler stages (and quite a bit more).
Unfortunately, this expressivity comes with a cost. Programmers must learn to
use both dependent types, and a new programming paradigm, programming by
code extraction.

Is there an expressive system supporting non-dependent indexed types,
somewhere in between \Fw\ and dependent calculi?
Can we use non-dependent indexed types when they are all we need?
Can we program, rather than extract code? The goal of this paper is
to develop the theory necessary to begin to answer these and related questions.

To approach this goal, we have designed a new calculus, System \Fi,
which extends System \Fw\ with just a few new features. Despite
the paucity of new features, \Fi\
is expressive enough to embed non-dependent \emph{term-indexed datatypes}
and their eliminators. Our contributions are:\vspace*{-5pt}
\begin{itemize}
\item Identifying which features are needed for a $\lambda$-calculus
    to embed term-indexed datatypes (\S\ref{sec:motiv}),
    in isolation from other features normally associated with such calculii
    (e.g., general recursion, large elimination, dependent types),
    \vspace*{-2pt}
\item The design of the calculus, System \Fi\ (\S\ref{sec:Fi}), which we
    use to studying the properties of languages with term-indexed datatypes,
    by embedding such datatypes into the calculus (\S\ref{sec:data})
    For example, we can use \Fi\ to give a formal proof that the 
    Mendler-style eliminators
    for GADTs appearing in last year's ICFP paper \cite{AhnShe11} are
    indeed normalizing.
    \vspace*{-2pt}
\item Showing that \Fi\ enjoys a simple erasure property
    (\S\ref{ssec:erasure}) and inherits metatheoretic results
    (\eg, strong normalization, logical consistency)
    from well-known calculi (such as \Fw) related to System \Fi\ (\S\ref{ssec:sn}).
\end{itemize}\vspace*{-3pt}


\section{Motivation}
\label{sec:motiv}
It is well known that datatypes can be embedded into polymorphic lambda calculi
(e.g., \cite{AbeMatUus03}) using
functional encodings such as the Church encoding.
In System \textsf{F}, we can embed \emph{regular datatypes},
such as homogeneous lists:
\[\!\!\!\!\!\!\!\!\!
\begin{array}{ll}
\text{Haskell:} & \texttt{data List a = Nil | Cons a (List a)} \\
\text{System \textsf{F}:} & \texttt{{List}}\:\: A\:\:\triangleq\:\:\forall X.X\to(A\to X\to X)\to X ~~\;
\end{array}
\]
Note the use of the universally quantified type variable $X$
and the regularity of $(\texttt{List a})$ in the datatype definition.

In System \Fw, we can embed \emph{type-indexed datatypes}, which include
datatypes that are not regular. For example, we can embed powerlists with
heterogeneous elements where an element of type \texttt{a} is followed by
an element of type \texttt{(a,a)}:
\[
\begin{array}{ll}
\text{Haskell:} & \!\!\!\!\texttt{data Powl a = PNil | PCons a (Powl(a,a))} \\
\text{System \Fw:} & \!\!\!\!\texttt{{Powl}}\:\triangleq\:
\lambda A^{*}.\forall X^{*\to*}.\\ \qquad
& \qquad X A\to (A\to X(A\times A)\to X A)\to XA
\end{array}
\]
Note the non-regular occurrence \texttt{(Powl(a,a))} and
the use of the type constructor variable $X$ universally quantifying over
type constructors of kind $* -> *$.

\begin{figure}\noindent
\definecolor{shadecolor}{rgb}{1,0.9,0.7}
\!\!\!\!\!A functional language supporting term-indexed datatypes: \vspace*{-4.5pt}
\begin{lstlisting}[basicstyle={\ttfamily},language=Haskell]
data Nat = Z | S n
data Vec (a:*) {i:N} where
  VNil  : Vec a {Z}
  VCons : a -> Vec a {i} -> Vec a {S i}
\end{lstlisting}\noindent
\!\!\!System \Fi: \vspace*{-7pt}
\begin{multline*}\!\!\!\!\!\!\!
\texttt{{Vec}}\:\:\triangleq\:\:\lambda A^{*}.\lambda i^{\texttt{{N}}}.
\forall X^{\texttt{{Nat}}\to*}.\\
X\{\texttt{{Z}}\}\to
(\forall i^{\texttt{{Nat}}}.A\to X\{i\}\to X\{\texttt{{S}}\; i\})\to X\{i\}
\end{multline*}\vspace*{-10pt}
\caption{A Motivating Example: length-indexed lists}
\label{fig:motiv}
\end{figure}

What extensions to \Fw\ do we need to embed datatypes that are indexed by
terms (such as \texttt{Z}, \texttt{i}, and \texttt{S i}), as well as indexed by types (\texttt{a})?
The classical example of such a type is the length-indexed lists
(\verb|Vec a {i}|) outlined in Figure \ref{fig:motiv}.
From this motivating example, we learn that
the calculus would need four additional constructs:
\begin{itemize}
\item index arrow kinds ($\texttt{{Nat}\ensuremath{\to}*}$),
\item index abstraction ($\lambda i^{\texttt{{Nat}}}.\cdots$),
\item index application ($X\{i\}$), and
\item index polymorphism ($\forall i^{\texttt{{Nat}}}.\cdots$).
\end{itemize}


