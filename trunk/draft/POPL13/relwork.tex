\section{Related work}
\label{sec:relwork}
Among theoretical calculi, \Fi\ is most closely related to
Curry-style System \Fw \cite{AbeMatUus03,AbeMatUus05,GHR93}
and Implicit Calculus of Constructions (ICC) \cite{Miquel01}.
All terms typable in Curry-style System \Fw\ are typable in System \Fi\ 
with the same type, and all terms typable in \Fi\ are typable in ICC
with the same type.\footnote{The $*$ kind in \Fw\ and \Fi\ corresponds
	to \textsf{Set} in ICC.}
We have discussed that we can derive strong normalization, logical consistency,
and subject reduction of \Fi, from \Fw\ and a subset of ICC.
In fact, ICC is more than just an extension of \Fi, as described in our work,
with dependent types and stratified universes. ICC includes $\eta$-reduction
and the extensionality typing rule. We do not foresee any problem of adding
$\eta$-reduction and the extensionality typing rule to \Fi. Although
System \Fi\ accepts less terms than ICC, \Fi\ enjoys more simple
erasure properties (Theorem \ref{thm:ierasetypingifree} and
Theorem \ref{thm:ierasetypingall}), which ICC cannot not provide
due to its support for full dependent types. In System \Fi, index terms
appearing in types (\eg, $s$ in $F\{s\}$) are always erasable.
\citet{LingerS08} formalized a more generic framework than ICC, which describes
the erasure on arbitrary Church-style calculi (EPTS) and Curry-style calculi
(IPTS), but only consider $\beta$-equivalence for type conversion.

In \S\ref{ssec:rationale}, we have mentioned that Curry-style calculi enjoys
better reduction properties (\eg,$\beta\eta$-reduction is Church-Rosser)
than Church-style calculi. \citet{Nederpelt73} showed a counterexample to
the Church-Rosser property for $\beta\eta$-reduction of Church-style terms.
\citet{Geuvers92} proved that $\beta\eta$-reduction is Church-Rosser
in functional PTSs, which is a certain class of Church-style calculi.
\citet{Seldin08} discusses the relation between the Church-style typing
and the Curry-style typing.

In a more practical setting aimed twoards language implementation,
\citet{YorgeyWCJVM12}, inspired by \citet{SHE}, designed a language extension
to Haskell, promoting datatypes to be used as kinds. For instance, \texttt{Bool}
is promoted to a kind (\ie, $\texttt{Bool}:\square$) and its data constructors
\texttt{Ture} and \texttt{False} are promoted to type level. To support this
in GHC, they extended System $F_{\!C}$ (GHC's intermediate language, or,
GHC Core), naming the extended GHC Core as System $F_{\!C}^\uparrow$.
The key difference between $F_{\!C}^\uparrow$ and \Fi\ is in the extension
to the kind syntax, as illustrated below: \vspace*{-2pt}
\[\qquad\quad
\begin{array}{ll}
F_{\!C}^\uparrow\,\textbf{kinds}: &
\kappa ::= * \mid \kappa -> \kappa \mid F \vec{\kappa} \mid \mathcal{X} \mid \forall \mathcal{X}.\kappa \mid \cdots \\
\,\Fi\,\,\textbf{kinds}: &
\kappa ::= * \mid \kappa -> \kappa \mid A -> \kappa \phantom{A^{A^A}}
\end{array}  
\] ~\vspace*{-6pt}\\
In $F_{\!C}^\uparrow$, any type constructor ($F$) is promoted to 
kind level and becomes a kind when fully applied to other kinds
($F\vec\kappa$). In \Fi, on the other hand, a type can only appear
at the domain of an index arrow kind ($A-> \kappa$). This seemingly small
difference to the kind syntax makes $F_{\!C}^\uparrow$ to develop into
a drastically more expressive language than \Fi. The promotion of
a type constructor, for instance, $\texttt{List}:* -> *$ to a kind constructor
$\texttt{List}:\square-> \square$ enables type-level data structures
such as $\mathtt{[Nat,Bool,Nat-> Bool]:List\,*}$. Having type-level
data structure motivates type-level computation over promoted data,
which they make it possible by extending the type families\footnote{
	A GHC extension to define type-level functions in Haskell}.
In addition, the promotion of polymorphic types naturally motivates
kind polymorphism ($\forall \mathcal{X}.\kappa$), which is known to
break strong normalization and cause logical inconsistency \cite{Girard72}.
For the purpose of extending a functional programming language,
inconsistency is not an issue. However, for our interest of studying
term-indexed datatypes in a logically consistent calculi, we need
a more conservative approach, as in \Fi, starting from smallest possible
extension that maintains normalization and consistency.

Literature on handing type equality constraints in the type systems supporting
GADTs is vast. We list a few of them. System $F_{\!C}$ \cite{Sulzmann07} would
arguably be the most influential system, being the intermediate language of
the Glasgow Haskell Compiler (GHC). \citet{VytWei10} proved parametricity of
System $\mathrm{R}_\omega$ \cite{Crary98}, an extension to Curry-style $\Fw$
with the type-representation datatype and its primitive recursor, so that
one may derive \emph{free theorems} \cite{Wadler89free} in the presence of
type equalities.

Another possible approach for utilizing term-indexed datatypes for lightweight
verified programming is to restrict from full-spectrum dependent types, rather
than to extend from non-dependent types. $F^{*}$, developed by \citet{Swamy11},
is a language for secure distributed programming with value dependent types.
In $F^{*}$, terms appearing in dependent types are restricted to first-order
values, which is in spirit of value restriction in ML type inference, but
even more limited to values that are not functions. By taming the dependent type
with such a restriction, they were able to have a usable programming language
and also self-certify \citet{Swamy12} their compiler by implementing $F^{*}$
type checker in $F^{*}$.

