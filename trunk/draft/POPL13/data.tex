\section{Embedding datatypes and their eliminators} \label{sec:data}
We demonstrate some examples of embedding datatypes into System \Fi.
%% TODO cite some paper that does this with System Fw or System F
We first illustrate the embedding of both non-recursive datatypes and
recursive datatypes as Church-encoded terms (\S\ref{ssec:embedChurch}).
Then, we illustrate a more involved embedding for the recursive datatypes
based on two-level types (\S\ref{ssec:embedTwoLevel}).

\subsection{Embedding datatypes of Church-encoded terms}
\label{ssec:embedChurch}

\begin{tabular}{lp{60mm}}
	\hline
boolean type	& $\!\!\!\!\textit{Bool} = \forall X.X -> X -> X$ \\
constructors		& $\mathtt{True} = \l x_1.\l x_2. x_1$ \\
            &$\mathtt{False} = \l x_1.\l x_2. x_2$ \\
eliminator		& $\l x.\l x_1. \l x_2. x\;x_1\,x_2$ \\
	      &(\textbf{if} $x$ \textbf{then} $x_1$ \textbf{else} $x_2$)
	\\\hline
pair type & $\!\!\!\!\!\!\!\!A_1\times A_2 = \forall X. (A_1 -> A_2 -> X) -> X$ \\
constructor		& $\mathtt{pair} = \l x_1.\l x_2.\l x'.x'\,x_1\,x_2$ \\
eliminator		& $\l x.\l x'.x\;x'$ \par
			(by passing appropriate values to $x'$, \par ~~ we get
			~$\textit{fst} = \l x.x(\l x_1.\l x_2.x_1)$,\par \qquad
			\quad
			~$\,\textit{snd} = \l x.x(\l x_1.\l x_2.x_2)$ )
	\\\hline

sum type & $\!\!\!\!\!\!\!\!A_1+A_2 = \forall X^{*}. (A_1 -> X) -> (A_2 -> X) -> X$ \\
constructors		& $\mathtt{inl} = \l x. \l x_1. \l x_2 . x_1\,x$\\
	      &		$\mathtt{inr} = \l x. \l x_2. \l x_2 . x_2\,x$ \\
eliminator		& $\l x.\l x_1. \l x_2. x\;x_1\,x_2$ \par
			(\textbf{case} $x$ \textbf{of}
				\{$\mathtt{inl}~x' -> x_1\;x'$;
				  $\mathtt{inr}~x' -> x_2\;x'$\})
	\\\hline
list type & $\!\!\!\!\!\!\!\!\textit{List}=\l A^{*}.\forall X^{*}. (A -> X -> X) -> X -> X$ \\
constructors		& $\mathtt{cons} = \l x_a.\l x.\l x_c.\l x_n. x_c\,x_a\,(x\;x_c\,x_n)$\\
       &	$\mathtt{nil}\;\, = \l x_c.\l x_n.\l x_n$ \\
eliminator		& $\l x.\l x_c. \l x_n.x\;x_c\,x_n$ \\
	    &		(\textit{foldr} $x_z$ $x_c$ $x$ in Haskell)
	\\\hline
\end{tabular}


lists
encoding of type	$\textit{List}\;A = \forall X. (A -> X -> X) -> X -> X$ \\
constructors		$\mathtt{cons} = \l x_a.\l x.\l x_c.\l x_n. x_c\,x_a\,(x\;x_c\,x_n)$,\par
			$\mathtt{nil}\;\, = \l x_c.\l x_n.\l x_n$ \\
eliminator		$\l x.\l x_c. \l x_n.x\;x_c\,x_n$ \quad
			(\textit{foldr} $x_z$ $x_c$ $x$ in Haskell)

\[
\textit{Powl} = \l A^{*}.\forall X^{* -> *} .
	(A -> X(A\times A) -> XA) -> XA  -> XA \\
\]

\begin{align*}
\textit{Powl} &= \l A^{*}.\forall X^{* -> *}&.&
	(A -> X(A\times A) & -> & XA) & -> & XA & -> & XA \\
\textit{List} &= \l A^{*}.\forall X^{*}&.&
	(A -> X & -> & X) & -> & X & -> & X
\end{align*}


\subsection{
   Embedding the recursive type operator and the Mendler-style iterators}
\label{ssec:embedTwoLevel}
We can divide a recursive datatype defintion into two levels,
by factoring out the recursive type operator, which ties the knot of
the recursive definition, and a non-recursive base structure,
which describes the shape (\ie, number of data constructors and their types) of
the recursive datatype.

For the non-recursive base structures, or non-recursive datatypes,
we can use the same impredicative encodings in the previous subsection.
That is, booleans, sums, and products are encoded as in Figure TODO.

Encoding of two-level types are more involved than the encoding, but
iterator definitions become more general and uniform.

\begin{figure}
\begin{lstlisting}[basicstyle={\ttfamily\small},language=Haskell,mathescape]
newtype Mu$_{*}$ (f :: * -> *)
  = In$_{*}$ (f (Mu$_{*}$ f))

data ListF (a::*) (r::*)
  = Nil
  | Cons a r

type List a = Mu$_{*}$ (ListF a)
nil       = In$_{*}$ Nil
cons x xs = In$_{*}$ (Cons x xs)

mit$_{*}$ :: ($\forall$ r.(r->x) -> f r -> x) -> Mu0 f -> x
mit$_{*}$ phi (In$_{*}$ z) = phi (mit$_{*}$ phi) z

newtype Mu$_{(*-> *)}$ (f :: (*->*) -> (*->*)) (a::*)
  = In$_{(*-> *)}$ (f (Mu$_{(*-> *)}$ f)) a

data PowlF (r::*->*) (a::*)
  = PNil
  | PCons a (r(a,a))

type Powl a = Mu$_{(*-> *)}$ PowlF a
pnil       = In$_{(*-> *)}$ PNil
pcons x xs = In$_{(*-> *)}$ (PCons x xs)

mit$_{(*-> *)}$ :: ($\forall$ r a.($\forall$a.r a->x a) -> f r a -> x a)
        -> Mu$_{(*-> *)}$ f a -> x a
mit$_{(*-> *)}$ phi (In$_{(*-> *)}$ z) = phi (mit$_{(*-> *)}$ phi) z

-- above is Haskell (with some GHC extensions)
-- below is Haskell-ish psudocode

newtype Mu$_{(\mathtt{Nat}-> *)}$ (f::(Nat->*)->(Nat->*)) {n::Nat}
  = In$_{(\mathtt{Nat}-> *)}$ (f (Mu$_{(\mathtt{Nat}-> *)}$ f)) {n}

data VecF (a::*) (r::Nat->*) {n::Nat} where
  VNil  :: VecF a r {Z}
  VCons :: a -> r n -> VecF a r {S n}

type Vec a {n::Nat} = Mu$_{(\mathtt{Nat}-> *)}$ (VecF a) {n}
vnil       = In$_{(\mathtt{Nat}-> *)}$ VNil
vcons x xs = In$_{(\mathtt{Nat}-> *)}$ (VCons x xs)

mit$_{(\mathtt{Nat}-> *)}$::($\forall$ r n.($\forall$n.r{n}->x{n})->f r {n}->x{n})
        -> Mu$_{(\mathtt{Nat}-> *)}$ f {n} -> x{n}
mit$_{(\mathtt{Nat}-> *)}$ phi (In$_{(\mathtt{Nat}-> *)}$ z) = phi (mit$_{(\mathtt{Nat}-> *)}$ phi) z
\end{lstlisting}
\caption{2-level types and their Mendler-style iterators in Haskell}
\label{fig:twoleveltypes}
\end{figure}
