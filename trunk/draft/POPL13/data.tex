\section{Embedding datatypes and their eliminators} \label{sec:data}
We demonstrate some examples of embedding datatypes into System \Fi.
%% TODO cite some paper that does this with System Fw or System F
We first illustrate embeddings for both non-recursive datatypes and
recursive datatypes, where we use Church encodings \cite{Church33}
for data constructors (\S\ref{ssec:embedChurch}). Then, we illustrate
a more involved embedding for the recursive datatypes based on two-level types
(\S\ref{ssec:embedTwoLevel}).

\subsection{Embedding datatypes using Church-encoded terms}
\label{ssec:embedChurch}
\begin{figure}
\begin{align*}
&\!\!\!\!\!\!\mathtt{Bool} &=~& \forall X.X -> X -> X \\
&\!\!\!\!\!\!\mathtt{true}  &\!\!\!:~~& \texttt{Bool} ~~=~ \l x_1.\l x_2. x_1 \\
&\!\!\!\!\!\!\mathtt{false} &\!\!\!:~~& \texttt{Bool} ~~=~ \l x_1.\l x_2. x_2 \\
&\!\!\!\!\!\!\mathtt{elim_{Bool}} &\!\!\!:~~& \texttt{Bool} -> \forall X.X -> X -> X \\
&	&=~& \l x.\l x_1. \l x_2. x\;x_1\,x_2 \qquad
(\textbf{if}~x~\textbf{then}~x_1~\textbf{else}~x_2)
\end{align*}\vspace*{-19pt} \\ \vspace*{-4pt}
\rule{\linewidth}{.4pt}
\begin{align*}
&\!\!\!\!\!\!A_1\times A_2 &=~& \forall X. (A_1 -> A_2 -> X) -> X \\
&\!\!\!\!\!\!\mathtt{pair} &\!\!\!:~~&
	\forall A_1^{*}.\forall A_2^{*}.A_1\times A_2
	~~=~ \l x_1.\l x_2.\l x'.x'\,x_1\,x_2 \\
&\!\!\!\!\!\!\mathtt{elim_{(\times)}} &\!\!\!:~~&
	\forall A_1^{*}.\forall A_2^{*}.A_1\times A_2 ->
	\forall X. (A_1 -> A_2 -> X) -> X \\
	& &=~& \l x.\l x'.x\;x' \\
 &&&\!\!\!\!\!\!\!\!\text{(by passing appropriate values to $x'$, we get}\\
 &&&\!\!\!\!\textit{fst} = \l x.x(\l x_1.\l x_2.x_1),~
            \textit{snd} = \l x.x(\l x_1.\l x_2.x_2) ~)
\end{align*} \vspace*{-19pt} \\ \vspace*{-4pt}
\rule{\linewidth}{.4pt}
\begin{align*}
&\!\!\!\!\!\!A_1+A_2 &=~&\forall X^{*}. (A_1 -> X) -> (A_2 -> X) -> X \\
&\!\!\!\!\!\!\mathtt{inl} &\!\!\!:~~& \forall A_1^{*}.\forall A_2^{*}.A_1-> A_1+A_2
	~~=~ \l x. \l x_1. \l x_2 . x_1\,x \\
&\!\!\!\!\!\!\mathtt{inr} &\!\!\!:~~& \forall A_1^{*}.\forall A_2^{*}.A_2-> A_1+A_2
	~~=~ \l x. \l x_1. \l x_2 . x_2\,x \\
&\!\!\!\!\!\!\mathtt{elim_{(+)}} &\!\!\!:~~&
	\forall A_1^{*}.\forall A_2^{*}.(A_1+A_2) -> \\
	&&& \forall X^{*}. (A_1 -> X) -> (A_2 -> X) -> X \\
	& &=~& \l x.\l x_1. \l x_2. x\;x_1\,x_2 \\
	&&&			(\textbf{case}~x~\textbf{of}~
				\{\mathtt{inl}~x' -> x_1\;x';
				  \mathtt{inr}~x' -> x_2\;x'\})
\end{align*}~\vspace*{-10pt}
\caption{Embedding non-recursive datatypes}
\label{fig:churchnonrec}
\end{figure}
\begin{figure}
\begin{align*}
&\!\!\!\!\!\!\mathtt{List} &\!\!\!\!\!=~& \l A^{*}.\forall X^{*}.(A-> X-> X)-> X-> X
	\\
&\!\!\!\!\!\!\texttt{cons} &\!\!\!\!\!:~~& \forall A^{*}.A-> \mathtt{List}\,A-> \mathtt{List}\,A \\
& & & \qquad~\qquad~\quad\, =~\l x_a.\l x.\l x_c.\l x_n. x_c\,x_a\,(x\;x_c\,x_n) \\
&\!\!\!\!\!\!\mathtt{nil} &\!\!\!\!\!:~~& \forall A^{*}.\texttt{List}\,A
~~=~ \l x_c.\l x_n.\l x_n \\
&\!\!\!\!\!\!\mathtt{elim_{List}} &\!\!\!\!:~~& \forall A^{*}.\texttt{List}\,A ->
	\forall X^{*}.(A -> X -> X) -> X -> X \\
& &\!\!\!\!\!=~& \l x.\l x_c. \l x_n.x\;x_c\,x_n\qquad
	\text{(\textit{foldr} $x_z$ $x_c$ $x~$ in Haskell)}
\end{align*}\vspace*{-19pt} \\ \vspace*{-4pt}
\rule{\linewidth}{.4pt}
\begin{align*}
&\!\!\!\!\!\!\mathtt{Powl} &\!\!\!\!\!=~& \l A^{*}.\\
&&&\forall X^{*-> *}.(A-> X(A\times A)-> XA)-> XA -> XA \\
&\!\!\!\!\!\!\texttt{pcons} &\!\!\!\!\!:~~& \forall A^{*}.A-> \mathtt{Powl}(A\times A)-> \mathtt{Powl}\,A \\
&&& \qquad~\qquad~\quad\, ~=~ \l x_a.\l x.\l x_c.\l x_n. x_c\,x_a\,(x\;x_c\,x_n) \\
&\!\!\!\!\!\!\mathtt{pnil} &\!\!\!\!\!:~~& \forall A^{*}.\texttt{Powl}\,A
~~~=~ \l x_c.\l x_n.\l x_n \\
&\!\!\!\!\!\!\mathtt{elim_{Powl}} &\!\!\!\!:~~& \forall A^{*}.\texttt{Powl}\,A -> \\
&&& \forall X^{*-> *}.(A -> X(A\times A) -> XA) -> XA -> XA \\
& &\!\!\!\!\!=~& \l x.\l x_c. \l x_n.x\;x_c\,x_n
\end{align*}\vspace*{-19pt} \\ \vspace*{-4pt}
\rule{\linewidth}{.4pt}
\begin{align*}
&\!\!\!\!\!\!\mathtt{Vec} &\!\!\!\!\!\!\!\!=~& \l A^{*}.\l i^{\mathtt{Nat}}.\\
&&&	\forall X^{\mathtt{Nat}-> *}.
	(\forall i^\mathtt{Nat}.A-> X\{i\}-> X\{\mathtt{succ}\,i\}) ->  \\
&&& \qquad~\qquad X\{\texttt{zero}\} -> X\{i\} \\
 &\!\!\!\!\!\!\texttt{vcons} &\!\!\!\!\!\!\!\!:~& \forall A^{*}.\forall i^\mathtt{Nat}.A-> \mathtt{Vec}\,A\,\{i\}-> \mathtt{Vec}\,A\,\{\mathtt{succ}\,i\} \\
&&&\;\qquad\qquad\quad =~ \l x_a.\l x.\l x_c.\l x_n. x_c\,x_a\,(x\;x_c\,x_n) \\
&\!\!\!\!\!\!\mathtt{vnil} &\!\!\!\!\!\!\!\!:~& \forall A^{*}.\texttt{Vec}\,A\,\{\mathtt{zero}\} 
~~~=~ \l x_c.\l x_n.\l x_n \\
&\!\!\!\!\!\!\mathtt{elim_{Vec}} &\!\!\!\!\!\!\!\!:~& \forall A^{*}.\forall i^\mathtt{Nat}.\texttt{Vec}\,A\,\{i\} -> \\
&&& \forall X^{\mathtt{Nat}-> *}.(\forall i^\mathtt{Nat}.A -> X\{i\} -> X\{\mathtt{succ}\,i\}) -> \\
&&& \qquad~\qquad X\{\mathtt{zero}\} -> X\{i\} \\
& &\!\!\!\!\!=~& \l x.\l x_c. \l x_n.x\;x_c\,x_n
\end{align*} ~\vspace*{-14pt}
\caption{Embedding recursive datatypes}
\label{fig:churchrec}
\end{figure}
\citet{Church33} demonstrated an embedding of natural numbers into
the untyped $\lambda$-calculus, which he invented, in order to argue
that the $\lambda$-calculus  expressive enough for the foundation of
logic and arithmetic. Church encoded the data constructors of natural numbers,
successor and zero, as higher-order functions,
$\mathtt{succ}=\l x.\l x_s.\l x_z.x_s(x\,x_s x_z)$ and
$\mathtt{zero}=\l x_s.\l x_z.x_z$.
The heart of the Church encoding is that a value is encoded as its elimination.
The bound variables $x_s$ and $x_z$ stands for the operations needed for
eliminating the successor case and the zero case. The Church encodings of
successor and zero states that: to eliminate $\mathtt{succ}\,x$, apply $x_s$
to the elimination of the predecessor $(x\,x_s x_z)$; and,
to eliminate $\mathtt{zero}$, just return $x_z$.
Since values themselves are eliminators,
eliminator can be defined as applying the value itself to the needed operations
for each data constructor case. For instance, we can define an eliminator
for natural numbers as $\mathtt{elimNat}=\l x.\l x_s.\l x_z.x\,x_s x_z$,
which is just an $\eta$-expansion of the identity function $\l x.x$.
Church encoded natural numbers are typable in polymorphic $\lambda$-calculi,
such as System \Fw, as follows:\vspace*{-2pt}
\begin{align*}
&\texttt{Nat} &=~& \forall X^{*}.(X -> X) -> X -> X \qquad\qquad\qquad\\
&\texttt{succ} &\!\!\!:~~& \texttt{Nat} -> \texttt{Nat}
	~~ =~ \l x.\l x_s.\l x_z.x_s(x\,x_s x_z) \\
&\texttt{zero} &\!\!\!:~~& \texttt{Nat} \qquad\quad\,
	~~ =~ \l x_s.\l x_z.x_z \\
&\mathtt{elim_{Nat}} &\!\!\!:~~& \texttt{Nat} -> \forall X^{*}.(X -> X)-> X-> X \\
& &=~& \l x.\l x_s.\l x_z.x\,x_s x_z
\end{align*}~\vspace*{-13pt}

Similarly, other datatypes are also embeddable into
polymorphic $\lambda$-calculi in this fashion.
Embeddings of some well-known non-recursive datatypes are illustrated
in Figure \ref{fig:churchnonrec}, and embeddings of the list-like
recursive datatypes, which we discussed earlier as motivating examples
(\S\ref{sec:motiv}), are illustrated in Figure \ref{fig:churchrec}.
Note that the term encodings for the constructors and eliminators of
the list-like datatypes in Figure \ref{fig:churchrec} are exactly the same.
For instance, the term encodings for \texttt{nil}, \texttt{pnil}, and
\texttt{vnil} coincide as $\l x_s.\l x_z.x_z$.

\subsection{
   Embedding the recursive type operators and the Mendler-style iterators}
\label{ssec:embedTwoLevel}
We can divide a recursive datatype definition into two levels,
by factoring out the recursive type operator, which ties the knot of
the recursive definition, and a non-recursive base structure,
which describes the shape (\ie, number of data constructors and their types) of
the recursive datatype.

For the non-recursive base structures, or non-recursive datatypes,
we can use the same impredicative encodings in the previous subsection.
That is, booleans, sums, and products are encoded as in Figure TODO.

Encoding of two-level types are more involved than the encoding, but
iterator definitions become more general and uniform.

\begin{figure}
\begin{lstlisting}[basicstyle={\ttfamily\small},language=Haskell,mathescape]
newtype Mu$_{*}$ (f :: * -> *)
  = In$_{*}$ (f (Mu$_{*}$ f))

data ListF (a::*) (r::*)
  = Cons a r       | Nil

type List a = Mu$_{*}$ (ListF a)
cons x xs = In$_{*}$ (Cons x xs)
nil       = In$_{*}$ Nil

mit$_{*}$ :: ($\forall$ r.(r->x) -> f r -> x) -> Mu0 f -> x
mit$_{*}$ phi (In$_{*}$ z) = phi (mit$_{*}$ phi) z

newtype Mu$_{(*-> *)}$ (f :: (*->*) -> (*->*)) (a::*)
  = In$_{(*-> *)}$ (f (Mu$_{(*-> *)}$ f)) a

data PowlF (r::*->*) (a::*)
  = PCons a (r(a,a)) | PNil

type Powl a = Mu$_{(*-> *)}$ PowlF a
pcons x xs = In$_{(*-> *)}$ (PCons x xs)
pnil       = In$_{(*-> *)}$ PNil

mit$_{(*-> *)}$ :: ($\forall$ r a.($\forall$a.r a->x a) -> f r a -> x a)
        -> Mu$_{(*-> *)}$ f a -> x a
mit$_{(*-> *)}$ phi (In$_{(*-> *)}$ z) = phi (mit$_{(*-> *)}$ phi) z

-- above is Haskell (with some GHC extensions)
-- below is Haskell-ish psudocode

newtype Mu$_{(\mathtt{Nat}-> *)}$ (f::(Nat->*)->(Nat->*)) {n::Nat}
  = In$_{(\mathtt{Nat}-> *)}$ (f (Mu$_{(\mathtt{Nat}-> *)}$ f)) {n}

data VecF (a::*) (r::Nat->*) {n::Nat} where
  VCons :: a -> r n -> VecF a r {S n}
  VNil  :: VecF a r {Z}

type Vec a {n::Nat} = Mu$_{(\mathtt{Nat}-> *)}$ (VecF a) {n}
vcons x xs = In$_{(\mathtt{Nat}-> *)}$ (VCons x xs)
vnil       = In$_{(\mathtt{Nat}-> *)}$ VNil

mit$_{(\mathtt{Nat}-> *)}$::($\forall$ r n.($\forall$n.r{n}->x{n})->f r {n}->x{n})
        -> Mu$_{(\mathtt{Nat}-> *)}$ f {n} -> x{n}
mit$_{(\mathtt{Nat}-> *)}$ phi (In$_{(\mathtt{Nat}-> *)}$ z) = phi (mit$_{(\mathtt{Nat}-> *)}$ phi) z
\end{lstlisting}
\caption{2-level types and their Mendler-style iterators in Haskell}
\label{fig:twoleveltypes}
\end{figure}
