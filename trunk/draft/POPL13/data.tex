\section{Embedding datatypes and their eliminators} \label{sec:data}
We demonstrate some examples of embedding datatypes into System \Fi.
%% TODO cite some paper that does this with System Fw or System F
We first illustrate embeddings for both non-recursive datatypes and
recursive datatypes, where we use Church encodings \cite{Church33}
for data constructors (\S\ref{ssec:embedChurch}). Then, we illustrate
a more involved embedding for the recursive datatypes based on two-level types
(\S\ref{ssec:embedTwoLevel}).

\subsection{Embedding datatypes using Church-encoded terms}
\label{ssec:embedChurch}
\begin{figure}
\begin{align*}
&\!\!\!\!\!\!\mathtt{Bool} &=~& \forall X.X -> X -> X \\
&\!\!\!\!\!\!\mathtt{true}  &\!\!\!:~~& \texttt{Bool} ~~=~ \l x_1.\l x_2. x_1 \\
&\!\!\!\!\!\!\mathtt{false} &\!\!\!:~~& \texttt{Bool} ~~=~ \l x_1.\l x_2. x_2 \\
&\!\!\!\!\!\!\mathtt{elim_{Bool}} &\!\!\!:~~& \texttt{Bool} -> \forall X.X -> X -> X \\
&	&=~& \l x.\l x_1. \l x_2. x\;x_1\,x_2 \qquad
(\textbf{if}~x~\textbf{then}~x_1~\textbf{else}~x_2)
\end{align*}\vspace*{-19pt} \\ \vspace*{-4pt}
\rule{\linewidth}{.4pt}
\begin{align*}
&\!\!\!\!\!\!A_1\times A_2 &=~& \forall X. (A_1 -> A_2 -> X) -> X \\
&\!\!\!\!\!\!\mathtt{pair} &\!\!\!:~~&
	\forall A_1^{*}.\forall A_2^{*}.A_1\times A_2
	~~=~ \l x_1.\l x_2.\l x'.x'\,x_1\,x_2 \\
&\!\!\!\!\!\!\mathtt{elim_{(\times)}} &\!\!\!:~~&
	\forall A_1^{*}.\forall A_2^{*}.A_1\times A_2 ->
	\forall X. (A_1 -> A_2 -> X) -> X \\
	& &=~& \l x.\l x'.x\;x' \\
 &&&\!\!\!\!\!\!\!\!\text{(by passing appropriate values to $x'$, we get}\\
 &&&\!\!\!\!\textit{fst} = \l x.x(\l x_1.\l x_2.x_1),~
            \textit{snd} = \l x.x(\l x_1.\l x_2.x_2) ~)
\end{align*} \vspace*{-19pt} \\ \vspace*{-4pt}
\rule{\linewidth}{.4pt}
\begin{align*}
&\!\!\!\!\!\!A_1+A_2 &=~&\forall X^{*}. (A_1 -> X) -> (A_2 -> X) -> X \\
&\!\!\!\!\!\!\mathtt{inl} &\!\!\!:~~& \forall A_1^{*}.\forall A_2^{*}.A_1-> A_1+A_2
	~~=~ \l x. \l x_1. \l x_2 . x_1\,x \\
&\!\!\!\!\!\!\mathtt{inr} &\!\!\!:~~& \forall A_1^{*}.\forall A_2^{*}.A_2-> A_1+A_2
	~~=~ \l x. \l x_1. \l x_2 . x_2\,x \\
&\!\!\!\!\!\!\mathtt{elim_{(+)}} &\!\!\!:~~&
	\forall A_1^{*}.\forall A_2^{*}.(A_1+A_2) -> \\
	&&& \forall X^{*}. (A_1 -> X) -> (A_2 -> X) -> X \\
	& &=~& \l x.\l x_1. \l x_2. x\;x_1\,x_2 \\
	&&&			(\textbf{case}~x~\textbf{of}~
				\{\mathtt{inl}~x' -> x_1\;x';
				  \mathtt{inr}~x' -> x_2\;x'\})
\end{align*}~\vspace*{-10pt}
\caption{Embedding non-recursive datatypes}
\label{fig:churchnonrec}
\end{figure}
\begin{figure}
\begin{align*}
&\!\!\!\!\!\!\mathtt{List} &\!\!\!\!\!=~& \l A^{*}.\forall X^{*}.(A-> X-> X)-> X-> X
	\\
&\!\!\!\!\!\!\texttt{cons} &\!\!\!\!\!:~~& \forall A^{*}.A-> \mathtt{List}\,A-> \mathtt{List}\,A \\
& & & \qquad~\qquad~\quad\, =~\l x_a.\l x.\l x_c.\l x_n. x_c\,x_a\,(x\;x_c\,x_n) \\
&\!\!\!\!\!\!\mathtt{nil} &\!\!\!\!\!:~~& \forall A^{*}.\texttt{List}\,A
~~=~ \l x_c.\l x_n.\l x_n \\
&\!\!\!\!\!\!\mathtt{elim_{List}} &\!\!\!\!:~~& \forall A^{*}.\texttt{List}\,A ->
	\forall X^{*}.(A -> X -> X) -> X -> X \\
& &\!\!\!\!\!=~& \l x.\l x_c. \l x_n.x\;x_c\,x_n\qquad
	\text{(\textit{foldr} $x_z$ $x_c$ $x~$ in Haskell)}
\end{align*}\vspace*{-19pt} \\ \vspace*{-4pt}
\rule{\linewidth}{.4pt}
\begin{align*}
&\!\!\!\!\!\!\mathtt{Powl} &\!\!\!\!\!=~& \l A^{*}.\\
&&&\forall X^{*-> *}.(A-> X(A\times A)-> XA)-> XA -> XA \\
&\!\!\!\!\!\!\texttt{pcons} &\!\!\!\!\!:~~& \forall A^{*}.A-> \mathtt{Powl}(A\times A)-> \mathtt{Powl}\,A \\
&&& \qquad~\qquad~\quad\, ~=~ \l x_a.\l x.\l x_c.\l x_n. x_c\,x_a\,(x\;x_c\,x_n) \\
&\!\!\!\!\!\!\mathtt{pnil} &\!\!\!\!\!:~~& \forall A^{*}.\texttt{Powl}\,A
~~~=~ \l x_c.\l x_n.\l x_n \\
&\!\!\!\!\!\!\mathtt{elim_{Powl}} &\!\!\!\!:~~& \forall A^{*}.\texttt{Powl}\,A -> \\
&&& \forall X^{*-> *}.(A -> X(A\times A) -> XA) -> XA -> XA \\
& &\!\!\!\!\!=~& \l x.\l x_c. \l x_n.x\;x_c\,x_n
\end{align*}\vspace*{-19pt} \\ \vspace*{-4pt}
\rule{\linewidth}{.4pt}
\begin{align*}
&\!\!\!\!\!\!\mathtt{Vec} &\!\!\!\!\!\!\!\!=~& \l A^{*}.\l i^{\mathtt{Nat}}.\\
&&&	\forall X^{\mathtt{Nat}-> *}.
	(\forall i^\mathtt{Nat}.A-> X\{i\}-> X\{\mathtt{succ}\,i\}) ->  \\
&&& \qquad~\qquad X\{\texttt{zero}\} -> X\{i\} \\
 &\!\!\!\!\!\!\texttt{vcons} &\!\!\!\!\!\!\!\!:~& \forall A^{*}.\forall i^\mathtt{Nat}.A-> \mathtt{Vec}\,A\,\{i\}-> \mathtt{Vec}\,A\,\{\mathtt{succ}\,i\} \\
&&&\;\qquad\qquad\quad =~ \l x_a.\l x.\l x_c.\l x_n. x_c\,x_a\,(x\;x_c\,x_n) \\
&\!\!\!\!\!\!\mathtt{vnil} &\!\!\!\!\!\!\!\!:~& \forall A^{*}.\texttt{Vec}\,A\,\{\mathtt{zero}\} 
~~~=~ \l x_c.\l x_n.\l x_n \\
&\!\!\!\!\!\!\mathtt{elim_{Vec}} &\!\!\!\!\!\!\!\!:~& \forall A^{*}.\forall i^\mathtt{Nat}.\texttt{Vec}\,A\,\{i\} -> \\
&&& \forall X^{\mathtt{Nat}-> *}.(\forall i^\mathtt{Nat}.A -> X\{i\} -> X\{\mathtt{succ}\,i\}) -> \\
&&& \qquad~\qquad X\{\mathtt{zero}\} -> X\{i\} \\
& &\!\!\!\!\!=~& \l x.\l x_c. \l x_n.x\;x_c\,x_n
\end{align*} ~\vspace*{-14pt}
\caption{Embedding recursive datatypes}
\label{fig:churchrec}
\end{figure}
\citet{Church33} demonstrated an embedding of natural numbers into
the untyped $\lambda$-calculus, which he invented, in order to argue
that the $\lambda$-calculus  expressive enough for the foundation of
logic and arithmetic. Church encoded the data constructors of natural numbers,
successor and zero, as higher-order functions,
$\mathtt{succ}=\l x.\l x_s.\l x_z.x_s(x\,x_s x_z)$ and
$\mathtt{zero}=\l x_s.\l x_z.x_z$.
The heart of the Church encoding is that a value is encoded as its elimination.
The bound variables $x_s$ and $x_z$ stands for the operations needed for
eliminating the successor case and the zero case. The Church encodings of
successor and zero states that: to eliminate $\mathtt{succ}\,x$, apply $x_s$
to the elimination of the predecessor $(x\,x_s x_z)$; and,
to eliminate $\mathtt{zero}$, just return $x_z$.
Since values themselves are eliminators,
eliminator can be defined as applying the value itself to the needed operations
for each data constructor case. For instance, we can define an eliminator
for natural numbers as $\mathtt{elim_{Nat}}=\l x.\l x_s.\l x_z.x\,x_s x_z$,
which is just an $\eta$-expansion of the identity function $\l x.x$.
Church encoded natural numbers are typable in polymorphic $\lambda$-calculi,
such as System \Fw, as follows:\vspace*{-2pt}
\begin{align*}
&\texttt{Nat} &=~& \forall X^{*}.(X -> X) -> X -> X \qquad\qquad\qquad\\
&\texttt{succ} &\!\!\!:~~& \texttt{Nat} -> \texttt{Nat}
	~~ =~ \l x.\l x_s.\l x_z.x_s(x\,x_s x_z) \\
&\texttt{zero} &\!\!\!:~~& \texttt{Nat} \qquad\quad\,
	~~ =~ \l x_s.\l x_z.x_z \\
&\mathtt{elim_{Nat}} &\!\!\!:~~& \texttt{Nat} -> \forall X^{*}.(X -> X)-> X-> X \\
& &=~& \l x.\l x_s.\l x_z.x\,x_s x_z
\end{align*}~\vspace*{-13pt}

Similarly, other datatypes are also embeddable into
polymorphic $\lambda$-calculi in this fashion.
Embeddings of some well-known non-recursive datatypes are illustrated
in Figure \ref{fig:churchnonrec}, and embeddings of the list-like
recursive datatypes, which we discussed earlier as motivating examples
(\S\ref{sec:motiv}), are illustrated in Figure \ref{fig:churchrec}.
Note that the term encodings for the constructors and eliminators of
the list-like datatypes in Figure \ref{fig:churchrec} are exactly the same.
For instance, the term encodings for \texttt{nil}, \texttt{pnil}, and
\texttt{vnil} coincide as $\l x_s.\l x_z.x_z$.

\subsection{
   Embedding the recursive type operators and the Mendler-style iterators}
\label{ssec:embedTwoLevel}
We can divide a recursive datatype definition into two levels,
by factoring out the recursive type operator, which weaves in the recursion
to the datatype definition, and a non-recursive base structure, which describes
the shape (\ie, number of data constructors and their types) of the datatype.
We can program with two-level types in functional languages that support
higher-order polymorphism\footnote{a.k.a. higher-kinded polymorphism
	or type constructor polymorphism}, such as Haskell, as illustrated
in Figure \ref{fig:twoleveltypes}. The function $\mathtt{mit}_\kappa$ descirbes
the Mendler-style iteration\footnote{An iteration is a principled recursion
	scheme guaranteed to terminate for any well-founded input.
	Also known as fold or catamorphism} for the recursive types
defined by $\mu_\kappa$. Although it is possible to wirte programs using
two level datatypes, we would not have gurantee of logical consistency
in such general purpose functional lanugages.

\begin{figure}
\begin{lstlisting}[basicstyle={\ttfamily\small},language=Haskell,mathescape]
newtype $\mu_{*}$ (f :: * -> *)
  = In$_{*}$ (f ($\mu_{*}$ f))

data ListF (a::*) (r::*)
  = Cons a r       | Nil

type List a = $\mu_{*}$ (ListF a)
cons x xs = In$_{*}$ (Cons x xs)
nil       = In$_{*}$ Nil

mit$_{*}$ :: ($\forall$ r.(r->x) -> f r -> x) -> Mu0 f -> x
mit$_{*}$ phi (In$_{*}$ z) = phi (mit$_{*}$ phi) z

newtype $\mu_{(*-> *)}$ (f :: (*->*) -> (*->*)) (a::*)
  = In$_{(*-> *)}$ (f (Mu$_{(*-> *)}$ f)) a

data PowlF (r::*->*) (a::*)
  = PCons a (r(a,a)) | PNil

type Powl a = $\mu_{(*-> *)}$ PowlF a
pcons x xs = In$_{(*-> *)}$ (PCons x xs)
pnil       = In$_{(*-> *)}$ PNil

mit$_{(*-> *)}$ :: ($\forall$ r a.($\forall$a.r a->x a) -> f r a -> x a)
        -> $\mu_{(*-> *)}$ f a -> x a
mit$_{(*-> *)}$ phi (In$_{(*-> *)}$ z) = phi (mit$_{(*-> *)}$ phi) z

-- above is Haskell (with some GHC extensions)
-- below is Haskell-ish psudocode

newtype $\mu_{(\mathtt{Nat}-> *)}$ (f::(Nat->*)->(Nat->*)) {n::Nat}
  = In$_{(\mathtt{Nat}-> *)}$ (f ($\mu_{(\mathtt{Nat}-> *)}$ f)) {n}

data VecF (a::*) (r::Nat->*) {n::Nat} where
  VCons :: a -> r n -> VecF a r {S n}
  VNil  :: VecF a r {Z}

type Vec a {n::Nat} = $\mu_{(\mathtt{Nat}-> *)}$ (VecF a) {n}
vcons x xs = In$_{(\mathtt{Nat}-> *)}$ (VCons x xs)
vnil       = In$_{(\mathtt{Nat}-> *)}$ VNil

mit$_{(\mathtt{Nat}-> *)}$::($\forall$ r n.($\forall$n.r{n}->x{n})->f r {n}->x{n})
        -> $\mu_{(\mathtt{Nat}-> *)}$ f {n} -> x{n}
mit$_{(\mathtt{Nat}-> *)}$ phi (In$_{(\mathtt{Nat}-> *)}$ z) = phi (mit$_{(\mathtt{Nat}-> *)}$ phi) z
\end{lstlisting}
\caption{2-level types and their Mendler-style iterators in Haskell}
\label{fig:twoleveltypes}
\end{figure}

Interestingly, there exists an embedding of the recursive type operator
$\mu_\kappa$, its data constructor $\mathtt{In}_\kappa$,
and the Mendler-style iterator $\mathtt{mit}\kappa$ at each kind $\kappa$
into higher-order polymorhpic lambda calculi, as in Figure \ref{fig:mu}.

However, there does not exist an embedding of destructing
(or, pattern matching away) the $\mathtt{In}_\kappa$ constructors.
It is a known fact that having arbitrary recursive datatypes
and the ability arbitrarily destruct (or, unroll) the values of
recursive types is powerful enough to define non-termiating computation
in a type safe way.

TODO For the non-recursive base structures, or non-recursive datatypes,
we can use the same impredicative encodings in the previous subsection.
That is, booleans, sums, and products are encoded as in Figure TODO.

TODO Encoding of two-level types are more involved than the encoding, but
iterator definitions become more general and uniform.

\begin{figure*}
\begin{align*}
&\mu_\kappa &\!\!\!\!\!~:~~& (\kappa -> \kappa) -> \kappa
  \qquad\qquad\qquad\qquad\quad
  = \l F^{\kappa -> \kappa}.\boldsymbol{\l}\mathbb{I}^\kappa.
  \forall X^\kappa.
  (\forall {X_r}^{\!\!\kappa}.
  	(X_r \stackrel{\kappa\;}{\pmb{\pmb{->}}} X) ->
	(F X_r \stackrel{\kappa\;}{\pmb{\pmb{->}}} X)) -> X\mathbb{I} \\
&\mu_{*} &\!\!\!\!\!~:~~& (* -> *) -> * 
 \qquad\qquad\qquad\qquad\quad~
 = \l F^{* -> *}.\phantom{\boldsymbol{\l}\mathbb{I}^\kappa.}
 \forall X^{*}.(\forall {X_r}^{\!\!*}.(X_r -> X) -> (F\,X_r -> X)) -> X \\
&\mu_{*-> *} &\!\!\!\!\!~:~~& ((* -> *) -> (* -> *)) -> (* -> *) \\
&            &\!\!\!\!\!=~&
  \l F^{(*-> *) -> (*-> *)}.\l X_1^{*}.
   \forall X^{* -> *}.(\forall {X_r}^{\!\!* -> *}.
   (\forall X_1^{*}.X_r X_1 -> X X_1) -> (\forall X_1^{*}.F\,X_r X_1 -> X X_1)) -> X X_1 \\
  &\mu_{\mathtt{Nat}-> *} &\!\!\!\!\!~:~~& ((\mathtt{Nat} -> *) -> (\mathtt{Nat} -> *)) -> (\mathtt{Nat} -> *) \\
&            &\!\!\!\!\!=~&
  \l F^{(\mathtt{Nat}-> *) -> (\mathtt{Nat}-> *)}.\l i_1^\mathtt{Nat}.
  \forall X^{\mathtt{Nat} -> *}.(\forall {X_r}^{\!\!\mathtt{Nat} -> *}.
  (\forall i_1^\mathtt{Nat}.X_r i_1 -> X i_1) -> (\forall i_1^\mathtt{Nat}.F\,X_r i_1 -> X i_1)) -> X i_1 \qquad\qquad
\end{align*}
\begin{align*}
\mathtt{In}_{\kappa} \,~\,&~~:~ \forall F^{\kappa-> \kappa}.
	F(\mu_\kappa F) \stackrel{\kappa\;}{\pmb{\pmb{->}}} \mu_\kappa F
&&=~ \l x_r. \l x_\varphi.x_\varphi\,(\mathtt{mit}_\kappa~x_\varphi)\,x_r
	\qquad~\qquad~\qquad~\qquad~\quad \\
\mathtt{mit}_\kappa &~~:~ \forall F^{\kappa-> \kappa}.\forall X^\kappa.
	(\forall {X_r}^{\!\!\kappa}.
	 (X_r \stackrel{\kappa\;}{\pmb{\pmb{->}}} X) ->
	 (F X_r \stackrel{\kappa\;}{\pmb{\pmb{->}}} X) ) ->
	(\mu_\kappa F \stackrel{\kappa\;}{\pmb{\pmb{->}}} X)
&&=~ \l x_\varphi.\l x_r.x_r\,x_\varphi
\end{align*}
\caption{Embedding of the recursive operators ($\mu_\kappa$),
	their data constructors ($\mathtt{In}_\kappa$),
	and the Mendler-style iterators ($\mathtt{mit}_\kappa$).}
\label{fig:mu}
\end{figure*}

