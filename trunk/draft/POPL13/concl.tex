\section{Conclusion and Future work}
\label{sec:concl}

System~\Fi\ is a strongly-normalizing, logically-consistent, higher-order
polymorphic lambda calculus that was designed to support the
definition of datatypes indexed by both terms and types.
In terms of expressivity, System~\Fi\ sits between System~\Fw\ and ICC.
We designed System~\Fi\ as a tool to reason about programming
languages with term-indexed datatypes. 

We have applied this tool to the design of the programming language Nax (not yet published).
Nax is given semantics in terms of System~\Fi . In Nax, Mendler style operators
are primitive operators with their own typing rules. Nax has been designed to
be expressive over the Hindley-Milner subset of System \Fi. It supports type
inference with minimal typing annotations. We believe this is an advantage
made possible because our extensions to \Fw\ are all static. This would be made
much more difficult had we restricted ICC.

Typing annotations in Nax are necessary only
on case statements (for non-recursive term-indexed datatypes)
and Mendler-style operators (for recursive term-indexed datatypes).
Programs involving only type-indexing require no annotations elsewhere.
A typing annotation takes a limited form of a large elimination,
which is an abstraction over both type- and term-indices to types
(\eg, $X,i_1,i_2 \mapsto F X \{i_1 + i_2\}$), which is somewhat similar to
the convoy pattern idiom \cite{cpdt} found in Coq proof scripts to aid
type checking depedent case expressions.
One of our futuer work
is to include richer form of large elimination, which enables selection
of different type constructors for the result type of case statements
and Mendler-style operators, such as:\vspace*{-5pt}
\[ X,i_1,i_2 \mapsto \textbf{if}\;i_1<i_2\;
	\textbf{then}\; F_1 X \{i_1\}\;\textbf{else}\;F_2 X \{i_2\} \]
~ \vspace*{-15pt} \\
Enriching the type annotations in Nax will motivate us to identify
the features we needed extend \Fi\ for embedding large eliminations.

%% Such abstractions
%% are classified exactly by the kinds derivable from the kind
%% syntax of \Fi.   The current implementation requires
%% static annotations, but we believe we can extend Nax to abstract over
%% annotations, and still retain the strict separation between terms and types
%% that allows both type inference and an erasure semantics.
 
