\section{Nax}\label{sec:nax}
\begin{figure}
\begin{framed}
\paragraph{Syntax:}
\begin{align*}
&\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!
 \text{Kinds}
 \!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!
	& \kappa	&~ ::= ~ * \mid \kappa -> \kappa \mid A -> \kappa
 \!\!\!\! \!\!\!\! \\
&\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!
 \text{Type Constructors}
 \!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!
	& T,H,A,B	&~ ::= ~ X \mid T
			   \mid \mu^\kappa(T\,\overline\tau)
			   \mid F\;G \mid F\,\{s\}
			   \mid A -> B
 \!\!\!\! \!\!\!\! \\
&\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!
 \text{Type Schemes}
 \!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!
	& \sigma	&~ ::= A
			   \mid \forall X.\sigma
			   \mid \forall i.\sigma
 \!\!\!\! \!\!\!\! \\
&\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!
 \text{Terms}
 \!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!
	& r,s,t		&~ ::= ~ x \mid `x \mid i
			   \mid \lambda x.t \mid r\;s
			   \mid \<let> x=s \<in> t %% \\
%% &	&		&~~~~~
			   \mid \varphi^\psi
			   \mid \<MIt> x.\varphi^\psi
			   \mid \In^\kappa
 \!\!\!\! \!\!\!\! \\
&\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!
 \text{Program}
 \!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!
	& Prog		&~ ::= ~ \overline{D};t
 \!\!\!\! \!\!\!\! \\
&\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!
 \text{Declarations}
 \!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!
	& D		&~ ::= \<data> T : \overline{K} -> * \<where>
                               \overline{C : \overline{A} -> T\,\overline{\tau}}
			 ~~\mid~ `x = t
 \!\!\!\! \!\!\!\! \\
&\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!
 \text{List of Declarations}
 \!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!
	& \overline{D}	&~ ::= \cdot \mid D,\overline{D}
 \!\!\!\! \!\!\!\! \\
&\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!
 \text{Kind Arguments}
 \!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!
	& K		&~ ::= ~ \kappa \mid A
 \!\!\!\! \!\!\!\! \\
&\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!
 \text{Type Arguments}
 \!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!
	& \tau		&~ ::= ~ G \mid \{s\}
 \!\!\!\! \!\!\!\! \\
&\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!
 \text{Type Argument Variables}
 \!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!
	& \iota		&~ ::= ~ X \mid i
 \!\!\!\! \!\!\!\! \\
&\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!
 \text{Index Transformers}
 \!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!
	& \psi		&~ ::= \cdot \mid \overline\iota . B
 \!\!\!\! \!\!\!\! \\
&\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!
 \text{Case Branches}
 \!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!
	& \varphi	&~ ::= \overline{C\,\overline{x} -> t}
 \!\!\!\! \!\!\!\! \\
&\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!
 \text{Contexts}
 \!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!
	& \Sigma	&~ ::= ~ \cdot
			   \mid \Sigma, T: \kappa
			   \mid \Sigma, C: \sigma
			   \mid \Sigma, `x: \sigma = t
 \!\!\!\! \!\!\!\! \\
&\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!
 \!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!
	& \Delta	&~ ::= ~ \cdot
			   \mid \Delta, X^\kappa
			   \mid \Delta, i^\sigma
 \!\!\!\! \!\!\!\! \\
&\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!
 \!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!
	& \Gamma	&~ ::= ~ \cdot \mid \Gamma,x:\sigma
 \!\!\!\! \!\!\!\!
\end{align*}

\paragraph{Well-formed contexts:}
\[ \fbox{$|- \Sigma$}
 ~~~~
   \inference{}{|- \cdot}
 ~~~~
   \inference{|- \Sigma & \Sigma |- \kappa:\square}
             {|- \Sigma,T:\kappa}
      \big( T\notin\dom(\Sigma) \big)
\]
\[ \inference{|- \Sigma & \Sigma;\cdot |- \sigma:*}
             {|- \Sigma,C:\sigma}
      \big( C\notin\dom(\Sigma) \big)
 ~~~~
   \inference{|- \Sigma & \Sigma;\cdot |- \sigma:*}
             {|- \Sigma,`x:\sigma=t}
      \big( `x\notin\dom(\Sigma) \big)
\]
\[ \fbox{$\Sigma|- \Delta$}
 ~~~~
   \inference{|- \Sigma}{\Sigma |- \cdot}
 ~~~~
   \inference{\Sigma |- \Delta & \Sigma |- \kappa:\square}
             {\Sigma |- \Delta,X^\kappa}
      \big( X\notin\dom(\Delta) \big)
 ~~~~ 
   \inference{\Sigma |- \Delta & \Sigma;\cdot |- \sigma:*}
             {\Sigma |- \Delta,i^\sigma}
      \big( i\notin\dom(\Delta) \big)
\]
\[ \fbox{$\Sigma;\Delta |- \Gamma$}
 ~~~~
   \inference{\Sigma |- \Delta}{\Sigma;\Delta |- \cdot}
 ~~~~
   \inference{\Sigma;\Delta |- \Gamma & \Sigma;\Delta |- A:*}
             {\Sigma;\Delta |- \Gamma,x:A}
      \big( x\notin\dom(\Gamma) \big)
\]
~\\

\paragraph{Reduction:}
$ \fbox{$t \rightsquigarrow t'$}
 ~~~~
   \inference{}{(\lambda x.t)\,s \rightsquigarrow [s/x]t}
 ~~~~
   \inference{}{\<let> x=s \<in> t \rightsquigarrow [s/x]t}
$
\[ \inference{ C\,\overline{x} -> t \in \varphi }
             { \varphi^\psi (C\,\overline{t})  \rightsquigarrow
               [\overline{t}/\overline{x}]t }
 ~~~~
   \inference{}
      { \<MIt> x.\varphi^\psi\;(\In^\kappa t) \rightsquigarrow
        [\<MIt> x.\varphi^\psi/x]\varphi^\psi ~ t}
\]
\[  \inference{t \rightsquigarrow t'}{\lambda x.t \rightsquigarrow \lambda x.t'}
 ~~~~
   \inference{r \rightsquigarrow r'}{r\;s \rightsquigarrow r'\;s}
 ~~~~
   \inference{s \rightsquigarrow s'}{r\;s \rightsquigarrow r\;s'}
 ~~~~
   \inference{t_i \rightsquigarrow t_i'}
             {C~t_1\cdots t_i \cdots t_n \rightsquigarrow
              C~t_1\cdots t_i'\cdots t_n }
\]
\[ \inference{s\rightsquigarrow s'}
             {\<let> x=s \<in> t \rightsquigarrow \<let> x=s' \<in> t}
 ~~~~
 \inference{t\rightsquigarrow t'}
             {\<let> x=s \<in> t \rightsquigarrow \<let> x=s \<in> t'}
 ~~~~
   \inference{\varphi^\psi \rightsquigarrow \varphi'^\psi}
             {\<MIt> x.\varphi^\psi \rightsquigarrow \<MIt> x.\varphi'^\psi}
\]
\[ \inference{t_i \rightsquigarrow t_i'}
      {(C_1\,\overline{x_1} -> t_1;\cdots
       ;C_i\,\overline{x_i} -> t_i;\cdots
       ;C_n\,\overline{x_n} -> t_n)^\psi
      ~\rightsquigarrow~
       (C_1\,\overline{x_1} -> t_1;\cdots
       ;C_i\,\overline{x_i} -> t_i';\cdots
       ;C_n\,\overline{x_n} -> t_n)^\psi
      }
\]
\end{framed}
\caption{Syntax and Reduction rules of Nax}
\label{fig:NaxSyntax}
\end{figure}

\begin{figure}
\begin{framed}
\paragraph{Sorting:}
\[ \fbox{$\Sigma |- \kappa : \square$}
 ~~~~
  \inference[($A$)]{}{\Sigma |- * : \square}
 ~~
   \inference[($R$)]{ \Sigma |- \kappa  : \square
                    & \Sigma |- \kappa' : \square }
                    { \Sigma |- \kappa -> \kappa' : \square }
 ~~
   \inference[($Ri$)]{\Sigma;\cdot |- A : * & \Sigma |- \kappa : \square}
                     {\Sigma |- A -> \kappa : \square}
\]

\paragraph{Kinding:}
$ \fbox{$\Sigma;\Delta |- \sigma : \kappa$ }
 ~~~~
   \inference[($\forall$)]{\Sigma;\Delta, X^\kappa |- \sigma : *}
                          {\Sigma;\Delta |- \forall X . \sigma : *}
 ~~~~
   \inference[($\forall i$)]{\Sigma;\Delta, i^A |- \sigma : *}
                            {\Sigma;\Delta |- \forall i . \sigma : *}
$
\[ \fbox{$\Sigma;\Delta |- F : \kappa$}
 ~~~~
   \inference[($Var$)]{X^\kappa\in\Delta & \Sigma |- \Delta}
                      {\Sigma;\Delta |- X : \kappa}
 ~~~~
   \inference[($TCon$)]{T:\kappa\in\Sigma & \Sigma |- \Delta}
                       {\Sigma;\Delta |- T : \kappa}
 ~~~~
   \inference[($\mu$)]{\Sigma;\Delta |- T\,\overline\tau : \kappa -> \kappa}
                      {\Sigma;\Delta |- \mu^\kappa(T\,\overline\tau) : \kappa}
\]
\[ \inference[($@$)]{ \Sigma;\Delta |- F : \kappa -> \kappa'
                    & \Sigma;\Delta |- G : \kappa }
                    {\Sigma;\Delta |- F\,G : \kappa'}
 ~~~~
   \inference[($@i$)]{ \Sigma;\Delta |- F : A -> \kappa
                     & \Sigma;\Delta;\cdot |- s : A }
                     {\Sigma;\Delta |- F\,\{s\} : \kappa}
\]
\[ \inference[($->$)]{\Sigma;\Delta |- A : * & \Sigma;\Delta |- B : *}
                     {\Sigma;\Delta |- A -> B : * }
 ~~~~
   \inference[($Conv$)]{ \Sigma;\Delta |- A : \kappa
                       & \Sigma;\Delta |- \kappa = \kappa' : \square }
                       {\Sigma;\Delta |- A : \kappa'}
\]


\paragraph{Typing:}
\[ \fbox{$\Sigma |- Prog : A$}
 ~~~~
   \inference[($\cdot;t$)]{\Sigma;\cdot;\cdot |- t:A}
                          {\Sigma |- \cdot;t : A}
 ~~~~
   \inference[($D$)]{ \Sigma |- D \Rrightarrow \Sigma'
                    & \Sigma' |- \overline{D};\; t : A}
                    {\Sigma |- D,\overline{D};\; t : A}
\]
\[ \fbox{$\Sigma;\Delta;\Gamma |- t : A$}
 ~~~~
   \inference[($=$)]{ \Sigma;\Delta;\Gamma |- t : A
                    & \Sigma;\Delta |- A = B : *}
                    {\Sigma;\Delta;\Gamma |- t : B}
\]
\[ \inference[($:$)]
      { x:\sigma \in \Gamma & \Sigma;\Delta |- A\prec\sigma
      & \Sigma;\Delta |- \Gamma }
      {\Sigma;\Delta;\Gamma |- x:A}
 ~~~~
   \inference[($:i$)]
      { i^\sigma \in \Delta & \Sigma;\Delta |- A\prec\sigma
      & \Sigma;\Delta |- \Gamma }
      {\Sigma;\Delta;\Gamma |- i:A}
\]
\[ \inference[($:C$)]
      { C:\sigma \in \Sigma & \Sigma;\Delta |- A\prec\sigma
      & \Sigma;\Delta |- \Gamma }
      {\Sigma;\Delta;\Gamma |- C:A}
 ~~~~
 \inference[($:`$)]
      { `x:\sigma=t \in \Sigma & \Sigma;\Delta |- A\prec\sigma
      & \Sigma;\Delta |- \Gamma }
      {\Sigma;\Delta;\Gamma |- `x:A}
\]
\[ \inference[($->$$I$)]{\Sigma;\Delta;\Gamma,x:A |- t : B}
                        {\Sigma;\Delta;\Gamma |- \lambda x.t : A -> B}
 ~~~~ ~~~~ ~~~~ ~~~~
   \inference[($->$$E$)]{ \Sigma;\Delta;\Gamma |- r : A -> B
                        & \Sigma;\Delta;\Gamma |- s : A}
                        {\Sigma;\Delta;\Gamma |- r\;s : B}
\]
\[ \inference[(let)]
      { \Sigma;\Delta,\overline{\iota^K};\Gamma |- s : A \\
        \Sigma;\Delta;\Gamma,x:\forall\,\overline{\iota}.A |- t : B }
      {\Sigma;\Delta;\Gamma |- \<let> x=s \<in> t : B }
      \begin{pmatrix} \overline{\iota} \cap \FV(s) = \emptyset \\
                      \overline{\iota} \cap \FV(\Gamma) = \emptyset
      \end{pmatrix}
 ~~~~
   \inference[(case)]
      { \Sigma;\Delta;\Gamma |-^\psi \varphi
                             : \forall\,\overline\iota . F\,\overline\iota
                                                    -> \psi(\overline\iota) }
      {\Sigma;\Delta;\Gamma |- \varphi^\psi
                             : F\;\overline\tau -> \psi(\overline\tau) }
\]
\[ \inference[(MIt)]
      { \Sigma;\Delta,X^\kappa;
               \Gamma,x:\forall\,\overline{\iota'} . X\overline{\iota'}
                                              -> \psi(\overline{\iota'})
           |-^\psi \varphi
           : \forall\,\overline\iota . F\,X\,\overline\iota
                                     -> \psi(\overline\iota) }
      {\Sigma;\Delta;\Gamma
           |- \<MIt> x.\varphi^\psi
           : \mu^{\kappa}\,T\;\overline\tau -> \psi(\overline\tau) }
      \big( X\notin\FV(\Gamma) \big)
\]
\[ \inference[(In)]
      {}
      {\Sigma;\Delta;\Gamma |- \In^\kappa
        : F(\mu^\kappa F)\,\overline{\tau} -> \mu^\kappa F\;\overline{\tau} }
\]
\[ \fbox{$\Sigma;\Delta;\Gamma |-^\psi \varphi : \sigma$}
 ~~~~
   \inference
      { \Sigma|_T = \overline{C_k:\sigma_k}^{\;k=1..n} &
        \overline{
        \begin{matrix}
         \Sigma;\Delta
           |- \overline{A} -> T\,\overline{\tau'}\,\overline\tau\prec\sigma_k
        ~&~
         \Sigma;\Delta;\Gamma,\overline{x:A} |- t : \psi(\overline\tau) 
        \end{matrix} }^{\;k=1..n} }
      { \Sigma;\Delta;\Gamma
           |-^\psi \overline{C_k\;\overline{x} -> t}^{\;k=1..n}
           : T\,\overline{\tau'}\,\overline\tau -> \psi(\overline\tau) }
\]

\paragraph{Extending the Global Context:}
\fbox{$\Sigma |- D \Rrightarrow \Sigma'$}
\[ \inference[($\Sigma,`x$)]
       {\Sigma;\overline{\iota^K};\cdot |- t : A}
       {\Sigma |- `x = t \Rrightarrow \Sigma,`x:\forall\,\overline{\iota}.A=t}
      \big( \overline{\iota} \cap \FV(t) = \emptyset \big)
\]
\[ \inference[($\Sigma,T$)]
      { \overline{ \Sigma,T:\kappa;\;\overline{\iota^K}
                      |- \overline{A} -> T\,\overline\tau :*} }
      { \Sigma |- \<data> T : \kappa \<where>
                  \overline{C : \overline{A} -> T\,\overline\tau }
               ~\Rrightarrow~
                  \Sigma,T:\kappa
                        ,\overline{C:\forall\,\overline{\iota}.\overline{A}
                                                       -> T\,\overline\tau} }
\]
\end{framed}
\caption{Typing rules of Nax}
\label{fig:NaxTyping}
\end{figure}

The Nax language definition is described in \Fig{NaxSyntax} and \Fig{NaxTyping}.

\paragraph{Typing contexts}
The typing context of Nax spearated into three zones. In addition to
the two zones of \Fi (the type level context $\Delta$ and
the term level context $\Gamma$), we have top level contexts ($\Sigma$).
The top level contexts can contain three kinds of bindings:
type constructor binding ($T:\kappa$), data constructor binding ($C:\sigma$),
and top level variable binding ($`x:\sigma$). These bindings are introduced
from delcarations ($D$). Type constructor bindings ($T:\kappa$) and
data constructor bindings ($C:\sigma$) are introduced from datatype declarations
($\<data> T:\dots \<where> \dots$). Top level variable bindings ($`x:\sigma$)
are introduced from top level definitions ($`x = t$).
The rules for well-formed contexts in Nax are similar to those rules in \Fi.

\paragraph{Kinds and their sorting rules}
The kind syntax of Nax is exactly the same as the kind syntax of \Fi.
The sorting rules are the same as \Fi\ except we judge the sorts of kinds
under the top level context ($\Sigma$).

\paragraph{Type constructors and their kinding rules}
The syntax for type constructors of Nax is similar to \Fi, but
different from \Fi\ in two aspects.

Firstly, polymorphic types are separate out as type schemes ($\sigma$) in Nax
since the type system of Nax is in flavour of Hindley-Milner to support
type inference (or, reconstruction).

Secondly, there are no type level abstractions and index abstractions in Nax.
Instead of defining type constructors expecting type arguments by abstraction
and index abstraction at type level, Nax supports datatype declarations
($\<data> T:\dots \<where> \dots$) and recursive type operators
($\mu^\kappa$) as language constructs.

TODO explain the kinding rules different from \Fi

\paragraph{Terms and their typing rules}
The term syntax of Nax has four additional term constructs than \Fi:
polymorphic let binding ($\<let>\dots \<in> \dots$),
eliminators for data constructors ($\varphi^\psi$),
Mendler style iterators ($\<MIt>\dots$), and
constructors for recursive types ($\In^\kappa~\dots$).

Polymorphic let bindings in Nax are just the usual polymorphic bindings of
Hindley-Milner type system for generalizing types of local definitions into
type schemes. In Nax, we generalize over term indices as well as types.

Eliminators for data constructors, or case terms, are also the usual
case terms for non-indexed types (\ie, when $\psi=\cdot$), but with
the additional index transformer ($\psi$) annotation, which aids
type reconstruction of case terms for indexed types.
TODO example and explanation for index transformers

$\<MIt>$ TODO.

The $\In$ constructors for recursive types are as usual.
However, Nax does not provide destructors, or inverse functions of $\In$,
which are often denoted as \textsf{unIn} or \textsf{out}, since we want
to support arbitrary recursive types in a normalizing language.


\paragraph{Nax programs and their typing rules}
A Nax program is a list of declarations followed by a term.
The information about the datatype definitions
in the datatype declarations are captured in the top level context ($\Sigma$)
before type checking the term (see ($\Sigma,T$) rule in \Fig{NaxTyping}).
Therefore, each of the sorting, kinding, and typing rules of Nax
(\Fig{NaxTyping}) has an additional top level context ($\Sigma$) compared to
the corresponding rules of \Fi\ (\Fig{Fi}).
%% TODO talk about embedding (fwd ref)???


\subsection{Type inference (or, reconstruction)}

