\section{Nax}\label{sec:nax}
\begin{figure}
\begin{framed}
\paragraph{Syntax:}
\begin{align*}
&\text{Kinds}
	& \kappa	&~ ::= ~ * \mid \kappa -> \kappa \mid A -> \kappa
 \\
&\text{Type Constructors}
	& T,H,A,B	&~ ::= ~ X \mid F
			   \mid \mu^\kappa
			   \mid T\;H \mid T\,\{s\}
			   \mid A -> B
 \\
&\text{Type Schemes}
	& \sigma	&~ ::= A
			   \mid \forall X.\sigma
			   \mid \forall i.\sigma
 \\
&\text{Terms}
	& r,s,t		&~ ::= ~ x \mid `x \mid i
			   \mid \lambda x.t \mid r\;s
			   \mid \<let> x=s \<in> t \\
&	&		&~~~~~
			   \mid \case^\psi~s~\varphi
			   \mid \MIt^\psi x.\varphi
			   \mid \In^\kappa
 \\
&\text{Program}
	& Prog		&~ ::= ~ \overline{D};t
 \\
&\text{Declarations}
	& D		&~ ::= \mathbf{data}~ F : \overline{K} -> *
                             ~ \mathbf{where} ~
                            \overline{C : \overline{A} -> F\,\overline{\tau}}
			 ~~\mid~ `x = t
 \\
&\text{List of Declarations}
	& \overline{D}	&~ ::= \cdot \mid D,\overline{D}
 \\
&\text{Kind Arguments}
	& K		&~ ::= ~ \kappa \mid A
 \\
&\text{Type Arguments}
	& \tau		&~ ::= ~ H \mid \{s\}
 \\
&\text{Type Argument Variables}
	& \iota		&~ ::= ~ X \mid i
 \\
&\text{Index Transformers}
	& \psi		&~ ::= \cdot \mid \overline\iota . B
 \\
&\text{Branches}
	& \varphi	&~ ::= \overline{C\,\overline{x} -> t}
 \\
&\text{Contexts}
	& \Sigma	&~ ::= ~ \cdot
			   \mid \Sigma, F: \kappa
			   \mid \Sigma, C: \sigma
			   \mid \Sigma, x: \sigma
 \\
&	& \Delta	&~ ::= ~ \cdot
			   \mid \Delta, X^\kappa
			   \mid \Delta, i^\sigma
 \\
&	& \Gamma	&~ ::= ~ \cdot \mid \Gamma,x:\sigma
\end{align*}

\paragraph{Reduction:}
$ \fbox{$t \rightsquigarrow t'$}
 ~~~~
   \inference{}{(\lambda x.t)\,s \rightsquigarrow [s/x]t}
 ~~~~
   \inference{}{\<let> x=s \<in> t \rightsquigarrow [s/x]t}
$
\[ \inference{ C\,\overline{x} -> t \in \varphi }
             { \case^\psi (C\,\overline{t}) ~ \varphi \rightsquigarrow
               [\overline{t}/\overline{x}]t }
 ~~~~
   \inference{}
      { (\MIt^\psi x.\varphi)\,(\In^\kappa t) \rightsquigarrow
        \case^\psi~t~\, [\MIt^\psi \varphi/x]\varphi }
\]
\[  \inference{t \rightsquigarrow t'}{\lambda x.t \rightsquigarrow \lambda x.t'}
 ~~~~
   \inference{r \rightsquigarrow r'}{r\;s \rightsquigarrow r'\;s}
 ~~~~
   \inference{s \rightsquigarrow s'}{r\;s \rightsquigarrow r\;s'}
 ~~~~
   \inference{t_i \rightsquigarrow t_i'}
             {C~t_1\cdots t_i \cdots t_n \rightsquigarrow
              C~t_1\cdots t_i'\cdots t_n }
\]
\[ \inference{\varphi \rightsquigarrow \varphi'}
             {\MIt^\psi x.\varphi \rightsquigarrow \MIt^\psi x.\varphi'}
 ~~~~
   \inference{s \rightsquigarrow s'}
             {\case^\psi s ~\varphi \rightsquigarrow \case^\psi s'\;\varphi }
 ~~~~
   \inference{\varphi \rightsquigarrow \varphi'}
             {\case^\psi s ~\varphi \rightsquigarrow \case^\psi s ~\varphi'}
\]
\[ \fbox{$\varphi \rightsquigarrow \varphi'$}
 ~~~~
   \inference{t_i \rightsquigarrow t_i'}
      { C_1\,\overline{x_1} -> t_1;\cdots
       ;C_i\,\overline{x_i} -> t_i;\cdots
       ;C_n\,\overline{x_n} -> t_n
      ~\rightsquigarrow~
        C_1\,\overline{x_1} -> t_1;\cdots
       ;C_i\,\overline{x_i} -> t_i';\cdots
       ;C_n\,\overline{x_n} -> t_n
      }
\]

\paragraph{Well-formed contexts:}
\[ \fbox{$|- \Sigma$}
 ~~~~
   \inference{}{|- \cdot}
 ~~~~
   \inference{|- \Sigma & \Sigma |- \kappa:\square}
             {|- \Sigma,F:\kappa}
      \big( F\notin\dom(\Sigma) \big)
\]
\[ \inference{|- \Sigma & \Sigma;\cdot |- \sigma:*}
             {|- \Sigma,C:\sigma}
      \big( C\notin\dom(\Sigma) \big)
 ~~~~
   \inference{|- \Sigma & \Sigma;\cdot |- \sigma:*}
             {|- \Sigma,`x:\sigma=t}
      \big( `x\notin\dom(\Sigma) \big)
\]
\[ \fbox{$\Sigma|- \Delta$}
 ~~~~
   \inference{|- \Sigma}{\Sigma |- \cdot}
 ~~~~
   \inference{\Sigma |- \Delta & \Sigma |- \kappa:\square}
             {\Sigma |- \Delta,X^\kappa}
      \big( X\notin\dom(\Delta) \big)
 ~~~~ 
   \inference{\Sigma |- \Delta & \Sigma;\cdot |- \sigma:*}
             {\Sigma |- \Delta,i^\sigma}
      \big( i\notin\dom(\Delta) \big)
\]
\[ \fbox{$\Sigma;\Delta |- \Gamma$}
 ~~~~
   \inference{\Sigma |- \Delta}{\Sigma;\Delta |- \cdot}
 ~~~~
   \inference{\Sigma;\Delta |- \Gamma & \Sigma;\Delta |- A:*}
             {\Sigma;\Delta |- \Gamma,x:A}
      \big( x\notin\dom(\Gamma) \big)
\]
\end{framed}
\caption{Syntax and Reduction rules of Nax}
\label{fig:NaxSyntax}
\end{figure}

\begin{figure}
\begin{framed}
\paragraph{Sorting:}
\[ \fbox{$\Sigma |- \kappa : \square$}
 ~~~~
  \inference[($A$)]{}{\Sigma |- * : \square}
 ~~
   \inference[($R$)]{ \Sigma |- \kappa  : \square
                    & \Sigma |- \kappa' : \square }
                    { \Sigma |- \kappa -> \kappa' : \square }
 ~~
   \inference[($Ri$)]{\Sigma;\cdot |- A : * & \Sigma |- \kappa : \square}
                     {\Sigma |- A -> \kappa : \square}
\]

\paragraph{Kinding:}
$ \fbox{$\Sigma;\Delta |- \sigma : \kappa$ }
 ~~~~
   \inference[($\forall$)]{\Sigma;\Delta, X^\kappa |- \sigma : *}
                          {\Sigma;\Delta |- \forall X . \sigma : *}
 ~~~~
   \inference[($\forall i$)]{\Sigma;\Delta, i^A |- \sigma : *}
                            {\Sigma;\Delta |- \forall i . \sigma : *}
$
\[ \fbox{$\Sigma;\Delta |- T : \kappa$}
 ~~~~
   \inference[($Var$)]{X^\kappa\in\Delta & \Sigma |- \Delta}
                      {\Sigma;\Delta |- X : \kappa}
 ~~~~
   \inference[($TCon$)]{F:\kappa\in\Sigma & \Sigma |- \Delta}
                       {\Sigma;\Delta |- F : \kappa}
 ~~~~
   \inference[($\mu$)]{\Sigma |- \kappa : \square}
                       {\Sigma;\Delta |- \mu^\kappa : \kappa -> \kappa}
\]
\[ \inference[($@$)]{ \Sigma;\Delta |- T : \kappa -> \kappa'
                    & \Sigma;\Delta |- H : \kappa }
                    {\Sigma;\Delta |- T\,H : \kappa'}
 ~~~~
   \inference[($@i$)]{ \Sigma;\Delta |- T : A -> \kappa
                     & \Sigma;\Delta;\cdot |- s : A }
                     {\Sigma;\Delta |- T\,\{s\} : \kappa}
\]
\[ \inference[($->$)]{\Sigma;\Delta |- A : * & \Sigma;\Delta |- B : *}
                     {\Sigma;\Delta |- A -> B : * }
 ~~~~
   \inference[($Conv$)]{ \Sigma;\Delta |- A : \kappa
                       & \Sigma;\Delta |- \kappa = \kappa' : \square }
                       {\Sigma;\Delta |- A : \kappa'}
\]


\paragraph{Typing:}
\[ \fbox{$\Sigma |- Prog : A$}
 ~~~~
   \inference[($\cdot;t$)]{\Sigma;\cdot;\cdot |- t:A}
                          {\Sigma |- \cdot;t : A}
 ~~~~
   \inference[($D$)]{ \Sigma |- D \Rrightarrow \Sigma'
                    & \Sigma' |- \overline{D};\; t : A}
                    {\Sigma |- D,\overline{D};\; t : A}
\]
\[ \fbox{$\Sigma;\Delta;\Gamma |- t : A$}
 ~~~~
   \inference[($=$)]{ \Sigma;\Delta;\Gamma |- t : A
                    & \Sigma;\Delta |- A = B : *}
                    {\Sigma;\Delta;\Gamma |- t : B}
\]
\[ \inference[($:$)]
      { x:\sigma \in \Gamma & \Sigma;\Delta |- A\prec\sigma
      & \Sigma;\Delta |- \Gamma }
      {\Sigma;\Delta;\Gamma |- x:A}
 ~~~~
   \inference[($:i$)]
      { i^\sigma \in \Delta & \Sigma;\Delta |- A\prec\sigma
      & \Sigma;\Delta |- \Gamma }
      {\Sigma;\Delta;\Gamma |- i:A}
\]
\[ \inference[($:C$)]
      { C:\sigma \in \Sigma & \Sigma;\Delta |- A\prec\sigma
      & \Sigma;\Delta |- \Gamma }
      {\Sigma;\Delta;\Gamma |- C:A}
 ~~~~
 \inference[($:`$)]
      { `x:\sigma=t \in \Sigma & \Sigma;\Delta |- A\prec\sigma
      & \Sigma;\Delta |- \Gamma }
      {\Sigma;\Delta;\Gamma |- `x:A}
\]
\[ \inference[($->$$I$)]{\Sigma;\Delta;\Gamma,x:A |- t : B}
                        {\Sigma;\Delta;\Gamma |- \lambda x.t : A -> B}
 ~~~~ ~~~~ ~~~~ ~~~~
   \inference[($->$$E$)]{ \Sigma;\Delta;\Gamma |- r : A -> B
                        & \Sigma;\Delta;\Gamma |- s : A}
                        {\Sigma;\Delta;\Gamma |- r\;s : B}
\]
\[ \inference[(let)]
      { \Sigma;\Delta,\overline{\iota^K};\Gamma |- s : A \\
        \Sigma;\Delta;\Gamma,x:\forall\,\overline{\iota}.A |- t : B }
      {\Sigma;\Delta;\Gamma |- \<let> x=s \<in> t : B }
      \begin{pmatrix} \overline{\iota} \cap \FV(s) = \emptyset \\
                      \overline{\iota} \cap \FV(\Gamma) = \emptyset
      \end{pmatrix}
 ~~~~
   \inference[(In)]
      {}
      {\Sigma;\Delta;\Gamma |- \In^\kappa
        : T(\mu^\kappa T)\,\overline{\tau} -> \mu^\kappa T\;\overline{\tau} }
\]
\[ \inference[(case)]
      { \Sigma;\Delta;\Gamma |- s : T\;\overline\tau
      & \Sigma;\Delta;\Gamma |-^\psi \varphi
                             : \forall\,\overline\iota . T\,\overline\iota
                                                    -> \psi(\overline\iota) }
      {\Sigma;\Delta;\Gamma |- \case^\psi~s~\varphi
                             : \psi(\overline\tau) }
\]
\[ \inference[(MIt)]
      { \Sigma;\Delta,X^\kappa;
               \Gamma,x:\forall\,\overline{\iota'} . X\overline{\iota'}
                                              -> \psi(\overline{\iota'})
           |-^\psi \varphi
           : \forall\,\overline\iota . T\,X\,\overline\iota
                                     -> \psi(\overline\iota) }
      {\Sigma;\Delta;\Gamma
           |- \MIt^\psi ~ x.\varphi
            : \mu^{\kappa}\,T\;\overline\tau -> \psi(\overline\tau) }
      \big( X\notin\FV(\Gamma) \big)
\]
\[ \fbox{$\Sigma;\Delta;\Gamma |-^\psi \varphi : \sigma$}
 ~~~~
   \inference
      { \Sigma|_F = \overline{C_k:\sigma_k}^{\;k=1..n} &
        \overline{
        \begin{matrix}
         \Sigma;\Delta
           |- \overline{A} -> F\,\overline{\tau'}\,\overline\tau\prec\sigma_k
        ~&~
         \Sigma;\Delta;\Gamma,\overline{x:A} |- t : \psi(\overline\tau) 
        \end{matrix} }^{\;k=1..n} }
      { \Sigma;\Delta;\Gamma
           |-^\psi \overline{C_k\;\overline{x} -> t}^{\;k=1..n}
           : F\,\overline{\tau'}\,\overline\tau -> \psi(\overline\tau) }
\]

\paragraph{Extending the Global Context:}
\fbox{$\Sigma |- D \Rrightarrow \Sigma'$}
\[ \inference[($\Sigma,`x$)]
       {\Sigma;\overline{\iota^K};\cdot |- t : A}
       {\Sigma |- `x = t \Rrightarrow \Sigma,`x:\forall\,\overline{\iota}.A=t}
      \big( \overline{\iota} \cap \FV(t) = \emptyset \big)
\]
\[ \inference[($\Sigma,F$)]
      { \overline{ \Sigma,F:\kappa;\;\overline{\iota^K}
                      |- \overline{A} -> F\,\overline\tau :*} }
      { \Sigma |- \mathbf{data}~ F : \kappa ~ \mathbf{where} ~
                  \overline{C : \overline{A} -> F\,\overline\tau }
               ~\Rrightarrow~
                  \Sigma,F:\kappa
                        ,\overline{C:\forall\,\overline{\iota}.\overline{A}
                                                       -> F\,\overline\tau} }
\]
\end{framed}
\caption{Typing rules of Nax}
\label{fig:NaxTyping}
\end{figure}

The Nax language definition is described in \Fig{NaxSyntax} and \Fig{NaxTyping}.

\paragraph{Kinds and their sorting rules}
The kind syntax of Nax is exactly the same as the kind syntax of \Fi.
The sorting rules are the same as \Fi\ except we judge the sorts of kinds
under the global context ($\Sigma$).

\paragraph{Type constructors and their kinding rules}
The type syntax of Nax is similar to \Fi, but different from \Fi in two aspects.

Firstly, polymorphic types are separate out as type schemes in Nax
since the type system of Nax is in flavour of Hindley-Milner to support
type inference (or, reconstruction).

Secondly, there are no type level abstractions and index abstractions in Nax.
Instead of defining type constructors expecting type arguments by abstraction
and index abstraction at type level, Nax supports datatype definitions
($\mathbf{data}~F:\kappa~\mathbf{where}~\dots$) and recursive type operators
($\mu^\kappa$) as language constructs.

TODO explain the kinding rules different from \Fi

\paragraph{Terms and their typing rules}
The term syntax of Nax has four additional term constructs than \Fi:
polymorphic let binding ($\<let>\dots \<in> \dots$),
eliminators for data constructors ($\case^\psi~\dots$),
constructors ($\In^\kappa~\dots$) for recursive types, and
Mendler style iterators ($\MIt^\psi~\dots$).

Polymorphic let bindings in Nax are just the usual polymorphic bindings of
Hindley-Milner type system for generalizing types of local definitions into
type schemes. In Nax, we generalize over term indices as well as types.

Eliminators for data constructors, or $\case$-terms, are also the usual
$\case$-terms for non-indexed types (\ie, when $\psi=\cdot$), but with
the additional index transformer ($\psi$) annotation, which aids
type reconstruction of $\case$-terms for indexed types.
TODO example and explanation for index transformers

The $\In$ constructors for recursive types are as usual.
However, Nax does not provide destructors, or inverse functions of $\In$,
which are often denoted as \textsf{unIn} or \textsf{out}, since we want
to support arbitrary recursive types in a normalizing language.

$\MIt$ TODO.

\paragraph{A Nax program} is a list of declarations followed by a term.
The information about the datatype definitions
in the datatype declarations are captured in the global context ($\Sigma$)
before type checking the term (see ($\Sigma,F$) rule in \Fig{NaxTyping}).
Therefore, each of the sorting, kinding, and typing rules of Nax
(\Fig{NaxTyping}) has an additional global context ($\Sigma$) compared to
the corresponding rules of \Fi\ (\Fig{Fi}).
%% TODO talk about embedding (fwd ref)???


\subsection{Type inference (or, reconstruction)}

