\section{Nax}\label{sec:nax}
\begin{figure}
\begin{framed}
\paragraph{Syntax:}
\begin{align*}
&\text{Kinds}
	& \kappa	&~ ::= ~ * \mid \kappa -> \kappa \mid A -> \kappa
 \\
&\text{Type Constructors}
	& T,H,A,B	&~ ::= ~ X \mid F
			   \mid \mu^\kappa
			   \mid T\;H \mid T\,\{s\}
			   \mid A -> B
 \\
&\text{Type Schemes}
	& \sigma	&~ ::= A
			   \mid \forall X.\sigma
			   \mid \forall i.\sigma
 \\
&\text{Terms}
	& r,s,t		&~ ::= ~ x \mid i
			   \mid \lambda x.t \mid r\;s \mid \Let{x}{s}{t} \\
&	&		&~~~~~
			   \mid \case^\psi~s~\overline{C\;\overline{x} -> t}
			   \mid \In^\kappa
			   \mid \MIt^\psi \varphi 
 \\
&\text{Program}
	& Prog		&~ ::= ~ \overline{D};t
 \\
&\text{Datatype Definitions}
	& D		&~ ::= \mathbf{data}~ F : \overline{K} -> *
                             ~ \mathbf{where} ~
                               \overline{C : \overline{A} -> F\,\overline{\tau}}
 \\
&\text{Datatype Declarations}
	& \overline{D}	&~ ::= \cdot \mid D,\overline{D}
 \\
&\text{Kind Arguments}
	& K		&~ ::= ~ \kappa \mid A
 \\
&\text{Type Arguments}
	& \tau		&~ ::= ~ H \mid \{s\}
 \\
&\text{Type Argument Variables}
	& \iota		&~ ::= ~ X \mid i
 \\
&\text{Index Transformers}
	& \psi		&~ ::= \cdot \mid \overline\iota . B
 \\
&\text{Recursive Equations}
	& \varphi	&~ ::= \overline{x' ~ (C\;\overline{x}) = t}
 \\
&\text{Contexts}
	& \Sigma	&~ ::= ~ \cdot
			   \mid \Sigma, F: \kappa \mid \Sigma, C: \sigma
	& \text{(Global)}
 \\
&	& \Delta	&~ ::= ~ \cdot
			   \mid \Delta, X^\kappa
			   \mid \Delta, i^\sigma
	& \text{(Static)}
 \\
&	& \Gamma	&~ ::= ~ \cdot \mid \Gamma,x:\sigma
	& \text{(Dynamic)}
\end{align*}

\paragraph{Reduction:} \fbox{$t \rightsquigarrow t'$}
\[ \inference{}{(\lambda x.t)\,s \rightsquigarrow [s/x]t}
 ~~~~
   \inference{}
      { \MIt^\psi \varphi\;(\In^\kappa t') \rightsquigarrow
        \case^\psi~t'~\overline{C\;\overline{x} -> [\MIt^\psi \varphi/x']t} }
      \big( \varphi \defeq \overline{x' ~ (C\;\overline{x}) = t}\; \big)
\]
\[ \inference{}
             {\case^\psi (C_i\,\overline{t}) ~
                \{C_1\,\overline{x_1} -> t_1;\;\cdots;\;
                  C_i\,\overline{x_i} -> t_i;\;\cdots;\;
                  C_n\,\overline{x_n} -> t_n \}
              \rightsquigarrow
              [\overline{t}/\overline{x_i}]t_i }
\]
\[  \inference{t \rightsquigarrow t'}{\lambda x.t \rightsquigarrow \lambda x.t'}
 ~~~~
   \inference{r \rightsquigarrow r'}{r\;s \rightsquigarrow r'\;s}
 ~~~~
   \inference{s \rightsquigarrow s'}{r\;s \rightsquigarrow r\;s'}
 ~~~~
   \inference{t_i \to t_i'}
             {C~t_1\cdots t_i \cdots t_n \rightsquigarrow
              C~t_1\cdots t_i'\cdots t_n }
\]
\[ \inference{s \rightsquigarrow s'}
             {\case^\psi s ~\overline{C\;\overline{x} -> t} \rightsquigarrow
              \case^\psi s'~\overline{C\;\overline{x} -> t} }
 ~~~~
   \inference{t_i \rightsquigarrow t_i' }
             {\begin{matrix}
             \phantom{\rightsquigarrow'}
              \case^\psi s ~
                \{C_1\,\overline{x_1} -> t_1;\;\cdots;\;
                  C_i\,\overline{x_i} -> t_i;\;\cdots;\;
                  C_n\,\overline{x_n} -> t_n \} \\
             \rightsquigarrow
              \case^\psi s ~
                \{C_1\,\overline{x_1} -> t_1;\;\cdots;\;
                  C_i\,\overline{x_i} -> t_i';\;\cdots;\;
                  C_n\,\overline{x_n} -> t_n \} \end{matrix} }
\]

\paragraph{Well-formed contexts:}
\[ \fbox{$|- \Sigma$}
 ~~~~
   \inference{}{|- \cdot}
 ~~~~
   \inference{|- \Sigma & \Sigma |- \kappa:\square}
             {|- \Sigma,F:\kappa}
      \big( F\notin\dom(\Sigma) \big)
 ~~~~
   \inference{|- \Sigma & \Sigma;\cdot |- \sigma:*}
             {|- \Sigma,C:\sigma}
      \big( C\notin\dom(\Sigma) \big)
\]
\[ \fbox{$\Sigma|- \Delta$}
 ~~~~
   \inference{|- \Sigma}{\Sigma |- \cdot}
 ~~~~
   \inference{\Sigma |- \Delta & \Sigma |- \kappa:\square}
             {\Sigma |- \Delta,X^\kappa}
      \big( X\notin\dom(\Delta) \big)
 ~~~~ 
   \inference{\Sigma |- \Delta & \Sigma;\cdot |- A:*}
             {\Sigma |- \Delta,i^A}
      \big( i\notin\dom(\Delta) \big)
\]
\[ \fbox{$\Sigma;\Delta |- \Gamma$}
 ~~~~
   \inference{\Sigma |- \Delta}{\Sigma;\Delta |- \cdot}
 ~~~~
   \inference{\Sigma;\Delta |- \Gamma & \Sigma;\Delta |- A:*}
             {\Sigma;\Delta |- \Gamma,x:A}
      \big( x\notin\dom(\Gamma) \big)
\]
\end{framed}
\caption{Syntax and Reduction rules of Nax}
\label{fig:NaxSyntax}
\end{figure}

\begin{figure}
\begin{framed}
\paragraph{Sorting:}
\[ \fbox{$\Sigma |- \kappa : \square$}
 ~~~~
  \inference[($A$)]{}{\Sigma |- *:\square}
 ~~
   \inference[($R$)]{ \Sigma |- \kappa:\square
                    & \Sigma |- \kappa':\square }
                    { \Sigma |- \kappa -> \kappa' : \square }
 ~~
   \inference[($Ri$)]{\Sigma;\cdot |- A:* & \Sigma |- \kappa:\square}
                     {\Sigma |- A -> \kappa : \square}
\]

\paragraph{Kinding:}
\[ \fbox{$\Sigma;\Delta |- T : \kappa$} \]
\[ \inference[($Var$)]{X^\kappa\in\Delta & \Sigma |- \Delta}
                      {\Sigma;\Delta |- X : \kappa}
 ~~~~
   \inference[($TCon$)]{F:\kappa\in\Sigma & \Sigma |- \Delta}
                       {\Sigma;\Delta |- F : \kappa}
 ~~~~
   \inference[($\mu$)]{\Sigma |- \kappa : \square}
                       {\Sigma;\Delta |- \mu^\kappa : \kappa -> \kappa}
\]
\[ \inference[($@$)]{ \Sigma;\Delta |- T : \kappa -> \kappa'
                    & \Sigma;\Delta |- H : \kappa }
                    {\Sigma;\Delta |- T\,H : \kappa'}
 ~~~~
   \inference[($@i$)]{ \Sigma;\Delta |- T : A -> \kappa
                     & \Sigma;\Delta;\cdot |- s : A }
                     {\Sigma;\Delta |- T\,\{s\} : \kappa}
\]
\[ \inference[($->$)]{\Sigma;\Delta |- A : * & \Sigma;\Delta |- B : *}
                     {\Sigma;\Delta |- A -> B : * }
 ~~~~
   \inference[($Conv$)]{ \Sigma;\Delta |- A : \kappa
                       & \Sigma;\Delta |- \kappa = \kappa' : \square }
                       {\Sigma;\Delta |- A : \kappa'}
\]
\[ \fbox{$\Sigma;\Delta |- \sigma : \kappa$ }
 ~~~~
   \inference[($\forall$)]{\Sigma;\Delta, X^\kappa |- \sigma : *}
                          {\Sigma;\Delta |- \forall X . \sigma : *}
 ~~~~
   \inference[($\forall i$)]{\Sigma;\Delta, i^A |- \sigma : *}
                            {\Sigma;\Delta |- \forall i . \sigma : *}
\]


\paragraph{Typing:}
\[ \fbox{$\Sigma |- Prog : A$}
 ~~~~
   \inference[($\cdot;t$)]{\Sigma;\cdot;\cdot |- t:A}
                          {\Sigma |- \cdot;t : A}
 ~~~~
   \inference[($D$)]{ \Sigma |- D \Rrightarrow \Sigma'
                    & \Sigma' |- \overline{D};\; t : A}
                    {\Sigma |- D,\overline{D};\; t : A}
\]
\[ \fbox{$\Sigma;\Delta;\Gamma |- t : A$}
 ~~~~
   \inference[($:$)]
      {x:\sigma \in \Gamma & A\prec\sigma & \Sigma;\Delta |- \Gamma} 
      {\Sigma;\Delta;\Gamma |- x:A}
 ~~~~
   \inference[($:i$)]
      {i^\sigma \in \Delta & A\prec\sigma & \Sigma;\Delta |- \Gamma} 
      {\Sigma;\Delta;\Gamma |- i:A}
\]
\[ \inference[($:C$)]
      {C:\sigma \in \Sigma & A\prec\sigma & \Sigma;\Delta |- \Gamma}
      {\Sigma;\Delta;\Gamma |- C:A}
 ~~~~
   \inference[($=$)]{\Sigma;\Delta;\Gamma |- t : A & \Sigma;\Delta |- A = B : *}
                    {\Sigma;\Delta;\Gamma |- t : B}
\]
\[ \inference[($->$$I$)]{\Sigma;\Delta;\Gamma,x:A |- t : B}
                        {\Sigma;\Delta;\Gamma |- \lambda x.t : A -> B}
 ~~~~ ~~~~ ~~~~ ~~~~
   \inference[($->$$E$)]{ \Sigma;\Delta;\Gamma |- r : A -> B
                        & \Sigma;\Delta;\Gamma |- s : A}
                        {\Sigma;\Delta;\Gamma |- r\;s : B}
\]
\[ \inference[(let)]
      { \Sigma;\Delta,\overline{\iota^K};\Gamma |- s : A \\
        \Sigma;\Delta;\Gamma,x:\forall\,\overline{\iota}.A |- t : B }
      {\Sigma;\Delta;\Gamma |- \Let{x}{s}{t} : B }
      \begin{pmatrix} \overline{\iota} \cap \FV(s) = \emptyset \\
                      \overline{\iota} \cap \FV(\Gamma) = \emptyset
      \end{pmatrix}
 ~~~~
   \inference[(In)]
      {}
      {\Sigma;\Delta;\Gamma |- \In^\kappa
        : T(\mu^\kappa T)\,\overline{\tau} -> \mu^\kappa T\; \overline{\tau} }
\]
\[ \inference[(case)]
      { \Sigma;\Delta;\Gamma |- s : T\;\overline\tau
      & \overline{\begin{matrix}
          C:\sigma \in \Sigma ~&~
          \overline{A} -> \psi(\overline{\tau}) \prec \sigma ~&~
          \Sigma;\Delta;\Gamma,\overline{x:A} |- t : \psi(\overline\tau) 
        \end{matrix} }
      }
      {\Sigma;\Delta;\Gamma |- \case^\psi~s~\overline{C\;\overline{x} -> t}
                             : \psi(\overline\tau) }
      \big( \text{\KYA{pattern is total}} \big)
\]
\[ \inference[(MIt)]
      { \overline{\begin{matrix}
        C:\sigma\in\Sigma ~&~ \overline{A} -> T\,\overline\tau \prec \sigma
      ~&~
        \Sigma;\Delta,X^{\kappa};
        \Gamma
            ,x':\forall\,\overline\iota.X\overline\iota -> \psi(\overline\iota)
            ,\overline{x:A}
          |- t : \psi(\overline\tau) \end{matrix} }
      }
      {\Sigma;\Delta;\Gamma
           |- \MIt^\psi ~ \overline{x' ~ (C\;\overline{x}) = t}
            : \mu^{\kappa}\,T\;\overline\tau -> \psi(\overline\tau) }
      \big( X\notin\FV(\Gamma) \big)
\]

\paragraph{Extending the Global Context:}
\[ \fbox{$\Sigma |- D \Rrightarrow \Sigma'$}
 ~~~~
   \inference[(Ext$\Sigma$)]
      { \Sigma |- \kappa : \square
      & \overline{\Sigma,F:\kappa;\;\overline{\iota^K} |- B:*} }
      { \Sigma |- \mathbf{data}~ F : \kappa ~ \mathbf{where} ~ \overline{C : B}
               ~\Rrightarrow~
                  \Sigma,F:\kappa,\overline{C:\forall\,\overline{\iota}.B} }
\]
\end{framed}
\caption{Typing rules of Nax}
\label{fig:NaxTyping}
\end{figure}

The Nax language definition is described in \Fig{NaxSyntax} and \Fig{NaxTyping}.

\paragraph{The kind syntax} of Nax is exactly the same as
the kind syntax of \Fi.

\paragraph{The type syntax} of Nax is similar to \Fi, but different from
\Fi in two aspects.

Firstly, polymorphic types are separate out as type schemes in Nax
since the type system of Nax is in flavour of Hindley-Milner
to support type inference (or, reconstruction).

Secondly, there are no type level abstractions and index abstractions in Nax.
Instead of defining type constructors expecting type arguments by
abstraction and index abstraction at type level, Nax supports datatype
definitions ($\mathbf{data}~F:\kappa~\mathbf{where}~\dots$) and
recursive type operators ($\mu^\kappa$) as language constructs.

\paragraph{The term syntax} of Nax has four additional term constructs than \Fi:
polymorphic let binding ($\sflet~\dots$),
eliminators for data constructors ($\case^\psi~\dots$),
constructors ($\In^\kappa~\dots$) for recursive types, and
Mendler style iterators ($\MIt^\psi~\dots$).

Polymorphic let bindings in Nax are just the usual polymorphic bindings of
Hindley-Milner type system for generalizing types of local definitions into
type schemes. In Nax, we generalize over term indices as well as types.

Eliminators for data constructors, or $\case$-terms, are also the usual
$\case$-terms for non-indexed types (\ie, when $\psi=\cdot$), but with
the additional index transformer ($\psi$) annotation, which aids
type reconstruction of $\case$-terms for indexed types.
TODO example and explanation for index transformers

The $\In$ constructors for recursive types are as usual.
However, Nax does not provide destructors, or inverse functions of $\In$,
which are often denoted as \textsf{unIn} or \textsf{out}, since we want
to support arbitrary recursive types in a normalizing language.

$\MIt$ TODO.

\paragraph{A Nax program} is a datatype declaration (\ie, a list of datatype
definitions) followed by a term. The information about the datatype definitions
in the datatype declarations are captured in the global context ($\Sigma$)
before type checking the term (see (Ext$\Sigma$) rule in \Fig{NaxTyping}).
Therefore, each of the sorting, kinding, and typing rules of Nax
(\Fig{NaxTyping}) has an additional global context ($\Sigma$) compared to
the corresponding rules of \Fi\ (\Fig{Fi}).
%% TODO talk about embedding (fwd ref)???

