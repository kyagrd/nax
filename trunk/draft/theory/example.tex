
\section{Nax by Example}\label{sec:bg}

In this section we introduce programming in our implementation of Nax by providing
examples. An example usually consists of several parts.

\begin{itemize}
\item Introducing data definitions to describe the data of interest. Recursive
data is introduced in two stages. We must be careful to separate parameters
from indices when using indices to describe static properties of data.

\item Introduce macros, either by explicit defintion, or by automatic derivation
to limit the amount of explicit notation that must be supplied by the programmer.

\item Write a series of definitions that describe how the data is to be
manipulated. Deconstruction of recursive data can only be performed with Mendler style operators
to ensure strong normalization.

\end{itemize}

\subsection{Two level types}\label{2level}
Non recurisive datatypes are introduced by the \verb+data+ declaration.
The data declaration can include arguments. The kind and separation of
arguments into parameters and a indices is infered. For example, 
the three non-recursive data types, \verb+Bool+, \verb+Either+, and 
\verb+Maybe+, familiar to many functional programmers, are introduced
by declaring the kind of the type, and the type of each of the
constructors. This is similar to the way {\small GADT}s are introduced in Haskell.

\vspace*{0.1in}
\begin{tabular}{l|l|l}
\begin{minipage}[t]{.25\linewidth}
{\small
\begin{verbatim}
data Bool: * where
  False: Bool
  True: Bool
\end{verbatim}}
\end{minipage}

& 

\begin{minipage}[t]{.38\linewidth}
{\small
\begin{verbatim}
data Either: * -> * -> * where 
  Left: a -> Either a b
  Right: b -> Either a b
\end{verbatim}}
\end{minipage}

&

\begin{minipage}[t]{.26\linewidth}
{\small
\begin{verbatim}
data Maybe: * -> * where
  Nothing: Maybe a
  Just: a -> Maybe a  
\end{verbatim}}
\end{minipage}
\end{tabular}

\vspace*{0.1in}
Note the kind information
(\verb+Bool: *+) declares \verb+Bool+ to be a type, (\verb+Either: * -> * -> *+) declares
\verb+Either+ to be a type constructor with two type arguments, and 
(\verb+Maybe: * -> *+) declares \verb+Maybe+ to a type constructor
with one type argument.
To introduce a recursive type, we first introduce a non recursive datatype
that uses a parameter where the usual recursive components occur. By design,
normal parameters of the introduced type are written first (\verb+a+ in \verb+L+)
and the parameter to stand for the recursive component is written last
(the \verb+r+ of \verb+Nat+, and the \verb+r+ of \verb+L+).



\vspace*{0.1in}
\begin{tabular}{l|l}
\begin{minipage}[t]{.40\linewidth}
{\small
\begin{verbatim}
-- The fix point of N will 
-- be the natural numbers.

data N: * where
  Zero: N a
  Succ: a -> N a
\end{verbatim}}
\end{minipage}

& 

\begin{minipage}[t]{.40\linewidth}
{\small
\begin{verbatim}
-- The fix point of (L a) will 
-- be the polymorphic lists  

data L: * -> * -> * where
  Nil: L a r
  Cons: a -> r -> L a r
\end{verbatim}}
\end{minipage}
\end{tabular}

\vspace*{0.1in}

A recursive type can be defined as the fixpoint of a (perhaps partially applied)
non recursive type constructor. Thus the traditional natural numbers are typed by \verb+Mu[*] N+
and the traditional lists with components of type \verb+a+ are typed by
\verb+Mu[*] (L a)+.  Note that the \verb+Mu+ type operator is itself specialized with a kind argument inside
square brackets (\verb+[ _ ]+). The fixpoint operator (\verb+Mu[k] f+) is well formed only
if the operand \verb+f+ has kind \verb+k -> j+, in which case the (\verb+Mu[k] f+) type
has kind \verb+j+. Since both \verb+N+ and \verb+(L a)+ have kind \verb+* -> *+,
the types  \verb+Mu[*] N+ and \verb+Mu[*] (L a)+ have kind \verb+*+, i.e. they 
are both types, not type constructors.

\subsection{Creating values}

Values of a particular data type are created by use of constructor functions. For
example \verb+True+ and \verb+False+ are constructor (constants) of type \verb+Bool+.
(\verb+Left 4+) is a value of type (\verb+Either Int a+). Values of recursive types
(i.e. those values with types such as (\verb+Mu[k] f+) are formed by using the \verb+In+
expression. Thus \verb+Nil+ has type \verb+L a+, and \verb+(In[*] Nil)+ has type
(\verb+Mu[*] (L a)+). In general, applying the operator \verb+(In[k])+ injects a term of
type \verb+f(Mu[k] f)+ to the recursive type (\verb+Mu[k] f+). Thus a list of Bool could be
created using the term \verb+(In[*] (Cons True  (In[*] (Cons False  (In[*] Nil)))))+. 
A general rule of thumb, is to apply \verb+In[k]+ to terms of non-recursive type
to get terms of recursive type. Writing programs using two level types, and recursive
injections has definite benefits, but it surely makes programs harder to write. Thus
we have provided Nax with a simple but powerful synonym (macro) facility.

\subsubsection{Synonyms, constructor functions, and derivation}\label{macro}

We may codify that some type is the fixed point of another, once and for all, by introducing
a type synonym (macro).

{\small
\begin{verbatim}
synonym Nat = Mu[*] N
synonym List a = Mu[*] (L a)     
\end{verbatim}}

In a similar manner we can introduce constructor functions that create
recursive values without explicit mention of \verb+In+ at their
call sites (potentially many), but only at their site of defintion (exactly once).

{\small
\begin{verbatim}
zero = In[*] Zero
succ n = In[*] (Succ n)

nil = In[*] Nil
cons x xs = In[*] (Cons x xs)
\end{verbatim}}
This is such a common occurence that recursive synonyms and recursive constructor functions
can be automatically derived. With automatic synonym and constructor derivation
using Nax is both concise ans simple. The clause ``\verb+deriving fixpoint List+"
causes the \verb+synonym+ for \verb+List+ to be automatically defined. It
also defines the constructor functions \verb+nil+ and \verb+cons+.
By convention, the constructor functions are named by dropping the initial
upper-case letter in the name of the non-recursive constructors to lower-case.
To illustrate, we provide side-by-side comparisons
of Haskell and two different uses of Nax.

\vspace*{0.1in}
\begin{tabular}{l|l|l}
{\em Haskell}  & {\em Nax with synonyms} &  {\em Nax with derivation} \\ \hline
\begin{minipage}[t]{.26\linewidth}
{\small
\begin{verbatim}
data List a 
  = Nil 
  | Cons a (List a)
  
x = Cons 3 (Cons 2 Nil)  
\end{verbatim}}
\end{minipage}

& 

\begin{minipage}[t]{.34\linewidth}
{\small
\begin{verbatim}
data L: * -> * -> * where
  Nil: L a r
  Cons: a -> r -> L a r
  
synonym List a = Mu[*] (L a)
nil = In[*] Nil
cons x xs = In[*] (Cons x xs)

x = cons 3 (cons 2 nil)  
\end{verbatim}}
\end{minipage}

&

\begin{minipage}[t]{.26\linewidth}
{\small
\begin{verbatim}
data L: * -> * -> * where
   Nil: L a r
   Cons: a -> r -> L a r
 deriving fixpoint List

x = cons 3 (cons 2 nil)    
\end{verbatim}}
\end{minipage}

\end{tabular}


\subsection{Mendler operators for non-indexed types}
There are no restrictions on what kind of datatypes
can be defined in Nax. There are also no restrictions on the creation
of values. Values are created using constructor functions, and the recursive injection (\verb+In[k]+). 
To ensure strong normalization, analysis of constructed
values has some restrictions. Values of non-recursive types can
be freely analysed using pattern matching. Values of recursive types
must be analysed using one of the Mendler style operators. By design,
we limit pattern matching to values of non-recursive types, by
{\em not} providing any mechanism to match against
the recursive injection (\verb+In[k]+).

To illustrate simple pattern matching over non-recursive types, we 
give a Nax multi-clause defintion for the \verb+not+ function over the (non-recursive) \verb+Bool+ type,
and a function that strips off the \verb+Just+ constructor over the (non-recursive) \verb+Maybe+ type
using a case expression.

\begin{tabular}{l|l}
\begin{minipage}[l]{.42\linewidth}
{\small
\begin{verbatim}
not True = False
not False = True
\end{verbatim}}
\end{minipage}

& 

\begin{minipage}[l]{.50\linewidth}
{\small
\begin{verbatim}

unJust0 x = 
  case x of
   (Just x) -> x
   Nothing  -> 0
\end{verbatim}}
\end{minipage}
\end{tabular}
\vspace*{.1in}

Analysis of recursive data is performed with Mendler style operators. In our
implementation we provide 4 Mendler style operators: \verb+mcata+ (fold or catamorphism),
\verb+mprim+ (primitive recursion), \verb+mhist+ (courses of values recursion), and
\verb+msfcata+ (fold for recursive types with negative occurrences). A Mendler style
operator appears similar to a case expression. It contains patterns, and the variables in
the patterns are scoped over a term, that is executed if tha pattern matches. It differs
from a case expression in that it also introduces additional names (or variables) into
scope. These variables play a role similar in nature to the operations of an abstract
datatype, and provide additional functionality over what can be done using just
case analysis.

For a visual example, compare the \verb+case+ expression
to the \verb+mcata+ expression. In the \verb+case+, each line following the \verb+of+
indicates a possible match of the scrutinee \verb+x+. In the \verb+mcata+,
each equation following the \verb+with+, binds the variable $\newFi{f}$, and
matches the pattern to a value related to the scrutinee \verb+x+.

\vspace*{.1in}
\begin{tabular}{l|l}
\begin{minipage}[t]{.42\linewidth}
\begin{tabbing}
\verb+case+  x \verb+of+ \\
\verb+  + \= \verb+(Cons x xs)+ \= $\to$  \= $e_{2}$ \\
\> \verb+Nil+ \> $\to$  \> $e_{1}$ \\
\end{tabbing}
\end{minipage}

& 

\begin{minipage}[t]{.50\linewidth}
\begin{tabbing}
\verb+mcata+  x \verb+with+ \\
\verb+  + \= \newFi{f} \= \verb+(Cons x xs)+ \= =  \= $e_{1}$ \\
          \> \newFi{f} \> \verb+Nil+         \> =  \> $e_{2}$ \\
\end{tabbing}
\end{minipage}
\end{tabular}
\vspace*{.1in}

The number and type of the additional variables depends upon which Mendler
operation is used to analyze the scrutinee. 
Each clause specifies (a potential) computation in an abstract datatype
depending on whether the pattern matches. For the \verb+mcata+ operator (above)
the abstract datatype has the following form. The scrutinee, \verb+x+,
is a value of some recursive type (\verb+Mu+[*] \verb+T+) for a non-recursive
type constructor \verb+T+. In each clause, the pattern has type (\verb+T r+), for some
abstract type \verb+r+. The additional variable introduced ($\newFi{f}$) is
an operator over the abstract type, \verb+r+, that can safely manipulate values of type \verb+r+.

Different Mendler style operators are implemented by different abstract types. Each abstraction safely
describes a class of provably terminating operations over a recursive type. The number (and type)
of abstract operations differs from Mendler operator to Mendler operator. We give
descriptions of three Mendler operators, their abstractions, and the types of the operators
within the abstraction, below. In each description
the type \verb+ans+ represents the type of the complete Medler operator.

\vspace*{.1in}
\begin{tabular}{l|l|l}
\begin{minipage}[t]{.25\linewidth}
{\small
\begin{tabbing}
\verb+mcata+  x \verb+with+ \\
\verb+  + \= \newFi{f} \= $\text{p}_{i}$ \= =  \= $e_{i}$ \\
\end{tabbing}
$x$: \verb+Mu+[*] T \\
$f$: r $\to$ \text{ans} \\
$p_{i}$: T r \\
$e_{i}$: \text{ans} \\
\\
\begin{verbatim}
mcata phi (In[*] x) 
   = phi (mcata phi) x
\end{verbatim}}   
\end{minipage}
& 

\begin{minipage}[t]{.35\linewidth}
{\small
\begin{tabbing}
\verb+mprim+  x \verb+with+ \\
\verb+  + \= \newFi{f} \= \newFi{cast} \= $\text{p}_{i}$ \= =  \= $e_{i}$ \\
\end{tabbing}
$x$: \verb+Mu+[*] T \\
$f$: r $\to$ \text{ans} \\
$cast$: r $\to$ \verb+Mu+[*] T \\
$p_{i}$: T r \\
$e_{i}$: \text{ans} \\
\\
\begin{verbatim}
mprim phi (In[*] x) 
  = phi (mprim phi) (In[*]) x
\end{verbatim}}  
\end{minipage}

& 

\begin{minipage}[t]{.25\linewidth}
{\small
\begin{tabbing}
\verb+mhist+  x \verb+with+ \\
\verb+  + \= \newFi{f} \= \newFi{project} \= $\text{p}_{i}$ \= =  \= $e_{i}$ \\
\end{tabbing}
$x$: \verb+Mu+[*] T \\
$f$: r $\to$ \text{ans} \\
$project$: r $\to$ T r \\
$p_{i}$: T r \\
$e_{i}$: \text{ans} \\
\begin{verbatim}
mhist phi (In[*] x) 
    = phi (mhist phi) out x
  where out (In[*] x) = x
\end{verbatim}}
\end{minipage}

\end{tabular}
\vspace*{.1in}

A Mendler style operator implements a (provably terminating) recursive function
applied to the scrutinee. The abstract type and its operations ensure termination.
Note that every operation above includes an abstract operator, \verb+f: r -> ans+. 
This operation represents a recursive call in the function defined by the Mendler
operator. Other operations in the other Mendler operations (\verb+cast+ and \verb+project+), support other functionality. The equations
at the bottom of each section provide an operational
understanding of how the operator works. These can be safely ignored until after
we see some examples of how a Mendler operator works in practice.

\vspace*{.1in}
\begin{tabular}{l|l}
\begin{minipage}[l]{.42\linewidth}
{\small
\begin{verbatim}
length y = 
   mcata y with
     len Nil = 0
     len (Cons x xs) = 1 + len xs

tail x = 
  mprim x with
    tl cast Nil = []
    tl cast (Cons y ys) = (cast ys )
\end{verbatim}}
\end{minipage}

& 

\begin{minipage}[l]{.50\linewidth}
{\small
\begin{verbatim}

factorial x =
  mprim x with
    fact cast Zero = succ zero
    fact cast (Succ n) = 
      times (succ (cast n)) (fact n)
                      
fibonocci x =
  mhist x with
    fib out Zero = 1
    fib out (Succ n) = 
        case (out n) of
          Zero -> 1
          (Succ m) -> fib n + fib m 
\end{verbatim}}
\end{minipage}
\end{tabular}
\vspace*{.1in}

The \verb+length+ function uses the simplest kind of recursion where
each recursive call is an application to a direct sub component of the input.
Operationally, \verb+length+ works as follows. The scrutinee, \verb+y+,
has type (\verb+Mu[*] (L a)+), and has the form (\verb+In[*] x+). 
The type of \verb+y+ implies that \verb+x+ must have the form \verb+Nil+ or
(\verb+Cons x xs+).  The  \verb+mcata+ strips off the (\verb+In[*]+) and matches \verb+x+ against
the \verb+Nil+ and (\verb+Cons x xs+) patterns. If the \verb+Nil+ pattern
matches, then \verb+0+ is returned. If the (\verb+Cons x xs+) pattern matches,
\verb+x+ and \verb+xs+ are bound. The abstract type mechanism gives the
pattern (\verb+Cons x xs+) the type (\verb+L a r+), so (\verb+x: a+) and
(\verb+xs: r+) for some abstract type \verb+r+. The abstract operation,
(\verb+len: r -> Int+), can safely be applied to \verb+xs+,
obtaining the length of the tail of the original list. This value
is incremented, and then returned. The \verb+mcata+ abstraction provides a safe way
allow the user to make recursive calls, \verb+len+, but the abstract type, \verb+r+,
limits its use to direct sub components, so termination is guaranteed.

Some recursive functions need direct access, not only to the direct sub components,
but also the original input as well. The Mendler operator \verb+mprim+ provides
a safe, yet abstract mechanism, to support this. The Mendler \verb+mprim+
abstraction provides two abstract operations. The recursive caller with type
(\verb+r -> ans+) and a casting function with type (\verb+r -> Mu[k] T+). The
casting operation allows the user to recover the original type from the abstract
type \verb+r+, but since the recursive caller
only works on the abstract type \verb+r+, the user cannot make a recursive call
on one of these cast values. The functions
\verb+factorial+ (over the natural numbers) and \verb+tail+ (over lists) are both
defined using \verb+mprim+.

Note how in \verb+factorial+ the original input is recovered (in constant time)
by taking the successor of casting the abstract predecessor, \verb+n+. In the
\verb+tail+ function, the abstract tail, \verb+ys+, is cast to get the
answer, and the recursive caller is not even used.

Some recursive functions need direct access, not only to the direct sub components,
but even deeper sub components. The Mendler operator \verb+mhist+ provides
a safe, yet abstract mechanism, to support this. The function \verb+fibonocci+
is a classic example of this kind of recursion.  The Mendler \verb+mhist+
provides two abstract operations. The recursive caller with type
(\verb+r -> ans+) and a projection function with type (\verb+r -> T r+). The projection
allows the programmer to observe the hidden \verb+T+ structure inside a value
of the the abstract type \verb+r+.
In the fibonocci function above, we name the projection \verb+out+. It is used
to observe if the abstract predecessor, \verb+n+, of the input, \verb+x+, is either
zero, or the successor of the second predecessor, \verb+m+, of \verb+x+. Note
how recursive calls are made on the direct predecessor, \verb+n+, and the second  predecessor,
\verb+m+.

Mendler observed that each operator can be defined
by the equation at the bottom of its figure. Each operation can be given
a naive type involving (\verb+Mu[*] T+), but if we instead give it a more abstract type,
abstracting values of type (\verb+Mu[*] T+) into some unknown abstract type \verb+r+, 
one can safely guarantee a certain pattern of use that insures termination.  Operationally
if the operation works for some unknown type \verb+r+
it will certainly also work for the actual type (\verb+Mu[*] T+), but because it cannot
assume that \verb+r+ has any particular structure, the user is forced to use
the abstract operations in carefully proscribed ways.
  
\subsection{Types with static indices}\label{sec:bg:ixty}
Recall that a type can have both parameters and indices, and that indices
can be either types or terms. We define three
types below each with one or more indices. Each example defines a non-recursive type, and
then uses derivation to define synonyms for its fix point and recursive constructor
functions. By convention, in each example, the argument that abstracts the recursive components
is called \verb+r+. By design, arguments appearing before \verb+r+ are understood to be
parameters, and arguments appearing after \verb+r+ are understood to be indices. To define a
recursive type with indices, it is necessary give the argument, \verb+r+,
a higher order kind. I.e. \verb+r+ should take indices as well, since it
abstracts over a recursive type which takes indices.

{\small
\begin{verbatim}
data Nest: (* -> *) -> * -> * where
   Tip: a -> Nest r a
   Fork: r(a,a) -> Nest r a
 deriving fixpoint PowerTree
  
gadt V: * -> (Nat -> *) -> Nat -> * where
  Vnil: V a r {`zero}
  Vcons: a -> r {n} -> V a r {`succ n}
    deriving fixpoint Vector

data Tag = E | O

gadt P: (Tag -> Nat -> *) -> Tag -> Nat -> * where
  Base : P r {E} {In[*] Zero} 
  StepO : r {O} {i} -> P r {E} {`succ i}
  StepE : r {E} {i} -> P r {O} {`succ i}
    deriving fixpoint Proof
\end{verbatim}}

Note, to distinguish type indices from term indices (and to make parsing unambiguous)
we enclose term indices in braces ( \verb+{ _ }+). We also back quote (\verb+`+)
variables in terms that we expect to be bound in the current environment. 
Un-backquoted
variables are taken to be universally quantified. By
backquoting \verb+succ+ we indicate we
want terms which are applications of the successor function, and not some
universally quantified function.

For non-recursive types without parameters, the kind of the fix point
is the same as the kind of the recursive argument \verb+r+. If the the non-recursive
type has parameters, the kind of the fix point will be composed
of the parameters \verb+->+ the kind of the recursive argument \verb+r+. For example,
study the kinds of the fix points for the non-recursive
types declared above in the the table below.

\vspace*{0.1in}
\begin{tabular}{l|c|c|c}
non-recursive type & Nest          & V                    & P                       \\
recursive type     & PowerTree     & Vector               & Proof                   \\ \hline
kind of T          & \verb+* -> *+ & \verb+* -> Nat -> *+ & \verb+Tag -> Nat -> *+  \\ 
kind of \verb+r+   &  \verb+* -> *+ & \verb+Nat -> *+     & \verb+Tag -> Nat -> *+  \\
number parameters  & 0             & 1                    & 0                       \\ 
number indices     & 1 (type)      & 1 (term)             & 2 (term,term)           \\ 

\end{tabular}

\vspace*{0.1in}
Recall, indices are used to track static properties about values
with those types. A well formed (\verb+PowerTree x+) contains a balanced
set of parenthesized binary tuples of elements. The index, \verb+x+,  describes
what kind of vaules are nested in the parentheses. The invariant is that the
number of items nested is always an exact power of 2. A (\verb+Vector a n+) is a list of elements of
type \verb+a+, with length exactly equal to \verb+n+, and a (\verb+Proof E n+) witness that
the natural number \verb+n+ is even, and a (\verb+Proof O m+) witnesses
that the natural number \verb+m+ is odd. Some example value with these types are
given below.

{\small
\begin{verbatim}
tree1: PowerTree Int = (tip 3)
tree2: PowerTree Int = (fork (tip (2, 5)))
tree3: PowerTree Int = (fork (fork (tip ((4, 7), (0, 2)))))

v2: Vector Int {succ (succ zero)} = (vcons 3 (vcons 5 vnil))

p1: P {O} {succ zero} = (stepE base)
p2: P {E} {succ (succ zero)} = (stepO (stepE base))
\end{verbatim}}

Note that in the types of the terms above, the 
indices in braces \verb+{ }+ are ordinary terms (not types). In these example we use 
natural numbers (like \verb+succ (succ zero)+) and elements (\verb+E+ and \verb+O+)
of the two-valued type \verb+Tag+. It is interesting to note that sometimes the
terms are of recursive types (like \verb+Nat+ which is a synonym for \verb+Mu[*] N+),
and some are non-recursive types (like \verb+Tag+).


\subsection{Mendler operators for indexed types}

Mendler operators generalize naturally to indexed types. The key observation
that makes this generalization possible is that the types of the operations
within abstraction have to be generalized to deal with the type indices in
a consistent manner. How this is done is best first explained by example, and
then later abstracted to its full general form.

Recall, a value of type (\verb+PowerTree Int+) is a nested, parenthesized, set
of integers, where the number of integers is an exact power of 2. Consider
a function that adds up all those integers. One wants a function of type
(\verb+PowerTree Int -> Int+). One strategy to writing this function is write
a more general function of type (\verb+PowerTree a -> (a -> Int) -> a+). In
Nax we can do this as follows:

{\small
\begin{verbatim}
genericSum t = mcata { a . (a -> Int) -> Int} t with
                  sum (Tip x)  = \ f -> f x
                  sum (Fork x) = \ f -> sum x (\ (a,b) -> f a + f b)

sumTree t = genericSum t (\ x -> x)
\end{verbatim}

In general, the type of the result of a function over an indexed type,
can depend upon what the index is. Thus, a Mendler operator over a value
with an indexed type, must be type-specialized to that value's index. Different values of the
same general type, will have different indices. After all, the role of
an index is to witness an invariant about the value, and different
values might have different invariants. Capturing this variation is the role of 
the  clause \verb+{a . (a -> Int) -> Int}+ following the key word \verb+mcata+. 
We call such a clause, an {\it index transformer}. In
the same way that the type of the result depends upon the index, the type of
the different components of the abstract datatype implementing the Mendler
operator also depend upon the index. In fact, everything depends upon the index
in a uniform way. The index transformer captures this uniformity.
One cannot abstract over the index tranformer in Nax. Each Mendler operator, over
an indexed type, must be supplied with a concrete clause (inside the braces)
that describe how the results depend upon the index. To see how the tranformer
is used, study the types of the terms in the example.

The scrutinee \verb+t+ has type (\verb+PowerTree a+) which is a synonym for
(\verb+(Mu[* -> *] Nest) a+). The recursive caller
\verb+sum+ has type (\verb+forall a. r a -> (a -> Int) -> Int+), for some abstract
type constructor \verb+r+. Recall \verb+r+ has an index, so it must be a type constructor, not a type. 
The patterns (\verb+Tip x+) and (\verb+Fork x+) have type
(\verb+Nest r a+) and the right hand sides of the equations:
(\verb+\ f -> f x+) and (\verb!\ f -> sum x (\ (a,b) -> f a + f b)!), have type
(\verb+(a -> Int) -> Int+). Note that the dependency of (\verb+(a -> Int) -> Int+) on
the index \verb+a+, appears in both the result type, and the type of the recursive caller.
If we think of an index transformer, like \verb+{a . (a -> Int) -> Int}+, as a function:
$\psi$ \verb+a = (a -> Int) -> Int+, we can succinctly
describe the types of the abstract operations in the \verb+mcata+ Mendler abstraction.
In the table below, we put the general case on the left, and
terms from the \verb+genericSum+ example, that illustrate the general case, on the right.

{\small
\begin{tabbing}
\verb+mcata{+ $\psi$ \verb+}+  $x$ \verb+with+ \\
\verb+  + \= $f$ \= $p_{i}$ \= =  \= $e_{i}$ \\
\end{tabbing}
\vspace*{-.15in}
\begin{tabular}{l|clcl}
$\psi$: \verb+k -> *+          & & \verb+{a . (a -> Int) -> Int}+ & : & (\verb+* -> *+)\\
$T$: \verb+(k -> *) -> k -> *+ & & \verb+Nest+ & : & (\verb+(* -> *) -> * -> *+) \\
$x$: (\verb+Mu+[\verb+k->*+] $T$) a        & & \verb+t+ & : & (\verb+(Mu[* -> *] Nest) a+) \\
$f$: $\forall$ (a:k) . r a $\to$ $\psi$ a & & \verb+sum+ & : & $\forall$ \verb+(a:*). r a -> (a -> Int) -> Int+) \\
$p_{i}$: $T$ r a                 & & (\verb+Fork x+) & : & (\verb+Nest r a+) \\
$e_{i}$: $\psi$ a     & & (\verb+\ f -> f x+) & : & (\verb+(a -> Int) -> Int+) \\
\end{tabular}
}  
\vspace*{0.08in}

The same scheme for \verb+mcata+ generalizes to type constructors with term indices, and with multiple
indices. To illustrate this we give the generic schemes for type constructors
with 2 or 3 indices. In the table the variables \verb+k+, \verb+j+, and \verb+i+,
stand for arbitrary kinds (either kinds for types, like \verb+*+, or kinds for terms, like \verb+Nat+
or \verb+Tag+).

\vspace*{0.05in}
{\small
\begin{tabular}{l|l}
\begin{minipage}[l]{.45\linewidth}
\begin{tabular}{lcl}
$T$ & : & \verb+(k->j->*) -> (k->j->*)+ \\
$\psi$ & : & \verb+k -> j -> *+               \\ 
$x$ & : & (\verb+Mu+[\verb+k->j->*+] $T$) a b        \\
$f$ & : & $\forall$ (a:k)(b:j) . r a b $\to$ $\psi$ a b \\
$p_{i}$ & : & $T$ r a b             \\
$e_{i}$ & : & $\psi$ a b   \\
\end{tabular}
\end{minipage}

&

\begin{minipage}[l]{.45\linewidth}
\begin{tabular}{lcl}
$T$ & : & \verb+(k->j->i->*) -> (k->j->i->*)+ \\
$\psi$ & : & \verb+k -> j -> i -> *+               \\ 
$x$ & : & (\verb+Mu+[\verb+k->j->i->*+] $T$) a b c        \\
$f$ & : & $\forall$ (a:k)(b:j)(c:i) . r a b c $\to$ $\psi$ a b c \\
$p_{i}$ & : & $T$ r a b c            \\
$e_{i}$ & : & $\psi$ a b c   \\
\end{tabular}
\end{minipage}
\end{tabular}
}  
\vspace*{0.05in}

The simplest form of index transformation, is where the transformation
is a constant function. This is the case of the function that computes
the integer length of a natural-number, length-indexed, list
(what we called a \verb+Vector+). Independent of the length the result
is an integer. Such a function has type: \verb+Vector a n -> Int+.
We can write this as follows:

{\small
\begin{verbatim}           
vlen x = mcata{ {i} . Int} x with
  len Vnil = 0
  len (Vcons x xs) = 1 + len xs
\end{verbatim}}


Let's study an example with a more interesting index transformation.
A term with type (\verb+Proof E n+), which is synonymous with the type 
(\verb+Mu[Tag->Nat->*] P E n+),  
witnesses that the term \verb+n+ is even. Can we transform such a term
into a proof that \verb!n+1! is odd? We need to write a function which
has both of the types:\\
\verb+   Proof E n -> Proof O (succ n)  +, and \\
\verb+   Proof O n -> Proof E (succ n)+. \\
We can capture this dependency
by defining the term-level function \verb+flip+, and using an \verb+mcata+
with the index transformer: \verb+{{t} {i} . Proof {`flip t} {`succ i}}+.

{\small
\begin{verbatim}
flip E = O
flip O = E

flop x = 
   mcata {{t} {i} . Proof {`flip t} {`succ i}} x    
     with  f Base = stepE base
           f (StepO p) = (stepE(f p))
           f (StepE p) = stepO(f p)
\end{verbatim}}


For our last term-indexed example, every length-indexed list has a length
which is either even or odd. We can witness this fact by writing a function with type:
\verb+Vector a n -> Either (Even n) (Odd n)+. Here, \verb+Even+ and \verb+Odd+
are synonyms for particular kinds of \verb+Proof+. To write this function
we need the index transformation: \verb+{ {n} . Either (Even {n}) (Odd {n})}+.

{\small
\begin{verbatim}    
synonym Even x = Proof {E} {x}
synonym Odd  x = Proof {O} {x}

polarity x = 
  mcata { {n} . Either (Even {n}) (Odd {n})} x with
    pol Vnil = Left base
    pol (Vcons x xs) = 
         case pol xs of
           Left p -> Right(stepE p)
           Right p -> Left(stepO p)  
\end{verbatim}}

\subsection{Recursive types of unrestricted polarity but restricted elimination}
\label{sec:bg:recty}
In Nax, programmers can define recursive data structures with both positive and 
negative polarity.  The classic example is a datatype
encoding the syntax of $\lambda$-calculus, which uses higher-order abstract syntax (HOAS).
Terms in the $\lambda$-calculus are either variables, applications, or abstractions.
In a HOAS representation, one uses Nax functions to encode abstractions. We
give a two level description for recursive $\lambda$-calculus \verb+Term+s, by taking
the fixpoint of the non-recursive \verb+Lam+ data type. 

{\small
\begin{verbatim}    
data Lam: * -> * where
   App: r -> r -> Lam r
   Abs: (r -> r) -> Lam r
 deriving fixpoint Term
 
apply = abs (\ f -> abs (\ x -> app f x)) 
\end{verbatim}}
Note that we don't need to include a constructor for variables,
as variables are represented by Nax variables, bound by Nax
functions. For example the lamdba term: ($\lambda f . \lambda x . f\; x$)
is encoded by the Nax term \verb+apply+ above.

Note also, the recursive constructor: \verb+abs: (Term -> Term) -> Term+,
introduced by the \verb+deriving fixpoint+ clause,
has a negative occurrence of the type \verb+Term+. In a language with
unrestricted analysis, such a type could lead to non-terminating
computations. The Mendler \verb+mcata+ and \verb+mprim+ operators
limit the analysis of such types in a manner that precludes non-terminating
computations. The Mendler operator, \verb+mhist+, is too expressive
to exclude non-terminating computations, and must be restricted to recursive
datatypes with no negative occurences.





\subsection{Mendler style iteration and recursion combinators}
\label{sec:bg:Mendler}


\section{Examples}\label{sec:examples}

