\section{\Fi}
\label{sec:Fi}
System \Fi\ is a higher-order polymorphic lambda calculus with term indices.
In other words, System \Fi\ is an extension of System \Fw\ by term indices.
The complete syntax and rules of \Fi\ are described in \Fig{Fi} and \Fig{eqFi}.
The syntax and rules highlighted by \newFi{\text{grey boxes}} are the extensions
new to \Fi\, which are not part of \Fw. That is, the system we get excluding
all the grey boxes from \Fig{Fi} and \Fig{eqFi} is a version of \Fw.
In particular, it is a version of \Fw\ with Curry style terms. That is,
term level lambda bindings are unannotated ($\lambda x.t$), and
type abstraction ($\forall I$) and application ($\forall E$) are implicit.
Types remain Church style as usual. That is, type level lambda bindings are
annotated by kinds ($\lambda X^\kappa.F$). We expect readers to be familiar
to \Fw\ and focus on describing new constructs of \Fi\ in grey boxes.

\begin{figure}
\paragraph{Syntax:}
\begin{align*}
&\text{Kinds}
 	& \kappa		&~ ::= ~ *
				\mid \kappa -> \kappa
				\mid \newFi{A -> \kappa}
\\
%% &\text{Type Schemes}
%% 	& \sigma	&~ ::= ~ A
%% 			\mid (x:A) -> \sigma
%% \\
%% &\text{Kind Schemes}
%% 	& \delta	&~ ::= ~ \kappa
%% 			\mid (x:A) -> \delta
%%			\mid (X:\kappa) -> \delta
%% \\
&\text{Type Constructors}
	& A,B,F,G		&~ ::= ~ X
				\mid \lambda X^\kappa.F
				\mid \newFi{\lambda x^A.F}
				\mid F\,G
				\mid \newFi{F\,\{s\}}
				\mid A -> B
				\mid \forall X^\kappa . B
				\mid \newFi{\forall x^A . B}
\\
&\text{Terms}
	& r,s,t			&~ ::= ~ x \mid \lambda x.t \mid r\;s
\\
&\text{Contexts}
	& \Delta		&~ ::= ~ \cdot
				\mid \Delta, x : A
				\mid \Delta, X^\kappa
				\mid \newFi{\Delta, x^A}
				\mid \newFi{\Delta, x :: A}
\end{align*}

\noindent
\begin{minipage}{.45\textwidth}
\paragraph{Well-formed contexts:}
\[\!\!\!\!\!\!\!\!
   \inference{}{|- \cdot} \]
\[\!\!\!\!\!\!\!\!
   \inference{|- \Delta & \Delta |- A:*}{|- \Delta,x:A}
 ~~
   \inference{|- \Delta & \Delta |- \kappa:\square}{|- \Delta,X^\kappa}
\]
\[\!\!\!\!\!\!\!\! \newFi{
   \inference{|- \Delta & \Delta |- A:*}{|- \Delta,x^A} }
 ~~ \newFi{
   \inference{|- \Delta & \Delta |- A:*}{|- \Delta,x::A} }
\]
\end{minipage}~~
\newFi{\begin{minipage}{.2\textwidth}
\textbf{Context lifting:}\vspace*{-.5em}
\begin{align*}
\hat\cdot &=~ \cdot \\
\widehat{\Delta,x:A} &=~ \hat\Delta \\
\widehat{\Delta,X^\kappa} &=~ \hat\Delta,X^\kappa \\
\widehat{\Delta,x^A} &=~ \hat\Delta,x::A \\
\widehat{\Delta,x::A} &=~ \hat\Delta,x::A
\end{align*}
\end{minipage}}~~
\begin{minipage}{.2\textwidth}
\paragraph{Sorting:}
\[ \inference[($A$)]{}{\Delta |- *:\square} \]
\[ \inference[($R$)]{\Delta |- \kappa:\square & \Delta |- \kappa':\square}
                    {\Delta |- \kappa -> \kappa' : \square}
\]\vspace*{.2em}
\[ \newFi{
   \inference[($Ri$)]{\Delta |- A:* & \Delta |- \kappa:\square}
                     {\Delta |- A -> \kappa : \square} }
\]
\end{minipage}

\paragraph{Kinding:}
\[ \inference[($Var$)]{X^\kappa\in\Delta & |- \Delta}
                       {\Delta |- X : \kappa}
 ~~~~ \newFi{
   \inference[($Conv$)]{ \Delta |- A : \kappa
                       & \Delta |- \kappa = \kappa' : \square }
                       {\Delta |- A : \kappa'} }
\]
\[
   \inference[($\lambda$)]{\Delta,X^\kappa |- F : \kappa}
                          {\Delta |- \lambda X^\kappa.F : \kappa->\kappa}
 ~~~~
 \inference[($@$)]{ \Delta |- F : \kappa -> \kappa'
                      & \Delta |- G : \kappa }
                      {\Delta |- F\,G : \kappa'}
\]
\[ \newFi{
   \inference[($\lambda i$)]{\Delta,x^A |- F : \kappa}
                            {\Delta |- \lambda x^A.F : A->\kappa} }
 ~~~~ \newFi{
   \inference[($@i$)]{ \Delta |- F : A -> \kappa
                     & \hat\Delta |- s : A }
                     {\Delta |- F\,\{s\} : \kappa} }
\]
\[ \inference[($->$)]{\Delta |- A : * & \Delta |- B : *}
                     {\Delta |- A -> B : * }
 ~~~~
   \inference[($\forall$)]{\Delta, X^\kappa |- B : *}
                            {\Delta |- \forall X^\kappa . B : *}
 ~~~~ \newFi{
   \inference[($\forall i$)]{\Delta, x^A |- B : *}
                              {\Delta |- \forall x^A . B : *} }
\]

\paragraph{Typing:}
\[ \inference[($:$)]{x:A \in \Delta & |- \Delta} 
                    {\Delta |- x:A}
 ~~~~ \newFi{
   \inference[($::$)]{x::A \in \Delta & |- \Delta} 
                     {\Delta |- x:A} }
 ~~~~
   \inference[($=$)]{\Delta |- t :A & \Delta |- A = B : *}
                    {\Delta |- t : B}
\]
\[
   \inference[($->$$I$)]{\Delta, x:A |- t : B}
                        {\Delta |- \lambda x.t : A -> B}
 ~~~~
   \inference[($->$$E$)]{\Delta |- r : A -> B & \Delta |- s : A}
                        {\Delta |- r\;s : B}
\]
\[ \inference[($\forall I$)]{\Delta, X^\kappa |- t : B}
                            {\Delta |- t : \forall X^\kappa.B}
 ~~~~
   \inference[($\forall E$)]{ \Delta |- t : \forall X^\kappa.B
                            & \Delta |- G:\kappa }
                            {\Delta |- t : [G/X]B}
\]
\[ \newFi{
   \inference[($\forall I i$)]{\Delta, x^A |- t : B}
                              {\Delta |- t : \forall x^A.B} }
 ~~~~ \newFi{
   \inference[($\forall E i$)]{\Delta |- t : \forall x^A.B & \hat\Delta |- s:A}
                              {\Delta |- t : [s/x]B} }
\]
\caption{Syntax and Typing rules of \Fi}
\label{fig:Fi}
\end{figure}

\begin{figure}
\paragraph{Kind equality:}
\[ \inference{}{\Delta |- * = *:\square}
 ~~~~
   \inference{ \Delta |- \kappa_1 = \kappa_1' : \square
             & \Delta |- \kappa_2 = \kappa_2' : \square }
             {\Delta |- \kappa_1 -> \kappa_2 = \kappa_1' -> \kappa_2' : \square}
 ~~~~ \newFi{
   \inference{\Delta |- A=A':* & \Delta |- \kappa=\kappa':\square}
             {\Delta |- A -> \kappa = A' -> \kappa' : \square} }
\]
\[ \inference{\Delta |- \kappa=\kappa':\square}
             {\Delta |- \kappa'=\kappa:\square}
 ~~~~
   \inference{ \Delta |- \kappa =\kappa' :\square
             & \Delta |- \kappa'=\kappa'':\square}
             {\Delta |- \kappa=\kappa'':\square}
\]
~\\
\paragraph{Type constructor equality:}
\[ \inference{\Delta |- X:\kappa }{\Delta |- X=X:\kappa}
 ~~~~
   \inference{\Delta,X^\kappa |- F:\kappa & \Delta |- G:\kappa}
             {\Delta |- (\lambda X^\kappa.F)\,G = [G/X]F:\kappa'}
 ~~~~ \newFi{
   \inference{\Delta,x^A |- F:\kappa & \hat\Delta |- s:A}
             {\Delta |- (\lambda x^A.F)\,\{s\} = [s/x]F:\kappa} }
\]
\[ \inference{\Delta,X^\kappa |- F=F' : \kappa'}
             {\Delta |- \lambda X^\kappa.F=\lambda X^\kappa.F':\kappa-> \kappa'}
 ~~~~
   \inference{\Delta |- F=F':\kappa->\kappa' & \Delta |- G=G':\kappa}
             {\Delta |- F\,G = F'\,G' : \kappa'}
\]
 ~~~~
\[ \newFi{
   \inference{\Delta,x^A |- F=F' : \kappa}
             {\Delta |- \lambda x^A.F=\lambda x^A.F' : A -> \kappa} }
 ~~~~ \newFi{
   \inference{\Delta |- F=F':A->\kappa & \hat\Delta |- s=s':A}
             {\Delta |- F\,\{s\} = F'\,\{s'\} : \kappa} }
\]
\[ \inference{\Delta |- A=A':* & \Delta |- B=B':*}{\Delta |- A-> B=A'-> B':*}
 ~~~~
   \inference{\Delta,X^\kappa |- B=B':*}
             {\Delta |- \forall X^\kappa.B=\forall X^\kappa.B':*}
 ~~~~ \newFi{
   \inference{\Delta,x^A |- B=B':*}
             {\Delta |- \forall x^A.B=\forall x^A.B':*} }
\]
\[ \inference{\Delta |- F = F' : \kappa}{\Delta |- F' = F : \kappa}
 ~~~~
   \inference{\Delta |- F = F' : \kappa & \Delta |- F' = F'' : \kappa}
             {\Delta |- F = F'' : \kappa}
\]
~\\
\paragraph{Term equality:}
\[ \inference{\Delta |- x:A}{\Delta |- x=x:A}
 ~~~~
   \inference{\Delta,x:A |- t:B & \Delta |- s:A}
             {\Delta |- (\lambda x.t)s=[s/x]t : B}
 ~~~~
   \inference{\Delta |- r=r':A-> B & \Delta |- s=s':A}{\Delta |- r\;s=r'\;s':B}
\]
\[ \inference{\Delta |- t=t':A}{\Delta |- t'=t:A}
 ~~~~
   \inference{\Delta |- t=t':A & \Delta |- t'=t'':A}{\Delta |- t=t'':A}
\]
~\\
\paragraph{Reduction:}
$  \inference{}{(\lambda x.t)\,s \rightsquigarrow [s/x]t}
 ~~~~
   \inference{t \rightsquigarrow t'}{\lambda x.t \rightsquigarrow \lambda x.t'}
 ~~~~
   \inference{r \rightsquigarrow r'}{r\;s \rightsquigarrow r'\;s}
 ~~~~
   \inference{s \rightsquigarrow s'}{r\;s \rightsquigarrow r\;s'} $

\caption{Equality rules and Reduction rules for \Fi}
\label{fig:eqFi}
\end{figure}


We extend kind syntax by an indexed arrow kind \newFi{A -> \kappa}.
%% example?

The sorting rule \newFi{(Ri)}
specifies when such an indexed arrow kind is well-formed:
$A -> \kappa$ is well-formed under the typing context $\Delta$
when $A$ is a well-formed type under $\Delta$
and $\kappa$ is a well-formed kind under $\Delta$.

We extend the type syntax by several constructs.
\newFi{\lambda x^A.F} is type level lambda abstraction over an index.

\newFi{F\,\{s\}} is a type level index application.

\newFi{\forall x^A . B} is an index polymorphic type.

We need to extend the syntax of typing context accordingly.
\newFi{\Delta, x^A} is a typing context $\Delta$ extended by
an index variable binding $x^A$. The index bindings are introduced from
$\lambda x^A.F$ by the kinding rule \newFi{(\lambda i)}.
Intuitively $x^A$ means that $x$ can only be used at type level,
but not at term level. In contrast, the ordinary term binding $x:A$
\newFi{\Delta, x :: A} is a typing contrext $\Delta$ extend ed by
multiple purpose variable binding $x::A$. Intuitively $x::A$ amounts to
having both $x^A$ and $x:A$. That is, we can use $x$ at both type and
term level when we have $x::A$ in the context.
TODO
% when we go inside curly brackets to type check the argument term ($s$) of
% an index application ($F\,\{s\}$). This property of $x::A$ is captured
TODO

kinding rules
\newFi{(Conv)}
\newFi{(\lambda i)}
\newFi{(@i)}
\newFi{(\forall i)}

typing rules
\newFi{(::)}
\newFi{(\forall I i)}
\newFi{(\forall E i)}



%% \Fi 
%%, but less powerful than
% the Calculus of Constructions (CC). That is, all typeable terms in \Fi\ are
% typeable terms in \Fi\ and all typable terms in \Fi\ are typable terms in CC.
% We can show normalization of \Fi\ by straitforward translation from
%% Since CC is normalizing, normalization of \Fi\ is automatic.






\subsection{\Fi\ in regards to PTS}
We describe \Fw\ and CC as an instances of the Pure Type System (PTS),
and then describe \Fi\ as an extension of \Fw\ and a restriction of CC.

%% \begin{figure}
\[\text{Syntax}~~~~~ a,b,A,B ::= s \mid x \mid b~a \mid \lambda x:A.B
                                   \mid (x:A) -> B \]
\[\text{Typing}~~~~~\]
\[
 \inference[Ax]{|-\Gamma & (s_1,s_2)\in\calA}{\Gamma |- s_1 : s_2}
 ~~~~
 \inference[Var]{|-\Gamma & (x:A)\in\Gamma}{\Gamma |- x:A} 
 ~~~~
 \inference[Conv]{\Gamma |- a:A & \Gamma |- B:s & A=B}{\Gamma |- a:B}
\]
\[
 \inference[Pi]{\Gamma |- A:s_1 & \Gamma,x:A |- B:s_2 & (s_1,s_2,s_3)\in\calR}
               {\Gamma |- (x:A)-> B : s_3}
\]
\[
 \inference[Lam]{\Gamma |- (x:A)-> B : s & \Gamma,x:A |- b:B}
                {\Gamma |- \lambda x:A.b : (x:A)-> B}
 ~~~~
 \inference[App]{\Gamma |- b:(x:A)-> B & \Gamma |- a:A}{\Gamma |- b\;a:[a/x]B}
\]

\[\text{Context}~~~~~
 \inference{}{|-\cdot}
 ~~~~
 \inference{x\notin\dom(\Gamma) & |-\Gamma}{|-\Gamma,x:A}
\]
%% \caption{Pure Type System}
%% \label{fig:PTSrule}
%% \end{figure}

PTS is instantiated by the triple $(\calS,\calA,\calR)$ where
$\calS$ is the set of sorts ($s,s_1,s_2,s_3\in\calS$ in the PTS typing rules),
$\calA\subset\calS\times\calS$ is the set of axioms (used in Ax rule), and
$\calR\subset\calS\times\calS\times\calS$ is the set of rules (used in Pi rule).

\Fw\ is an instance of PTS where
\[\calS=\{*,\square\}
  ~~~~~
  \calA=\{(*,\square)\}
  ~~~~~
  \calR=\{(*,*,*),(\square,*,*),(\square,\square,\square)\}
\]
Each element in $\calR$ stands for certain ability of dependency:
$(*,*,*)$ enables functions at the value level
(values depending on values)
$(\square,*,*)$ enables parametric polymorphism
(values depending on types)
$(\square,\square,\square)$ enables functions at the type level
(types depending on types).

CC extends \Fw\ with one additional rule
$(*,\square,\square)$, which enables types depending on values
(\emph{dependent types}, or, types with \emph{value dependency}).
That is, CC is an instance of PTS where
\[\calS=\{*,\square\}
  ~~~~~
  \calA=\{(*,\square)\}
  ~~~~~
  \calR=\{(*,*,*),(\square,*,*),(\square,\square,\square)
         ,(*,\square,\square)\}\]

\KYA{ below is what I understood marcelo maybe wrong}
\Fi\ is also an extension of \Fw\, but a restriction of CC.  Instead of
allowing full value dependency (given by $(*,\square,\square)$ in CC),
we only allow value dependency partially via special syntax as follows:
\[
 \inference[Let]{\Gamma |- a:A & \Gamma, x:A |- b:B}
                {\Gamma |- \mathsf{let}~x:A=a~\mathsf{in}~b : [a/x]B}
\]
\[
 \inference[Pi$_{(*,\square,\square)}$]
     {\Gamma |- A:* & \Gamma |- B:\square}
     {\Gamma |- (x:A)-> B : \square}
\]
The Let rule can be derived in CC by combining Pi rule and App rule.  However,
we only allow value dependency $(*,\square,\square)$ in this limited form,
but disallow arbitrary lambda abstractions to form value dependent functions
by limiting the Pi rule on $(*,\square,\square)$.

Normalization of \Fi\ is automatic since \Fi\ is a strict subset of CC,
which is known to be strongly normalizing.

\subsection{examples}
For better intuition, let us see some examples what we can express and
what we cannot in \Fi.
\newcommand{\List}{\mathsf{List}}
\newcommand{\Vect}{\mathsf{Vec}}

\paragraph{Ordinary (parametric) polymorphism} is obviously possible,
since \Fi\ is an extension of \Fw. Note, $\Gamma |- (x:*) -> B : *$
where $\Gamma,x:* |- B:*$, since $(\square,\star,\star) \in\calR$.
If you'd prefer \Fw\-like syntax we could use alternative notation
$\forall(x:*).B$ for $(x:*) -> B$. With the support of ordinary polymorphism,
we can write functions over polymorphic lists as follows
where $\List : * -> *$ (details of the function body is omitted):
\[ (\Lambda a:*.\lambda x:\List~a. \cdots) : \forall(a:*).\List~a -> \List~a \]
The uppercase lambda ($\Lambda$) is an alternative notation in flavour of \Fw
for the ordinary lowercase lambda ($\lambda$)
More generally, we can be polymorphic over any \Fw\ kind such as $* -> *$.
For instance, $\forall(x:* -> *).B$.

\paragraph{Polymorphism over indexed values} is also possible.
Note, $\Gamma |- (x:A) -> B : *$ where $\Gamma |- A:*$ and $\Gamma,x:A |- B:*$.
With the support of polymorphism over indexed values, we can write functions
over type indexed lists as follows (details of the function body is omitted)
where $\Vect : \Nat -> *$:
\[
(\Lambda n:\Nat.\lambda x:\Vect~n. \cdots) : \forall(n:\Nat).\Vect~n -> \Vect~n 
\]
More generally, $\Gamma |- (x:\ka) -> B : *$ where $\Gamma, x:\ka |- B:*$
can be written as $\forall(x:\ka).B$ in flavour of \Fw.

We call the (parametric) polymorphism of \Fi, which includes
both the ordinary polymorphism of \Fw\ and the polymorphism involving indices,
\emph{generalized polymorphism}.

To be more precise, this is not exactly the polymorphism we would expect
in functional languages with indexed types (\eg, GADT extension in Haskell),
since we usually expect index variables like $n$ bound by $\Lambda$ to be
erasable (or, computationally irrelevant) in contrast to the variables bound
by ordinary $\lambda$. Here in PTS, which is in Church style, $n$ can also
appear as computationally relevant in the function body. Unlike ordinary
polymorphism where the polymorphic variable is a type variable that cannot
live in value world, nothing prevents the index variables like $n$ to be used
in the value level. This is what Abel and Matthes in CSL 04 paper meant that
the Church style becomes richer than the Curry style as we move from \Fw\ to
a dependently typed setting such as CC. I think it is better to formalize
in Curry style if we want to capture the erasure property of polymorphism
correctly in \Fi.

\paragraph{Large eliminations resulting in constant kinds} are possible.
Large eliminations are type computations depending on values.  For example,
computing an $n$-ary boolean function type given a natural number index $n$
can be defined as follows (details of the function body is omitted):
\[
(\lambda n:\Nat. \stackrel{n}{\overbrace{\Bool-> \cdots-> \Bool}}\;\, -> \Bool)
  : (n:\Nat) -> *
\]
Note, the resulting kind ($*$) is constant, being independent of $n$.
So, the example above is a large elimination resulting in a constant kind,
which does not involve any kind computation.

However, large eliminations resulting in varying kinds that depend on
input index values are not possible, unless you use the let syntax to make
the input index values available (then, the input indices do not vary
at runtime after all). For example, large elimination computing an $n$-ary
type constructor given a natural number index $n$ line the following
is \emph{not} possible to define in \Fi:
\[
(\lambda n:\Nat. \cdots \cdots)
  : (n:Nat) -> \,\;\stackrel{n}{\overbrace{* -> \cdots -> *}}\;\, -> *
\]
This restriction is to make the kind inference doable.

