\section{System \Fi}
\label{sec:Fi}
System \Fi\ is a higher-order polymorphic lambda calculus with term indices.
In other words, System \Fi\ is an extension of System \Fw\ by term indices.
The complete syntax and rules of \Fi\ are described in \Fig{Fi} and \Fig{eqFi}.
The syntax and rules highlighted by \newFi{\text{grey boxes}} are the extensions
new to \Fi, which are not originally part of \Fw. That is, the system we obtain
by excluding all the grey boxes from \Fig{Fi} and \Fig{eqFi} is a version of
\Fw. In particular, it is a version of \Fw\ with Curry style terms. That is,
term level abstractions are unannotated ($\lambda x.t$), and type generalization
($\forall I$) and type instantiation ($\forall E$) are implicit at term level.
Types remain Church style as usual. That is, type level abstractions are
annotated by kinds ($\lambda X^\kappa.F$). We expect readers to be familiar to
\Fw\ and focus on describing new constructs of \Fi, which are in grey boxes.

\begin{figure}
\begin{framed}
\paragraph{Syntax:}
\begin{align*}
\!\!\!\!\!\!\!\!&\text{Kinds}
 	& \kappa		&~ ::= ~ *
				\mid \kappa -> \kappa
				\mid \newFi{A -> \kappa}
\\
\!\!\!\!\!\!\!\!&\text{Type Constructors}
	& A,B,F,G		&~ ::= ~ X
				\mid \lambda X^\kappa.F
				\mid \newFi{\lambda x^A.F}
				\mid F\,G
				\mid \newFi{F\,\{s\}}
				\mid A -> B
				\mid \forall X^\kappa . B
				\mid \newFi{\forall x^A . B}
\\
\!\!\!\!\!\!\!\!&\text{Terms}
	& r,s,t			&~ ::= ~ x \mid \lambda x.t \mid r\;s
\\
\!\!\!\!\!\!\!\!&\text{Contexts}
	& \Delta		&~ ::= ~ \cdot
				\mid \Delta, x : A
				\mid \Delta, X^\kappa
				\mid \newFi{\Delta, x^A}
\end{align*}
\newFi{ 
\begin{minipage}{\textwidth}\vspace*{-1em}
\begin{align*}\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!
\textbf{Context lifting:}~~~~~~~~~
& \hat\cdot                  = \cdot                &~~~&
  \widehat{\Delta,x:A}       = \hat\Delta           &~~~&
  \widehat{\Delta,X^\kappa}  = \hat\Delta,X^\kappa  &~~~&
  \widehat{\Delta,x^A}       = \hat\Delta,x^A
\end{align*}
\end{minipage} }

\paragraph{Well-formed contexts:} ~~~~
$  \inference{}{|- \cdot}
 ~~~~ ~~~~ ~~~~
   \inference{|- \Delta & \Delta |- A:*}
             {|- \Delta,x:A}
      \big( x\notin\dom(\Delta) \big)
$
\[
   \inference{|- \Delta & \Delta |- \kappa:\square}
             {|- \Delta,X^\kappa}
      \big( X\notin\dom(\Delta) \big)
 ~~~~ \newFi{
   \inference{|- \Delta & \cdot |- A:*}
             {|- \Delta,x^A}
      \big( x\notin\dom(\Delta) \big) }
\]

\paragraph{Sorting:}
$  \inference[($A$)]{}{\Delta |- *:\square}
 ~~~~
   \inference[($R$)]{\Delta |- \kappa:\square & \Delta |- \kappa':\square}
                    {\Delta |- \kappa -> \kappa' : \square}
 ~~~~
   \newFi{
   \inference[($Ri$)]{\cdot |- A:* & \Delta |- \kappa:\square}
                     {\Delta |- A -> \kappa : \square} }
$

\paragraph{Kinding:}
\[ \inference[($Var$)]{X^\kappa\in\Delta & |- \Delta}
                       {\Delta |- X : \kappa}
 ~~~~ \newFi{
   \inference[($Conv$)]{ \Delta |- A : \kappa
                       & \Delta |- \kappa = \kappa' : \square }
                       {\Delta |- A : \kappa'} }
\]
\[
   \inference[($\lambda$)]{\Delta,X^\kappa |- F : \kappa'}
                          {\Delta |- \lambda X^\kappa.F : \kappa->\kappa'}
 ~~~~
   \inference[($@$)]{ \Delta |- F : \kappa -> \kappa'
                    & \Delta |- G : \kappa }
                    {\Delta |- F\,G : \kappa'}
\]
\[ \newFi{
   \inference[($\lambda i$)]{\Delta,x^A |- F : \kappa}
                            {\Delta |- \lambda x^A.F : A->\kappa} }
 ~~~~ \newFi{
   \inference[($@i$)]{ \Delta |- F : A -> \kappa
                     & \hat\Delta |- s : A }
                     {\Delta |- F\,\{s\} : \kappa} }
\]
\[ \inference[($->$)]{\Delta |- A : * & \Delta |- B : *}
                     {\Delta |- A -> B : * }
 ~~~~
   \inference[($\forall$)]{\Delta, X^\kappa |- B : *}
                          {\Delta |- \forall X^\kappa . B : *}
 ~~~~ \newFi{
   \inference[($\forall i$)]{\Delta, x^A |- B : *}
                            {\Delta |- \forall x^A . B : *} }
\]

\paragraph{Typing:}
\[ \inference[($:$)]{x:A \in \Delta & |- \Delta} 
                    {\Delta |- x:A}
 ~~~~ \newFi{
   \inference[($:'$)]{x^A \in \Delta & |- \Delta} 
                     {\Delta |- x:A} }
 ~~~~
   \inference[($=$)]{\Delta |- t :A & \Delta |- A = B : *}
                    {\Delta |- t : B}
\]
\[
   \inference[($->$$I$)]{\Delta, x:A |- t : B}
                        {\Delta |- \lambda x.t : A -> B}
 ~~~~ ~~~~ ~~~~ ~~~~
   \inference[($->$$E$)]{\Delta |- r : A -> B & \Delta |- s : A}
                        {\Delta |- r\;s : B}
\]
\[ \inference[($\forall I$)]{\Delta, X^\kappa |- t : B}
                            {\Delta |- t : \forall X^\kappa.B}
 ~~~~ ~~~~ ~~~~ ~~~~ ~~~~ ~~~~ ~~
   \inference[($\forall E$)]{ \Delta |- t : \forall X^\kappa.B
                            & \Delta |- G:\kappa }
                            {\Delta |- t : [G/X]B}
\]
\[ \newFi{
   \inference[($\forall I i$)]{\Delta, x^A |- t : B}
                              {\Delta |- t : \forall x^A.B} }
     \big( x\notin\FV(t) \big)
 ~~~~ \newFi{
   \inference[($\forall E i$)]{ \Delta |- t : \forall x^A.B
                              & \hat\Delta |- s:A}
                              {\Delta |- t : [s/x]B} }
\]
\end{framed}
\caption{Syntax and Typing rules of \Fi}
\label{fig:Fi}
\end{figure}

\begin{figure}
\begin{framed}
\paragraph{Kind equality:}
\[ \inference{}{\Delta |- * = *:\square}
 ~~~~
   \inference{ \Delta |- \kappa_1 = \kappa_1' : \square
             & \Delta |- \kappa_2 = \kappa_2' : \square }
             {\Delta |- \kappa_1 -> \kappa_2 = \kappa_1' -> \kappa_2' : \square}
 ~~~~ \newFi{
   \inference{\cdot |- A=A':* & \Delta |- \kappa=\kappa':\square}
             {\Delta |- A -> \kappa = A' -> \kappa' : \square} }
\]
\[ \inference{\Delta |- \kappa=\kappa':\square}
             {\Delta |- \kappa'=\kappa:\square}
 ~~~~
   \inference{ \Delta |- \kappa =\kappa' :\square
             & \Delta |- \kappa'=\kappa'':\square}
             {\Delta |- \kappa=\kappa'':\square}
\]
~\\
\paragraph{Type constructor equality:}
\[ \inference{\Delta |- X:\kappa }{\Delta |- X=X:\kappa}
 ~~~~
   \inference{\Delta,X^\kappa |- F:\kappa & \Delta |- G:\kappa}
             {\Delta |- (\lambda X^\kappa.F)\,G = [G/X]F:\kappa'}
 ~~~~ \newFi{
   \inference{\Delta,x^A |- F:\kappa & \hat\Delta |- s:A}
             {\Delta |- (\lambda x^A.F)\,\{s\} = [s/x]F:\kappa} }
\]
\[ \inference{\Delta,X^\kappa |- F=F' : \kappa'}
             {\Delta |- \lambda X^\kappa.F=\lambda X^\kappa.F':\kappa-> \kappa'}
 ~~~~
   \inference{\Delta |- F=F':\kappa->\kappa' & \Delta |- G=G':\kappa}
             {\Delta |- F\,G = F'\,G' : \kappa'}
\]
 ~~~~
\[ \newFi{
   \inference{\Delta,x^A |- F=F' : \kappa}
             {\Delta |- \lambda x^A.F=\lambda x^A.F' : A -> \kappa} }
 ~~~~ \newFi{
   \inference{\Delta |- F=F':A->\kappa & \hat\Delta |- s=s':A}
             {\Delta |- F\,\{s\} = F'\,\{s'\} : \kappa} }
\]
\[ \inference{\Delta |- A=A':* & \Delta |- B=B':*}{\Delta |- A-> B=A'-> B':*}
 ~~~~
   \inference{\Delta,X^\kappa |- B=B':*}
             {\Delta |- \forall X^\kappa.B=\forall X^\kappa.B':*}
 ~~~~ \newFi{
   \inference{\Delta,x^A |- B=B':*}
             {\Delta |- \forall x^A.B=\forall x^A.B':*} }
\]
\[ \inference{\Delta |- F = F' : \kappa}{\Delta |- F' = F : \kappa}
 ~~~~
   \inference{\Delta |- F = F' : \kappa & \Delta |- F' = F'' : \kappa}
             {\Delta |- F = F'' : \kappa}
\]
~\\
\paragraph{Term equality:}
\[ \inference{\Delta |- x:A}{\Delta |- x=x:A}
 ~~~~
   \inference{\Delta,x:A |- t:B & \Delta |- s:A}
             {\Delta |- (\lambda x.t)s=[s/x]t : B}
 ~~~~
   \inference{\Delta |- r=r':A-> B & \Delta |- s=s':A}{\Delta |- r\;s=r'\;s':B}
\]
\[ \inference{\Delta |- t=t':A}{\Delta |- t'=t:A}
 ~~~~
   \inference{\Delta |- t=t':A & \Delta |- t'=t'':A}{\Delta |- t=t'':A}
\]
~\\
\paragraph{Reduction:}
\[ \inference{}{(\lambda x.t)\,s \rightsquigarrow [s/x]t}
 ~~~~
   \inference{t \rightsquigarrow t'}{\lambda x.t \rightsquigarrow \lambda x.t'}
 ~~~~
   \inference{r \rightsquigarrow r'}{r\;s \rightsquigarrow r'\;s}
 ~~~~
   \inference{s \rightsquigarrow s'}{r\;s \rightsquigarrow r\;s'}
\]
\end{framed}
\caption{Equality rules and Reduction rules for \Fi}
\label{fig:eqFi}
\end{figure}

\subsection{The constructs new to \Fi}
\paragraph{Kinds and Sorting rules}
We extend the kind syntax of \Fw\ by indexed arrow kinds of the form
\newFi{A -> \kappa}. The formation of indexed arrow kinds are
governed by the sorting rule \newFi{(Ri)}.
The rule $(Ri)$ specifies that an indexed arrow kind $A -> \kappa$
is well-formed under the typing context $\Delta$
when $A$ is a well-formed type under the empty context ($\cdot$) 
and $\kappa$ is a well-formed kind under the same typeing context $\Delta$.
The type $A$ appearing in the index arrow kind $A -> \kappa$ must be
well kindined under the empty context since we do not want any dependent kinds
(\ie, kinds depending on type level or value level bindings). Since \Fi\ does
not have any binidings at kind level, $A$ must be well-kinded in the empty
context.

\paragraph{Type Constructors and Kinding rules}
We extend the type constructor syntax by three constructs,
and extend the kinding rules accordingly for these new constructs.

\newFi{\lambda x^A.F} is the type level abstraction over an index
(or, index abstraction). Index abstractions introduce indexed arrow kinds
by the kinding rule \newFi{(\lambda i)}. Note, we have new form of binding
$x^A$ in the kinding rule ($\lambda i$).
We will explain what this binding means when we discuss about contexts.

\newFi{F\,\{s\}} is the type level index application. In contrast to
the ordinary type level application ($F\,G$) whose argument being applied is
a type constructor ($G$), the argument of the index application ($F\,\{s\}$) is
a term ($s$). We use the curly bracket notation around the index argument to
emphasize the distinction from ordinary type arguments and also to emphasize
that $s$ is an erasable (or static) term. Index applications eliminate
indexed arrow kinds by the kinding rule \newFi{(@i)}. Note, we type check $s$
under the lifted context $\hat\Delta$ in the rule ($@i$).
We will explain what this lifted context notation $\hat\Delta$ means
in more detail when we discuss about contexts.

\newFi{\forall x^A . B} is an index polymorphic type.
The formation of indexed polymorphic types is governed by
the kinding rule \newFi{\forall i}, which is very similar to
the formation rule ($\forall$) for ordinary polymorphic types.

In addition to the rules ($\lambda i$), ($@ i$), and ($\forall i$),
we need a conversion rule \newFi{($Conv$)} at kind level. This is because of
the new extension to the kind syntax $A -> \kappa$ involving types.
Since kind syntax involves types, we need more than simple structural
equality over kinds. The equality over kinds is the usual structural
equality extended by type equality when comparing indexed arrow kinds
(see \Fig{eqFi}).

\paragraph{Typing rules}
Since we have index polymorphic types ($\forall x^A . B$),
we need typing rules for index polymorphism:
the rule \newFi{(\forall I i)} for index generalization
and the rule \newFi{(\forall E i)} for index instantiation.

The index generalization rule ($\forall I i$) is similar to
the type generalization rule ($\forall I$), except the additional
side condition $\big(x\notin\FV(t)\big)$. This side condition prevents
terms from accessing the type level index variables introduced by index
polymorhpism. Otherwise, whithout this side condition, $\forall$ would be
no longer behave as polymorphism but powerful enough to behave as
dependent type functions, which are usually denoted by the $\Pi$ binder
in independend type theory. This side condition is fairly standard
in dependently typed languages supporting distinction between polymorphism
(or, erasable arguments) and dependent functions
(\eg, IPTS[TODO cite Nathans' thesis], ICC[TODO cite]).
The rule ($\forall I$) for ordinary type gernalization rule does not need
a side condition such as $\big(X\notin\FV(t)\big)$ because the syntax of
terms cannot have any type variables to appear in terms.

The index instantiation rule ($\forall E i$) is similar to
the type instantiation rule ($\forall E i$), except that
we type check the index term $s$ to be instantiated for $x$
in the lifted context $\hat\Delta$.
We will explain what this lifted context notation $\hat\Delta$ means
in more detail when we discuss about contexts.

In addition to the rules ($\forall I i$) and ($\forall E i$) for
index polymorphism, we need an additional variable rule \newFi{(:')}
to be able to acess to index variables already in scope. Terms ($s$) used
at type level in index applications ($F\{s\}$) should be able to acess
index variables already in scope. For example, $\lambda x^A.F\{x\}$ should be
well-kinded under a context where $F$ is well-kinded,
justified by the following derivation:
\[
   \inference[($\lambda i$)]
      { \inference[(@i)]{ \Delta, x^A |- F : A -> \kappa
                        & \inference[($:'$)]{ x^A\in\widehat{\Delta,x^A}
                                            & |- \widehat{\Delta,x^A} }
                                            {\widehat{\Delta,x^A} |- x:A}
                        }
                        {\Delta, x^A |- F\{x\} : \kappa} }
      {\Delta |- \lambda x^A.F\{x\} :\kappa}
\]
\KYA{we stil need to show a small lemma that context lifting preserves
well-formedness of cotnexts so that we can accept $|-\widehat{\Delta,x^A}$
assuming $|-\hat\Delta$. TODO put this in the next paragraph.}

\paragraph{Contexts}
We have a forms of bindings $x^A$, which we call index binding,
that can appear in the context. We also define the context lifting
for the judgement that appear at an upper level than its usual level (\eg,
type judgment for a term $s$ at type level in the kinding rule ($@i$),
kind judgment for a type $A$ at kind level in the sorting rule ($Ri$)).

\newFi{x^A} is an index binding, which can only be used statically
(\ie, at type level) but not dynamically (\ie, at term level).
Index bindings ($x^A$) are introduced either from index abstractions
($\lambda x^A.F$) or from index polymorphic types ($\forall x^A.B$).
The index binding introduced from index abstraction can be used in its
body, as we have alredy discussed above with the example derivation for
$\Delta,x^A |- F \{x\} :*$, since the body of index abstraction ($F\{x\}$)
is at type level. However, the index biniding $x^A$ introduced by
index polymorhpic type in the generalization rule ($\forall I i$)
is not allowed to appear in the term $t$, which is at term level,
although it can appear in $B$, which is at type level.

The context lifting ($\hat\Delta$) forgets dynamic bindings ($x:A$)
and leaves the others ($X^\kappa$ and $x^A$) unchaged.
The definition of context lifinting captures the idea that index terms
(\eg, $s$ in the rules ($@i$) and ($\forall E i$)) should not have access to
the dynamic term variables but should be able to access the type variables and
the index variables already in scope.



\subsection{\Fi\ in regards to PTS}
We describe \Fw\ and CC as an instances of the Pure Type System (PTS),
and then describe \Fi\ as an extension of \Fw\ and a restriction of CC.

%% \begin{figure}
\[\text{Syntax}~~~~~ a,b,A,B ::= s \mid x \mid b~a \mid \lambda x:A.B
                                   \mid (x:A) -> B \]
\[\text{Typing}~~~~~\]
\[
 \inference[Ax]{|-\Gamma & (s_1,s_2)\in\calA}{\Gamma |- s_1 : s_2}
 ~~~~
 \inference[Var]{|-\Gamma & (x:A)\in\Gamma}{\Gamma |- x:A} 
 ~~~~
 \inference[Conv]{\Gamma |- a:A & \Gamma |- B:s & A=B}{\Gamma |- a:B}
\]
\[
 \inference[Pi]{\Gamma |- A:s_1 & \Gamma,x:A |- B:s_2 & (s_1,s_2,s_3)\in\calR}
               {\Gamma |- (x:A)-> B : s_3}
\]
\[
 \inference[Lam]{\Gamma |- (x:A)-> B : s & \Gamma,x:A |- b:B}
                {\Gamma |- \lambda x:A.b : (x:A)-> B}
 ~~~~
 \inference[App]{\Gamma |- b:(x:A)-> B & \Gamma |- a:A}{\Gamma |- b\;a:[a/x]B}
\]

\[\text{Context}~~~~~
 \inference{}{|-\cdot}
 ~~~~
 \inference{x\notin\dom(\Gamma) & |-\Gamma}{|-\Gamma,x:A}
\]
%% \caption{Pure Type System}
%% \label{fig:PTSrule}
%% \end{figure}

PTS is instantiated by the triple $(\calS,\calA,\calR)$ where
$\calS$ is the set of sorts ($s,s_1,s_2,s_3\in\calS$ in the PTS typing rules),
$\calA\subset\calS\times\calS$ is the set of axioms (used in Ax rule), and
$\calR\subset\calS\times\calS\times\calS$ is the set of rules (used in Pi rule).

\Fw\ is an instance of PTS where
\[\calS=\{*,\square\}
  ~~~~~
  \calA=\{(*,\square)\}
  ~~~~~
  \calR=\{(*,*,*),(\square,*,*),(\square,\square,\square)\}
\]
Each element in $\calR$ stands for certain ability of dependency:
$(*,*,*)$ enables functions at the value level
(values depending on values)
$(\square,*,*)$ enables parametric polymorphism
(values depending on types)
$(\square,\square,\square)$ enables functions at the type level
(types depending on types).

CC extends \Fw\ with one additional rule
$(*,\square,\square)$, which enables types depending on values
(\emph{dependent types}, or, types with \emph{value dependency}).
That is, CC is an instance of PTS where
\[\calS=\{*,\square\}
  ~~~~~
  \calA=\{(*,\square)\}
  ~~~~~
  \calR=\{(*,*,*),(\square,*,*),(\square,\square,\square)
         ,(*,\square,\square)\}\]

%% \KYA{ below is what I understood marcelo maybe wrong}
%% \Fi\ is also an extension of \Fw\, but a restriction of CC.  Instead of
%% allowing full value dependency (given by $(*,\square,\square)$ in CC),
%% we only allow value dependency partially via special syntax as follows:
%% \[
%%  \inference[Let]{\Gamma |- a:A & \Gamma, x:A |- b:B}
%%                 {\Gamma |- \mathsf{let}~x:A=a~\mathsf{in}~b : [a/x]B}
%% \]
%% \[
%%  \inference[Pi$_{(*,\square,\square)}$]
%%      {\Gamma |- A:* & \Gamma |- B:\square}
%%      {\Gamma |- (x:A)-> B : \square}
%% \]
%% The Let rule can be derived in CC by combining Pi rule and App rule.  However,
%% we only allow value dependency $(*,\square,\square)$ in this limited form,
%% but disallow arbitrary lambda abstractions to form value dependent functions
%% by limiting the Pi rule on $(*,\square,\square)$.

Normalization of \Fi\ is automatic since \Fi\ is a strict subset of CC,
which is known to be strongly normalizing.

\subsection{examples}
For better intuition, let us see some examples what we can express and
what we cannot in \Fi.
\newcommand{\List}{\mathsf{List}}
\newcommand{\Vect}{\mathsf{Vec}}

\paragraph{Ordinary (parametric) polymorphism} is obviously possible,
since \Fi\ is an extension of \Fw. Note, $\Gamma |- (x:*) -> B : *$
where $\Gamma,x:* |- B:*$, since $(\square,\star,\star) \in\calR$.
If you'd prefer \Fw\-like syntax we could use alternative notation
$\forall(x:*).B$ for $(x:*) -> B$. With the support of ordinary polymorphism,
we can write functions over polymorphic lists as follows
where $\List : * -> *$ (details of the function body is omitted):
\[ (\Lambda a:*.\lambda x:\List~a. \cdots) : \forall(a:*).\List~a -> \List~a \]
The uppercase lambda ($\Lambda$) is an alternative notation in flavour of \Fw
for the ordinary lowercase lambda ($\lambda$)
More generally, we can be polymorphic over any \Fw\ kind such as $* -> *$.
For instance, $\forall(x:* -> *).B$.

\paragraph{Polymorphism over indexed values} is also possible.
Note, $\Gamma |- (x:A) -> B : *$ where $\Gamma |- A:*$ and $\Gamma,x:A |- B:*$.
With the support of polymorphism over indexed values, we can write functions
over type indexed lists as follows (details of the function body is omitted)
where $\Vect : \Nat -> *$:
\[
(\Lambda n:\Nat.\lambda x:\Vect~n. \cdots) : \forall(n:\Nat).\Vect~n -> \Vect~n 
\]
More generally, $\Gamma |- (x:\ka) -> B : *$ where $\Gamma, x:\ka |- B:*$
can be written as $\forall(x:\ka).B$ in flavour of \Fw.

We call the (parametric) polymorphism of \Fi, which includes
both the ordinary polymorphism of \Fw\ and the polymorphism involving indices,
\emph{generalized polymorphism}.

To be more precise, this is not exactly the polymorphism we would expect
in functional languages with indexed types (\eg, GADT extension in Haskell),
since we usually expect index variables like $n$ bound by $\Lambda$ to be
erasable (or, computationally irrelevant) in contrast to the variables bound
by ordinary $\lambda$. Here in PTS, which is in Church style, $n$ can also
appear as computationally relevant in the function body. Unlike ordinary
polymorphism where the polymorphic variable is a type variable that cannot
live in value world, nothing prevents the index variables like $n$ to be used
in the value level. This is what Abel and Matthes in CSL 04 paper meant that
the Church style becomes richer than the Curry style as we move from \Fw\ to
a dependently typed setting such as CC. I think it is better to formalize
in Curry style if we want to capture the erasure property of polymorphism
correctly in \Fi.

\paragraph{Large eliminations resulting in constant kinds} are possible.
Large eliminations are type computations depending on values.  For example,
computing an $n$-ary boolean function type given a natural number index $n$
can be defined as follows (details of the function body is omitted):
\[
(\lambda n:\Nat. \stackrel{n}{\overbrace{\Bool-> \cdots-> \Bool}}\;\, -> \Bool)
  : (n:\Nat) -> *
\]
Note, the resulting kind ($*$) is constant, being independent of $n$.
So, the example above is a large elimination resulting in a constant kind,
which does not involve any kind computation.

However, large eliminations resulting in varying kinds that depend on
input index values are not possible, unless you use the let syntax to make
the input index values available (then, the input indices do not vary
at runtime after all). For example, large elimination computing an $n$-ary
type constructor given a natural number index $n$ line the following
is \emph{not} possible to define in \Fi:
\[
(\lambda n:\Nat. \cdots \cdots)
  : (n:Nat) -> \,\;\stackrel{n}{\overbrace{* -> \cdots -> *}}\;\, -> *
\]
This restriction is to make the kind inference doable.

