\documentclass{llncs}
\usepackage{pdfpages}
%% \usepackage[hang,bf]{caption}
\usepackage{color}
\usepackage[fleqn]{amsmath}
\usepackage{amssymb}
\usepackage{semantic}
\usepackage{listings}
\usepackage{comment}
\usepackage[numbers]{natbib}

\definecolor{grey}{rgb}{0.8,0.8,0.8}

\newcommand{\Fig}[1]{Fig.\,\ref{fig:#1}}
\newcommand{\Figs}[1]{Figs.\,\ref{fig:#1}}
\newcommand{\newFi}[1]{\colorbox{grey}{\ensuremath{#1}}}

\newcommand{\ie}{{i.e.}}
\newcommand{\eg}{{e.g.}}
\newcommand{\aka}{{a.k.a.}$\,$}

\newcommand{\Fi}{\ensuremath{\mathsf{F}_i}}
\newcommand{\Fw}{\ensuremath{\mathsf{F}_\omega}}
\newcommand{\fix}{\mathsf{fix}}
\newcommand{\Fix}{\mathsf{Fix}}
\newcommand{\Fixw}{\ensuremath{\Fix_{\omega}}}
\newcommand{\Fixi}{\ensuremath{\Fix_{i}}}

\renewcommand{\l}{\lambda}

\newcommand{\dom}{\mathop{\mathsf{dom}}}
\newcommand{\FV}{\mathop{\mathrm{FV}}}

\newcommand{\Eq}{\mathtt{Eq}}
\newcommand{\LEq}{\mathtt{LEq}}
\newcommand{\Ran}{\mathtt{Ran}}
\newcommand{\Lan}{\mathtt{Lan}}
\newcommand{\s}[1]{\{#1\}}

\renewcommand{\S}[0]{Sect.\;}

\title{System \Fi}
\subtitle{a Higher-Order Polymorphic $\lambda$-Calculus\\
        with Erasable Term Indices}
\titlerunning{System \Fi}
\author{Ki Yung Ahn\inst{1} \and Tim Sheard\inst{1} \and
        Marcelo Fiore\inst{2} \and Andrew M. Pitts\inst{2} }
\institute{
        Portland State University, Portland, Oregon, USA
        \thanks{supported by NSF grant 0910500.}
        \\ \email{kya@cs.pdx.edu} \qquad \email{sheard@cs.pdx.edu}
        \and
        University of Cambridge, Cambridge, UK
        \\ \email{\{Marcelo.Fiore,Andrew.Pitts\}@cl.cam.ac.uk}
        }

\begin{document}
\maketitle
\begin{abstract}
TODO
\keywords{term-indexed data types, generalized algebraic data types,
higher-order polymorphism, type-constructor polymorphism, higher-kinded types,
impredicative encoding}
\end{abstract}

\section{Introduction}

%% Term indices - erasable, possibly nested
%% 
%% Higher-order polymorphism
%% 
%% Strong normalization and logical consistency

We are interested in the use of indexed types to state and
maintain program properties. A type parameter
(like {\tt Int} in {\tt (List Int)}) usually tells us
something about data stored in values of that type.
A type index (like {\tt 3} in {\tt (Vector Int 3)}) states
an inductive property of values with that type. For example,
values of type {\tt (Vector Int 3)} have three elements.

Indexed types come in two flavors: \emph{type-indexed} and \emph{term-indexed}
types. {\it Type indexing} involves higher-kinded parametric polymorphism,
but there also exists more sophisticated types such as
Generalized Algebraic Datatypes~(GADTs). An example of type indexing
using GADTs (in Haskell) is a type representation:\vspace*{-2pt}
\begin{lstlisting}[basicstyle={\ttfamily\small},language=Haskell,mathescape]
data TypeRep t where
  Int  :: TypeRep Int
  Bool :: TypeRep Bool
  Pair :: TypeRep a -> TypeRep b -> TypeRep(a,b)
\end{lstlisting}\vspace*{-2pt}
Here, a value of type {\tt (TypeRep t)} is isomorphic in ``shape" with
the type {\tt t}. For example {\tt (Pair Int Bool)} is isomorphic in shape
with its type {\tt (Int,Bool)}.

{\it Term-indcies} range over data structures, such as natural numbers
(like {\tt Z}, {(\tt S Z})) or lists (like {\tt Nil} or ({\tt Cons Z Nil})). 
A classic example of a term index is the second parameter to
the length-indexed list type {\tt Vec}~(as in ({\tt Vec Int (S Z)})).

In languages such as Haskell\footnote{see \S\ref{sec:relwork} for
        a very recent GHC extension, which enable true term-indices.}
	or OCaml \cite{GarNor11}, which support GADTs with type indexing,
term-indices are simulated (or faked) by reflecting data at the type level
with uninhabited type constructors. For example,\vspace*{-2pt}
\begin{lstlisting}[basicstyle={\ttfamily\small},language=Haskell,mathescape]
data S n
data Z
\end{lstlisting}\vspace*{-8pt}
\begin{lstlisting}[basicstyle={\ttfamily\small},language=Haskell,mathescape]
data Vec t n where
  Cons :: a -> Vec a n -> Vec a (S n)
  Nil  :: Vec a Z
\end{lstlisting}\vspace*{-2pt}
This comes with a number of problems. First, there is no way to say
that types such as {\tt (S Int)} are ill-formed, and second the costs
associated with duplicating the constructors of data to be used
as term-indices.
Nevertheless, GADTs iwth ``faked" term indices have become extremely popular
as a light-weight, type-based mechanism to raise the confidence of users
that software systems maintain important properties.

Our approach in this direction is to design a new foundational calculus,
System~\Fi, for functional programming languages with term-indexed
datatypes.  In a nutshell, System~\Fi\ is obtained by minimally extending
System~\Fw\ with type-indexed kinds.  Notably, this yields a logical
calculus that is expressive enough to embed non-dependent
\emph{term-indexed datatypes} and their eliminators. Our contributions in
this development are as follows.\vspace*{-.8ex}
\begin{itemize}
\item 
  Identifying the features that are needed for a higher-order polymorphic
  $\lambda$-calculus to embed term-indexed datatypes~(\S\ref{sec:motiv}),
  in isolation from other features normally associated with such
  calculi~(e.g., general recursion, large elimination, dependent types).
\item 
  The design of the calculus, System \Fi\ (\S\ref{sec:Fi}), and its use to
  study properties of languages with term-indexed datatypes, by embedding
  these into the calculus~(\S\ref{sec:motiv}).  For instance, one can use
  System~\Fi\ to prove that the Mendler-style eliminators for GADTs
  \cite{AhnShe11} are normalizing.
\item 
  Showing that System~\Fi\ enjoys a simple erasure
  property (\S\ref{ssec:erasure}) 
  and inherits meta-theoretic
  results~(strong normalization and logical consistency) from well-known
  calculi~(\Fw\ and ICC) that are supersets of \Fi~(\S\ref{ssec:sn}).
\end{itemize}\vspace*{-3pt}

\section{Motivation: from System~\Fw\ to System~\Fi, and back}
\label{sec:motiv}
It is well known that datatypes can be embedded into polymorphic lambda
calculi by means of functional encodings~\cite{AbeMatUus03}, such
as the Church and Boehm-Berarducci encodings~\cite{BoehmBerarducci}.

In System~\textsf{F}, for instance, one can embed \emph{regular
datatypes}, like homogeneous lists:
\[
\begin{array}{ll}
\text{Haskell:} & \texttt{data List a = Cons a (List a) | Nil} \\
\text{System \textsf{F}:}~& 
\texttt{{List}}\:\: A\:\:\triangleq\:\:
\forall X.
(A\to X\to X) \to X \to X ~~\; 
\end{array}
\]
In such regular datatypes, constructors have algebraic structure that
directly translates into polymorphic operations on abstract types as
encapsulated by universal quantification over types (of kind $*$).

In the more expressive System \Fw~ (where one can abstract over type constructors
of any kind),
one can encode more general \emph{type-indexed datatypes} that go beyond the 
regular datatypes. For example, one can embed powerlists with
heterogeneous elements in which an element of type \texttt{a} is followed by
an element of the product type \texttt{(a,a)}:
\[
\begin{array}{ll}
\text{Haskell:} & \texttt{data Powl a = 
        PCons a (Powl(a,a))
        | 
        PNil 
} \\
& \texttt{Cons 1 (Cons (2,3) (Cons ((3,4),(1,2)) Nil)) :: Powl Int}\\
\text{System \Fw:}~& \texttt{{Powl}}\:\triangleq\:
\lambda A^{*}.\forall X^{*\to*}. (A\to X(A\times A)\to X A) \to X A \to XA
\end{array}
\]
Note the non-regular occurrence (\texttt{Powl(a,a)}) in the definition of
(\texttt{Powl a}), and the use of universal quantification over
higher-order kinds.

What about term-indexed datatypes?  What extensions to System~\Fw\ are
needed to embed term indices as well as type indices?  Our answer is
System~\Fi.

In a functional language supporting term-indexed datatypes, we envisage
that the classic example of homogeneous length-indexed lists would be
defined along the following lines (in Nax [TODO cite] syntax):\vspace{-5pt}
\begin{lstlisting}[basicstyle={\ttfamily},language=Haskell]
 data Nat = S Nat | Z 
 data Vec (a:*) {i:Nat} where
   VCons : a -> Vec a {i} -> Vec a {S i}
   VNil  : Vec a {Z}
\end{lstlisting}~\vspace{-15pt}\\ \noindent
Here the type constructor~{\tt Vec} is defined to admit parameterisation
by both type and term indices.  For instance, the type 
(\verb|Vec (List Nat) {S (S Z)}|) is that of two-dimensional
vectors of lists of natural numbers.  By design, our syntax directly
reflects the difference between type and term indexing by enclosing the latter in
curly braces.  We also make this distinction in 
System~\Fi, where it is useful within the types system
to guarantee the static nature of term indexing.

The encoding of the vector datatype in System~\Fi\ is as follows: 
\begin{equation*}\label{FiVecType}
\texttt{{Vec}}
\triangleq
\begin{array}[t]{l}
\lambda A^\mathtt{*}.\lambda
i^{\texttt{{Nat}}}.  \forall X^{\texttt{{Nat}}\to\mathtt{*}}.
  (\forall j^{\texttt{{Nat}}}.A\to X\{j\}\to X\{\texttt{{S}}\; j\})
  \to X\{\texttt{{Z}}\}
    \to X\{i\}
\end{array}
\end{equation*}
where $\texttt{{Nat}}$, $\mathtt Z$, and $\mathtt S$ respectively encode
the natural number type and its two constructors,  zero and successor.
Without going into the details of the formalism, which are given in the
next section, one sees that such a calculus incorporating term-indexing
structure needs four additional constructs (see \Fig{FiSyntax} for the
highlighted extended syntax).
\begin{enumerate}
\item 
  Type-indexed kinding~($A\to\kappa$), as in $(\texttt{{Nat}\ensuremath{\to}*})$
  in the example above, where the compile-time nature of term-indexing
  will be reflected in the typing rules, enforcing that $A$ be a closed
  type~(rule~$(Ri)$ in \Fig{FiTyping}).

\item 
  Term-index abstraction~$\lambda i^A.F$~(as $\lambda
  i^{\texttt{{Nat}}}.\cdots$ in the example above) for constructing (or
  introducing) type-indexed kinds (rule~$(\lambda i)$ in
  \Fig{FiTyping}).  

\item 
  Term-index application~$F\{s\}$ (as $X\{{\tt Z}\}$, $X\{j\}$, and
  $X\{\texttt{S}\;j\}$ in the example above) for destructing (or
  eliminating) type-indexed kinds, where the compile-time nature of
  indexing will be reflected in the typing rules, enforceing that the index be
  statically typed% in that it does not depend on run-time parameters
~(rule~$(@i)$ in \Fig{FiTyping}) .

\item 
  Term-index polymorphism~$\forall i^A.B$ (as $\forall
  j^{\texttt{{Nat}}}.\cdots$ in the example above) where the compile-time
  nature of polymorphic term-indexing will be reflected in the typing rules enforcing
  that the variable~$i$ be static of closed type~$A$~(rule~$(\forall
  Ii)$ in \Fig{FiTyping}).
\end{enumerate}

As described above, System~\Fi\ maintains a clear-cut separation between
type indexing and term indexing.  This adds a level of abstraction
to System~\Fw\ and yields types that in addition to parametric polymorphism
also keep track of inductive invariants using term indices. All term-index
information can be erased, since it is only used at compile-time.  
It is possible to project any well-typed System~\Fi\ term into a well-typed System~\Fw\ term.
For instance, the erasure of the \Fi-type~\texttt{Vec}
is the \Fw-type~\texttt{List}.  This is established in
\S\ref{sec:theory} and used to deduce the strong normalization of
System~\Fi.

\section{System \Fi} \label{sec:Fi}
System \Fi\ is a higher-order polymorphic lambda calculus 
designed to extend System~\Fw\ by the inclusion of term indices.
The syntax and rules of System~\Fi\ are described in~\Figs{FiSyntax},
\ref{fig:FiTyping} and~\ref{fig:eqFi}. 
The extensions new to System~\Fi, which are not originally part of System~\Fw, 
are highlighted by \newFi{\text{grey boxes}}.
Eliding all the grey boxes from~\Figs{FiSyntax}, \ref{fig:FiTyping}
and~\ref{fig:eqFi}, one obtains a version of System~\Fw\ 
with Curry-style terms and the typing context separated into two parts
(type-level context $\Delta$ and term-level context $\Gamma$).

We assume readers to be familiar with System~\Fw\
and focus on describing the new constructs of \Fi, which appear in grey boxes.

\begin{figure}
\paragraph{Syntax:}~\vskip-3ex
\begin{align*}
\!\!\!\!\!\!\!\!&\text{Sort}
        & \square
        \\
\!\!\!\!\!\!\!\!&\text{Term Variables}
        & x,i
\\
\!\!\!\!\!\!\!\!&\text{Type Constructor Variables}
        & X
\\
\!\!\!\!\!\!\!\!&\text{Kinds}
        & \kappa                &~ ::= ~ *
                                \mid \kappa -> \kappa
                                \mid \newFi{A -> \kappa}
\\
\!\!\!\!\!\!\!\!&\text{Type Constructors}
        & A,B,F,G               &~ ::= ~ X
                                \mid A -> B
                                \mid \lambda X^\kappa.F
                                \mid F\,G
                                \mid \forall X^\kappa . B \\
                                &&& \qquad\qquad\qquad\quad~
                                \mid \newFi{\lambda i^A.F
                                \mid F\,\{s\}
                                \mid \forall i^A . B}
\\
\!\!\!\!\!\!\!\!&\text{Terms}
        & r,s,t                 &~ ::= ~ x \mid \lambda x.t \mid r\;s
\\
\!\!\!\!\!\!\!\!&\text{Typing Contexts}
        & \Delta                &~ ::= ~ \cdot
                                \mid \Delta, X^\kappa
                                \mid \newFi{\Delta, i^A} \\
&       & \Gamma                &~ ::= ~ \cdot
                                \mid \Gamma, x : A
\end{align*}\vskip-2ex
\paragraph{Reduction:} ~~ \fbox{$t \rightsquigarrow t'$} \\
$
 ~~~~
   \inference{}{(\lambda x.t)\,s \rightsquigarrow t[s/x]}
 ~~~~
   \inference{t \rightsquigarrow t'}{\lambda x.t \rightsquigarrow \lambda x.t'}
 ~~~~
   \inference{r \rightsquigarrow r'}{r\;s \rightsquigarrow r'\;s}
 ~~~~
   \inference{s \rightsquigarrow s'}{r\;s \rightsquigarrow r\;s'}
$
\caption{Syntax and Reduction rules of \Fi}
\label{fig:FiSyntax}
\end{figure}

\begin{figure}
\paragraph{Well-formed typing contexts:}
\[ \fbox{$|- \Delta$}
 ~~~~
   \inference{}{|- \cdot}
 ~~~
   \inference{|- \Delta & |- \kappa:\square}
             {|- \Delta,X^\kappa}
      \big( X\notin\dom(\Delta) \big)
 ~~~ \newFi{
   \inference{|- \Delta & \cdot |- A:*}
             {|- \Delta,i^A}
      \big( i\notin\dom(\Delta) \big) }
\]
\[ \fbox{$\Delta |- \Gamma$}
 ~~~~
   \inference{|- \Delta}{\Delta |- \cdot}
 ~~~
   \inference{\Delta |- \Gamma & \Delta |- A:*}
             {\Delta |- \Gamma,x:A}
      \big( x\notin\dom(\Gamma) \big)
 \qquad\qquad\qquad\qquad\qquad\qquad\qquad
\]
~\\
\paragraph{Sorting:} ~~ \fbox{$|- \kappa : \square$}
\[
  \inference[($A$)]{}{|- *:\square}
 ~~~~
   \inference[($R$)]{|- \kappa:\square & |- \kappa':\square}
                    {|- \kappa -> \kappa' : \square}
 ~~~~
   \newFi{
   \inference[($Ri$)]{\cdot |- A:* & |- \kappa:\square}
                     {|- A -> \kappa : \square} }
\]
~\\
\paragraph{Kinding:} ~~ \fbox{$\Delta |- F : \kappa$}
$ \quad
 ~~~~
   \inference[($Var$)]{X^\kappa\in\Delta & |- \Delta}
                       {\Delta |- X : \kappa}
 ~~~~
   \inference[($->$)]{\Delta |- A : * & \Delta |- B : *}
                     {\Delta |- A -> B : * }
$
\[
  \inference[($\lambda$)]{|- \kappa:\square & \Delta,X^\kappa |- F : \kappa'}
                          {\Delta |- \lambda X^\kappa.F : \kappa -> \kappa'}
 ~~~~ \quad ~~
 \newFi{
  \inference[($\lambda i$)]{\cdot |- A:* & \Delta,i^A |- F : \kappa}
                            {\Delta |- \lambda i^A.F : A->\kappa}
                    }
\]
\[ \inference[($@$)]{ \Delta |- F : \kappa -> \kappa'
                    & \Delta |- G : \kappa }
                    {\Delta |- F\,G : \kappa'}
 ~~~~
 \newFi{
   \inference[($@i$)]{ \Delta |- F : A -> \kappa
                     & \Delta;\cdot |- s : A }
                     {\Delta |- F\,\{s\} : \kappa}
             }
\]
\[ \inference[($\forall$)]{|- \kappa:\square & \Delta, X^\kappa |- B : *}
                          {\Delta |- \forall X^\kappa . B : *}
 ~~~~ \quad ~~~
 \newFi{
   \inference[($\forall i$)]{\cdot |- A:* & \Delta, i^A |- B : *}
                            {\Delta |- \forall i^A . B : *}
                    }
\]
\[ \newFi{
   \inference[($Conv$)]{ \Delta |- A : \kappa
                       & \Delta |- \kappa = \kappa' : \square }
                       {\Delta |- A : \kappa'} }
\]
~\\
\paragraph{Typing:} ~~ \fbox{$\Delta;\Gamma |- t : A$}
$ \quad
 ~~~~
 \inference[($:$)]{(x:A) \in \Gamma & \Delta |- \Gamma} 
                    {\Delta;\Gamma |- x:A}
 ~~~~ \newFi{
   \inference[($:i$)]{i^A \in \Delta & \Delta |- \Gamma} 
                     {\Delta;\Gamma |- i:A} }
$
\[
   \inference[($->$$I$)]{\Delta |- A:* & \Delta;\Gamma,x:A |- t : B}
                        {\Delta;\Gamma |- \lambda x.t : A -> B}
 ~~~~ ~~~~
   \inference[($->$$E$)]{\Delta;\Gamma |- r : A -> B & \Delta;\Gamma |- s : A}
                        {\Delta;\Gamma |- r\;s : B}
\]
\[ \inference[($\forall I$)]{|- \kappa:\square & \Delta, X^\kappa;\Gamma |- t : B}
                            {\Delta;\Gamma |- t : \forall X^\kappa.B}
                            (X\notin\FV(\Gamma))
 ~~~~ ~~~~
   \inference[($\forall E$)]{ \Delta;\Gamma |- t : \forall X^\kappa.B
                            & \Delta |- G:\kappa }
                            {\Delta;\Gamma |- t : B[G/X]}
\]
\[ \!\!\newFi{
   \inference[($\forall I i$)]{\cdot |- A:* & \Delta, i^A;\Gamma |- t : B}
                              {\Delta;\Gamma |- t : \forall i^A.B}
   \left(\begin{matrix}
                i\notin\FV(t),\\
                i\notin\FV(\Gamma)\end{matrix}\right)
 ~~
   \inference[($\forall E i$)]{ \Delta;\Gamma |- t : \forall i^A.B
                              & \Delta;\cdot |- s:A}
                              {\Delta;\Gamma |- t : B[s/i]} }
\]
\[ \inference[($=$)]{\Delta;\Gamma |- t : A & \Delta |- A = B : *}
                    {\Delta;\Gamma |- t : B}
\]
\caption{Well-formedness, Sorting, Kinding, and Typing rules of \Fi}
\label{fig:FiTyping}
\end{figure}

\begin{figure}
\paragraph{Kind equality:} ~~ \fbox{$|- \kappa=\kappa' : \square$}
$
 ~~~~
   \inference{}{|- * = *:\square}
 ~~~~
   \inference{ |- \kappa_1 = \kappa_1' : \square
             & |- \kappa_2 = \kappa_2' : \square }
             {|- \kappa_1 -> \kappa_2 = \kappa_1' -> \kappa_2' : \square}
$
\[ \newFi{
   \inference{\cdot |- A=A':* & |- \kappa=\kappa':\square}
             {|- A -> \kappa = A' -> \kappa' : \square} }
 ~~~~
   \inference{|- \kappa=\kappa':\square}
             {|- \kappa'=\kappa:\square}
 ~~~~
   \inference{ |- \kappa =\kappa' :\square
             & |- \kappa'=\kappa'':\square}
             {|- \kappa=\kappa'':\square}
\]
~\\
\paragraph{Type constructor equality:} ~~ \fbox{$\Delta |- F = F' : \kappa$}
\[ \inference{\Delta,X^\kappa |- F:\kappa' & \Delta |- G:\kappa}
             {\Delta |- (\lambda X^\kappa.F)\,G = F[G/X]:\kappa'}
 ~~~~ \newFi{
   \inference{\Delta,i^A |- F:\kappa & \Delta;\cdot |- s:A}
             {\Delta |- (\lambda i^A.F)\,\{s\} = F[s/i]:\kappa} }
\]
\[ \inference{\Delta |- X:\kappa }{\Delta |- X=X:\kappa}
 ~~~~
   \inference{\Delta |- A=A':* & \Delta |- B=B':*}{\Delta |- A-> B=A'-> B':*}
\]
\[ \inference{|- \kappa:\square & \Delta,X^\kappa |- F=F' : \kappa'}
             {\Delta |- \lambda X^\kappa.F=\lambda X^\kappa.F':\kappa-> \kappa'}
 ~~~~ \quad ~
 \newFi{
   \inference{\cdot |- A:* & \Delta,i^A |- F=F' : \kappa}
             {\Delta |- \lambda i^A.F=\lambda i^A.F' : A -> \kappa}
     }
\]
\[ \inference{\Delta |- F=F':\kappa->\kappa' & \Delta |- G=G':\kappa}
             {\Delta |- F\,G = F'\,G' : \kappa'}
 ~~~~ \newFi{
 \inference{\Delta |- F=F':A->\kappa & \Delta;\cdot |- s=s':A}
             {\Delta |- F\,\{s\} = F'\,\{s'\} : \kappa}
     }
\]
\[
   \inference{|- \kappa:\square & \Delta,X^\kappa |- B=B':*}
             {\Delta |- \forall X^\kappa.B=\forall X^\kappa.B':*}
 ~~~~ \qquad
 \newFi{
   \inference{\cdot |- A:* & \Delta,i^A |- B=B':*}
             {\Delta |- \forall i^A.B=\forall i^A.B':*} }
\]
\[ \inference{\Delta |- F = F' : \kappa}{\Delta |- F' = F : \kappa}
 ~~~~
   \inference{\Delta |- F = F' : \kappa & \Delta |- F' = F'' : \kappa}
             {\Delta |- F = F'' : \kappa}
\]
~\\
\paragraph{Term equality:} ~~ \fbox{$\Delta;\Gamma |- t = t' : A$}
$ \qquad
 ~~~~
   \inference{\Delta;\Gamma,x:A |- t:B & \Delta;\Gamma |- s:A}
             {\Delta;\Gamma |- (\lambda x.t)\,s=t[s/x] : B} $
\[
   \inference{\Delta;\Gamma |- x:A}{\Delta;\Gamma |- x=x:A}
 ~~~~
   \inference{\quad~~ \Delta |- A:* \\ \Delta;\Gamma,x:A |- t=t':B}
             {\Delta;\Gamma |- \lambda x.t = \lambda x.t':B}
 ~~~~
   \inference{\Delta;\Gamma |- r=r':A-> B \\ \Delta;\Gamma |- s=s':A \qquad~}
             {\Delta;\Gamma |- r\;s=r'\;s':B}
\]
\[ \inference{|- \kappa:\square & \Delta, X^\kappa;\Gamma |- t=t' : B}
             {\Delta;\Gamma |- t=t' : \forall X^\kappa.B}
             (X\notin\FV(\Gamma))
 ~~~~ ~~~~
   \inference{ \Delta;\Gamma |- t=t' : \forall X^\kappa.B
             & \Delta |- G:\kappa }
             {\Delta;\Gamma |- t=t' : B[G/X]}
\]
\[ \newFi{
   \inference{\cdot |- A:* & \Delta, i^A;\Gamma |- t=t' : B}
             {\Delta;\Gamma |- t=t' : \forall i^A.B}
   \left(\begin{smallmatrix}
                i\notin\FV(t),\\
                i\notin\FV(t'),\\
                i\notin\FV(\Gamma)\end{smallmatrix}\right)
 ~~~~
   \inference{ \Delta;\Gamma |- t=t' : \forall i^A.B
             & \Delta;\cdot |- s:A}
             {\Delta;\Gamma |- t=t' : B[s/i]} }
\]
\[ \inference{\Delta;\Gamma |- t=t':A}{\Delta;\Gamma |- t'=t:A}
 ~~~~
   \inference{\Delta;\Gamma |- t=t':A & \Delta;\Gamma |- t'=t'':A}
             {\Delta;\Gamma |- t=t'':A}
\]
\caption{Equality rules of \Fi}
\label{fig:eqFi}
\end{figure}

%% \subsection{System~\Fi\ compared to System~\Fw} \label{ssec:newFi}

\paragraph{Kinds.}
The key extension to \Fw\ is the addition of term-indexed arrow kinds of
the form \newFi{A -> \kappa}. This allows type constructors to have terms
as indices. The rest of the development of \Fi\ flows naturally from
this single extension.

\paragraph{Sorting.} \label{sorting}
The formation of indexed arrow kinds is
governed by the sorting rule \newFi{(Ri)}. The rule $(Ri)$ specifies that
an indexed arrow kind $A -> \kappa$ is well-sorted when $A$ has kind $*$
under the empty type level context ($\cdot$) and $\kappa$ is well-sorted.

Requiring $A$ to be well-kinded under the empty type level context avoids
dependent kinds (\ie, kinds depending on type level or value level bindings).
%% The type $A$ appearing in
%% the index arrow kind $A -> \kappa$ must be well-kinded under
%% the empty type level context ($\cdot$).
That is, $A$ should to be a closed type of kind $*$,
which does not contain any free type variables or index variables.
For example, $(\textit{List}\,X -> *)$ is not a well-sorted kind since $X$
appears free, while $((\forall X^{*}\!.\,\textit{List}\,X) -> *)$ is a well-sorted kind.

\paragraph{Typing contexts.}
Typing contexts are split into two parts.
Type level contexts ($\Delta$) for type level (static) bindings,
and term level contexts ($\Gamma$) for term level (dynamic) bindings.
A new form of index variable binding ($i^A$) can appear in
type level contexts in addition to the traditional type variable bindings ($X^\kappa$).
There is only one form of term level binding ($x:A$) that appears in
term level contexts.

\paragraph{Well formed typing contexts.}
A type level context $\Delta$ is well-formed if (1) it is either empty,
or (2) extended by a type variable binding $X^\kappa$ whose kind $\kappa$ is
well-sorted under $\Delta$, or (3) extended by an index binding $i^A$
whose type $A$ is well-kinded under the empty type level context at kind $*$.
This restriction is similar to the one that occurs in the sorting rule ($Ri$)
for term-indexed arrow kinds (see the paragraph {\textit{Sorting}}).
The consequence of this is that, in typing contexts and in sorts,
$A$ must be a closed type (not a type constructor!) without free variables.

A term level context $\Gamma$ is well-formed under a type level context
$\Delta$ when it is either empty or extended by a term variable binding
$x:A$ whose type $A$ is well-kinded under $\Delta$.


\paragraph{Type constructors and their kinding rules.}
We extend the type constructor syntax by three constructs,
and extend the kinding rules accordingly. %% for these new constructs.

\newFi{\lambda i^A.F} is the type level abstraction over an index
(or, index abstraction). Index abstractions introduce indexed arrow kinds
by the kinding rule \newFi{(\lambda i)}. Note, the use of the new form of context
extension, $i^A$, in the kinding rule ($\lambda i$).


\newFi{F\,\{s\}} is the type level index application. In contrast to
the ordinary type level application ($F\,G$) where the argument ($G$) is
a type constructor, the argument of an index application ($F\,\{s\}$) is
a term ($s$). We use the curly bracket notation around an index argument in a type to
emphasize the transition from ordinary type to term, and to emphasize
that $s$ is an index term, which is erasable. Index applications eliminate
indexed arrow kinds by the kinding rule \newFi{(@i)}. Note, we type check
the index term ($s$) under the current type level context paired with
the empty term level context ($\Delta;\cdot$) since we do not want
the index term ($s$) to depend on any term level bindings. Allowing such
a dependency would admit true dependent types.

\newFi{\forall i^A . B} is an index polymorphic type.
The formation of indexed polymorphic types is governed by
the kinding rule \newFi{\forall i}, which is very similar to
the formation rule ($\forall$) for ordinary polymorphic types.

In addition to the rules ($\lambda i$), ($@ i$), and ($\forall i$),
we need a conversion rule \newFi{(Conv)} at kind level. This is because
the new extension to the kind syntax $A -> \kappa$ involves types.
Since kind syntax involves types, we need more than simple structural
equality over kinds. The new equality over kinds is the usual structural equality
extended by type constructor equality when comparing indexed arrow kinds
(see \Fig{eqFi}).

\paragraph{Terms and their typing rules}
The term syntax is exactly the same as other Curry-style calclui.
We write $x$ for ordinary term variables introduced by
term level abstractions ($\lambda x.t$).
We write $i$ for index variables introduced by
index abstractions ($\lambda i^A.F$) and by
index polymorphic types ($\forall i^A.B$). As discussed earlier, the distinction between
$x$ and $i$ is for the convenience of readability.

Since \Fi\ has index polymorphic types ($\forall i^A . B$),
we need typing rules for index polymorphism:
\newFi{(\forall I i)} for index generalization
and \newFi{(\forall E i)} for index instantiation.

The index generalization rule ($\forall I i$) is similar to
the type generalization rule ($\forall I$), but generalizes over
index variables ($i$) rather than type consturctor variables ($X$).
The rule ($\forall I i$) has two side conditions
while the rule ($\forall I$) has only one.
The additional side condition $i\notin\FV(t)$ in the ($\forall I i$) rule
prevents terms from accessing the type level index variables introduced by
index polymorphism. Without this side condition, $\forall$-binder
would no longer behave polymorphicaly, but instead would behave as
a dependent function binder, which are usually denoted by $\Pi$ in
dependent type theories.
%% The rule ($\forall I$) for ordinary
%% type generalization does not need such additional side condition
%% because type variables cannot appear in the syntax of terms.
Such side conditions on generalization rules for polymorphism is fairly standard
in dependently typed languages that distinguish between polymorphism
(or, erasable arguments) and dependent functions (\eg, IPTS\cite{LingerS08},
ICC\cite{Miquel01}).

The index instantiation rule ($\forall E i$) is similar to
the type instantiation rule ($\forall E$), except that
we type check the index term $s$ to be instantiated for $i$
in the current type level context paired with the empty term level context
($\Delta;\cdot$) rather than the current term level context.
Since index terms are at type level, they should not depend on
term level bindings.

In addition to the rules ($\forall I i$) and ($\forall E i$) for
index polymorphism, we need an additional variable rule \newFi{(:i)}
to be able to access the index variables already in scope. Terms ($s$) used
at type level in index applications ($F\{s\}$) should be able to access
index variables already in scope. 

\section{Metatheory} \label{sec:theory}

The expectation is that System \Fi\ has all the nice properties of System \Fw,
yet is more expressive because of the addition of term-indexed types.

We show some basic well-formedness properties for
the judgments of \Fi\ in \S\ref{ssec:wf}.
We prove erasure properties of \Fi, which captures the idea that indices are
erasable since they are irrelevant for reduction in \S\ref{ssec:erasure}.
We show strong normalization, logical consistence, and subject reduction for
\Fi\ by reasoning about well-known calculi related to \Fi\ in \S\ref{ssec:sn}.

\subsection{Well-formedness and Substitution Lemmas} \label{ssec:wf}

We want to show that kinding and typing derivations give
well-formed results under well-formed contexts. That is,
kinding derivations result in well-sorted kinds
under well-formed type level contexts (Proposition \ref{prop:wfkind}), and
typing derivations result in well-kinded types
under well-formed type and term level contexts (Proposition \ref{prop:wftype}).
\begin{proposition}
\label{prop:wfkind}
$ \inference{ |- \Delta & \Delta |- F : \kappa}{ |- \kappa:\square } $
\end{proposition}
\begin{proposition} \label{prop:wftype}
$ \inference{ \Delta |- \Gamma & \Delta;\Gamma |- t : A}{ \Delta |- A : * } $
\end{proposition}
We can prove these well-formnedness properties
by induction over the judgment\footnote{TODO}
and using the substitition lemma below.

\begin{lemma}[substitution]\mbox{}\\[-3mm]
\label{lem:subst}
\begin{enumerate}
\item
%\begin{lemma}[type substitution]
\label{lem:tysubst}
\mbox{\rm (type substitution)}
$\inference{\Delta,X^\kappa |- F:\kappa' & \Delta |- G:\kappa}
        {\Delta |- F[G/X]:\kappa'} $
%\end{lemma}
\medskip

\item
%\begin{lemma}[index substitution]
\label{lem:ixsubst}
\mbox{\rm (index substitution)}
$ \inference{\Delta,i^A |- F:\kappa & \Delta;\cdot |- s:A}
        {\Delta |- F[s/i]:\kappa} $
%\end{lemma}
\medskip

\item
%\begin{lemma}[term substitution]
\label{lem:tmsubst}
\mbox{\rm (term substitution)}
$ \inference{\Delta;\Gamma,x:A |- t:B & \Delta;\Gamma |- s:A}
        {\Delta,\Gamma |- t[s/x]:B} $
%\end{lemma}
\end{enumerate}
\end{lemma}
These substitution lemmas are fairly standard,
comparable to substitution lemmas
in other well-known systems such as \Fw\ or ICC.


\subsection{Erasure Properties} \label{ssec:erasure}

We define a meta-operation of index erasure that projects $\Fi$-types
to $\Fw$-types.

\begin{definition}[index erasure]\label{def:ierase}
\[ \fbox{$\kappa^\circ$}
 ~~~~ ~~
 *^\circ =
 *
 ~~~~ ~~
 (\kappa_1 -> \kappa_2)^\circ =
 {\kappa_1}^\circ -> {\kappa_2}^\circ
 ~~~~ ~~
 (A -> \kappa)^\circ =
 \kappa^\circ
\]
\[ \fbox{$F^\circ$}
 ~~~~ ~~
 X^\circ =
 X
 ~~~~ ~~~~ ~~~~ ~~~~ ~~~~ ~~~~
 (A -> B)^\circ =
 A^\circ -> B^\circ
\]
\[ \qquad \qquad
 (\lambda X^\kappa.F)^\circ =
 \lambda X^{\kappa^\circ}.F^\circ
 ~~~~ ~~~
 (\lambda i^A.F)^\circ =
 F^\circ
\]
\[ \qquad \qquad
 (F\;G)^\circ =
 F^\circ\;G^\circ
 ~~~~ ~~~~ ~~~~ ~~
 (F\,\{s\})^\circ =
 F^\circ
\]
\[ \qquad \qquad
 (\forall X^\kappa . B)^\circ =
 \forall X^{\kappa^\circ} . B^\circ
 ~~~~ ~~~
 (\forall i^A . B)^\circ =
 B^\circ
\]
\[ \fbox{$\Delta^\circ$}
 ~~~~
 \cdot^\circ = \cdot
 ~~~~ ~~
 (\Delta,X^\kappa)^\circ = \Delta^\circ,X^{\kappa^\circ}
 ~~~~ ~~
 (\Delta,i^A)^\circ = \Delta^\circ
\]
\[ \fbox{$\Gamma^\circ$}
 ~~~~
 \cdot^\circ = \cdot
 ~~~~ ~~~~
 (\Gamma,x:A)^\circ = \Gamma^\circ,x:A^\circ
\]
\end{definition}

\begin{definition}[index variable selection]
        \[ \fbox{$\Delta^\bullet$} ~~~~ ~~ \cdot^\bullet = \cdot \qquad
        (\Delta,X^\kappa)^\bullet = \Delta^\bullet \qquad
        (\Delta,i^A)^\bullet = \Delta^\bullet,i:A
\]
\end{definition}



\begin{theorem}[index erasure on well-sorted kinds]
\label{thm:ierasesorting}
        $\inference{|- \kappa : \square}{|- \kappa^\circ : \square}$
\end{theorem}
\begin{proof}
        By induction on the sort ($\kappa$).
\end{proof}
\begin{remark}
For any well-sorted kind $\kappa$ in \Fi,
$\kappa^\circ$ is a kind in \Fw.
\end{remark}

\begin{theorem}[index erasure on well-formed type level contexts]
\label{thm:ierasetyctx}
$ \inference{|- \Delta}{|- \Delta^\circ} $
\end{theorem}
\begin{proof}
        By induction on the type level context ($\Delta$)
        and using Theorem \ref{thm:ierasesorting}.
\end{proof}
\begin{remark}
For any well-formed type level context $\Delta$ in \Fi,
$\Delta^\circ$ is a well-formed type level context in \Fw.
\end{remark}

\begin{theorem}[index erasure on kind equality]\label{thm:ierasekindeq}
$ \inference{|- \kappa=\kappa':\square}
        {|- \kappa^\circ=\kappa'^\circ:\square}
$
\end{theorem}
\begin{proof}
        By induction on the kind equality judgement.
\end{proof}
\begin{remark}
For any well-sorted kind equality $|- \kappa=\kappa':\square$ in \Fi,
$\kappa^\circ$ and $\kappa'^\circ$ are the syntactically same \Fw\ kinds.
Note that no variables can appear in the erased kinds by definition of
the erasure operation on kinds.
\end{remark}

\begin{theorem}[index erasure on well-kinded type constructors]
\label{thm:ierasekinding}
\[ \inference{|- \Delta & \Delta |- F : \kappa}
                {\Delta^\circ |- F^\circ : \kappa^\circ}
\]
\end{theorem}
\begin{remark} TODO
\end{remark}


\begin{theorem}[index erasure on type constructor equality]
\label{thm:ierasetyconeq}
\[ \inference{\Delta |- F=F':\kappa}
                {\Delta^\circ |- F^\circ=F'^\circ:\kappa^\circ}
\]
\end{theorem}
\begin{remark} TODO
\end{remark}

\begin{theorem}[index erasure on well-formed term level contexts
                prepended by index variable selection]
\label{thm:ierasetmctxivs}
\[ \inference{\Delta |- \Gamma}{\Delta^\circ |- (\Delta^\bullet,\Gamma)^\circ}
\]
\end{theorem}

\begin{theorem}[index erasure on well-typed terms]
\label{thm:ierasetypingall}
$ \inference{\Delta |- \Gamma & \Delta;\Gamma |- t : A}
                {\Delta^\circ;(\Delta^\bullet,\Gamma)^\circ |- t : A^\circ}
$
\end{theorem}

\begin{corollary}[index erasure on index-free well-typed terms]
\label{thm:ierasetypingifree}
\[ \inference{ \Delta |- \Gamma & \Delta;\Gamma |- t : A}
                {\Delta^\circ;\Gamma^\circ |- t : A^\circ}
                {\enspace(\dom(\Delta)\cap\FV(t) = \emptyset)}
\]
\end{corollary}

\subsection{Strong Normalization and Logical Consistency} \label{ssec:sn}
Strong normalization is a corollary of the erasure property since we know that
System~\Fw\ is strongly normalizing. Logical consistency is immediate since
System~\Fi\ is a strict subset of the \emph{restricted implicit calculus}
\cite{Miquel00}, which is in turn a restriction of ICC~\cite{Miquel01}.
Subject reduction is also immediate for the same reason.

\section{Related Work} \label{sec:relwork}
TODO

\section{TODO}
TODO

\bibliographystyle{splncsnat}
\bibliography{main}

%% \newpage
%% \appendix

\end{document}
