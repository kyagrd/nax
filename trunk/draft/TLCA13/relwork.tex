\section{Related Work} \label{sec:relwork}
System~\Fi\ is most closely related to
Curry-style System~\Fw \cite{AbeMatUus03,AbeMatUus05,GHR93}
and the Implicit Calculus of Constructions (ICC) \cite{Miquel01}.
All terms typable in a Curry-style System \Fw\ are typable (with the same type) in System \Fi\ 
and all terms typable in \Fi\ are typable (with the same type\footnote{The $*$ kind in \Fw\ and \Fi\ corresponds
	to \textsf{Set} in ICC}) in ICC.

We can derive strong normalization, logical consistency,
and subject reduction of System~\Fi, from both System~\Fw\ and a subset of ICC.
In fact, ICC is more than just an extension of System~\Fi
with dependent types and stratified universes. ICC includes
$\eta$-reduction
and the extensionality typing rule. We do not foresee any problems adding
$\eta$-reduction and the extensionality typing rule to System~\Fi. Although
System~\Fi\ accepts fewer terms than ICC, it enjoys simpler
erasure properties (Theorem \ref{thm:ierasetypingifree} and
Theorem \ref{thm:ierasetypingall}), which ICC cannot enjoy
due to its support for full dependent types. In System \Fi, index terms
appearing in types (\eg,~$s$ in $F\{s\}$) are always erasable.
\citet{LingerS08} generalized the ICC framework to one which describes
erasure on arbitrary Church-style calculi~(EPTS) and Curry-style
calculi~(IPTS), but they only consider $\beta$-equivalence for type conversion.


In the practical setting of programming language implementations,
\citet{YorgeyWCJVM12}, inspired by \citet{SHE}, designed an extension
to Haskell, allowing datatypes to be used as kinds. For instance, \texttt{Bool}
is promoted to a kind (\ie, $\texttt{Bool}:\square$) and its data constructors
\texttt{True} and \texttt{False} are promoted to types. To support this,
they extended System $F_{\!C}$ (The Glasgow Haskell Compiler's (GHC) intermediate core language), 
naming the extension System $F_{\!C}^\uparrow$.
The key difference between $F_{\!C}^\uparrow$ and \Fi\ is the kind syntax, as illustrated below: \vspace*{-2pt}
\[\qquad\quad
\begin{array}{ll}
F_{\!C}^\uparrow\,\textbf{kinds}: &
\kappa ::= * \mid \kappa -> \kappa \mid F \vec{\kappa} \mid \mathcal{X} \mid \forall \mathcal{X}.\kappa \mid \cdots \\
\,\Fi\,\,\textbf{kinds}: &
\kappa ::= * \mid \kappa -> \kappa \mid A -> \kappa \phantom{A^{A^A}}
\end{array}  
\] ~\vspace*{-6pt}\\
In $F_{\!C}^\uparrow$, all type constructors ($F$) are promotable to the 
kind level and become kinds when fully applied to other kinds
($F\vec\kappa$). On the other hand, in \Fi,  a type can only appear
as the domain of an index arrow kind ($A-> \kappa$). This seemingly small
difference allows $F_{\!C}^\uparrow$ to be a much
more expressive language than \Fi. The promotion of
a type constructor, for instance, $\texttt{List}:* -> *$ to a kind constructor
$\texttt{List}:\square-> \square$ enables type-level data structures
such as $\mathtt{[Nat,Bool,Nat-> Bool]:List\,*}$. Type-level
data structures motivate type-level computations over promoted data.
This is made possible by type families\footnote{
	A GHC extension to define type-level functions in Haskell.}.
The promotion of polymorphic types naturally motivates
kind polymorphism ($\forall \mathcal{X}.\kappa$), which is known to
break strong normalization and cause logical inconsistency \cite{Girard72}.
In a functional {\em programming language},
inconsistency is not an issue. However, when studying
term-indexed datatypes in a logically consistent calculi, we need
a more conservative approach, as in System \Fi.

